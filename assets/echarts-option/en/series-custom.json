{
    "id": {
        "desc": " Component ID, not specified by default. If specified, it can be used to refer the component in option or API. "
    },
    "name": {
        "desc": " Series name used for displaying in [tooltip][0] and filtering with [legend][1], or updating data and configuration with setOption.\n\n[0]: #tooltip\n[1]: #legend"
    },
    "colorBy": {
        "desc": ">  Since > v5.2.0 The policy to take color from [option.color][0]. Valid values: \n\n* 'series': assigns the colors in the palette by series, so that all data in the same series are in the same color;\n* 'data': assigns colors in the palette according to data items, with each data item using a different color.\n\n\n\n[0]: #color"
    },
    "legendHoverLink": {
        "desc": " Whether to enable highlighting chart when [legend][0] is being hovered.\n\n[0]: #legend",
        "uiControl": {
            "type": "boolean",
            "default": "true"
        }
    },
    "coordinateSystem": {
        "desc": " The coordinate used in the series, whose options are: \n\n* null or 'none' No coordinate.\n\n* 'cartesian2d' Use a two-dimensional rectangular coordinate (also known as Cartesian coordinate), with [xAxisIndex][0] and [yAxisIndex][1] to assign the corresponding axis component.\n\n* 'polar' Use polar coordinates, with [polarIndex][2] to assign the corresponding polar coordinate component.\n\n* 'geo' Use geographic coordinate, with [geoIndex][3] to assign the corresponding geographic coordinate components.\n\n* 'none' Do not use coordinate system.\n\n\n\n[0]: #series-custom.xAxisIndex\n[1]: #series-custom.yAxisIndex\n[2]: #series-custom.polarIndex\n[3]: #series-custom.geoIndex"
    },
    "xAxisIndex": {
        "desc": " Index of [x axis][0] to combine with, which is useful for multiple x axes in one chart.\n\n[0]: #xAxis"
    },
    "yAxisIndex": {
        "desc": " Index of [y axis][0] to combine with, which is useful for multiple y axes in one chart.\n\n[0]: #yAxis"
    },
    "polarIndex": {
        "desc": " Index of [polar coordinate][0] to combine with, which is useful for multiple polar axes in one chart.\n\n[0]: #polar"
    },
    "geoIndex": {
        "desc": " Index of [geographic coordinate][0] to combine with, which is useful for multiple geographic axes in one chart.\n\n[0]: #geo"
    },
    "calendarIndex": {
        "desc": " Index of [calendar coordinates][0] to combine with, which is useful for multiple calendar coordinates in one chart.\n\n[0]: #calendar"
    },
    "renderItem": {
        "desc": "custom series requires developers to write a render logic by themselves. This render logic is called [renderItem][0]. For example: \n\n    var option = {\n        ...,\n        series: [{\n            type: 'custom',\n            renderItem: function (params, api) {\n                var categoryIndex = api.value(0);\n                var start = api.coord([api.value(1), categoryIndex]);\n                var end = api.coord([api.value(2), categoryIndex]);\n                var height = api.size([0, 1])[1] * 0.6;\n    \n                var rectShape = echarts.graphic.clipRectByRect({\n                    x: start[0],\n                    y: start[1] - height / 2,\n                    width: end[0] - start[0],\n                    height: height\n                }, {\n                    x: params.coordSys.x,\n                    y: params.coordSys.y,\n                    width: params.coordSys.width,\n                    height: params.coordSys.height\n                });\n    \n                return rectShape && {\n                    type: 'rect',\n                    shape: rectShape,\n                    style: api.style()\n                };\n            },\n            data: data\n        }]\n    }\n    \n\n[renderItem][0] will be called on each data item. [renderItem][0] provides two parameters: \n\n* [params][1]: provides info about the current series and data and coordinate system.\n* [api][2]: includes some methods.\n\n[renderItem][0] method should returns graphic elements definitions.See [renderItem.return][3]. Generally, the main process of [renderItem][0] is that retrieve value from data and convert them to graphic elements on the current coordinate system. Two methods in [renderItem.arguments.api][2] are always used in this procedure: \n\n* [api.value(...)][4] is used to retrieve value from data. For example, api.value(0) retrieve the value of the first dimension in the current data item.\n* [api.coord(...)][5] is used to convert data to coordinate. For example, var point = api.coord([api.value(0), api.value(1)]) converet the data to the point on the current coordinate system.\n\nSometimes [api.size(...)][6] method is needed, which calculates the size on the coordinate system by a given data range. Moreover, [api.style(...)][7] method can be used to set style. It provides not only the style settings specified in [series.itemStyle][8], but also the result of visual mapping. This method can also be called like api.style({fill: 'green', stroke: 'yellow'}) to override those style settings.\n\n[0]: #series-custom.renderItem\n[1]: #series-custom.renderItem.arguments.params\n[2]: #series-custom.renderItem.arguments.api\n[3]: #series-custom.renderItem.return\n[4]: #series-custom.renderItem.arguments.api.value\n[5]: #series-custom.renderItem.arguments.api.coord\n[6]: #series-custom.renderItem.arguments.api.size\n[7]: #series-custom.renderItem.arguments.api.style\n[8]: #series-custom.itemStyle"
    },
    "renderItem.arguments": {
        "desc": " Parameters of renderItem. "
    },
    "renderItem.arguments.params": {
        "desc": " The first parameter of renderItem, including: \n\n    {\n        context: // {string} An object that developers can store something temporarily here. Life cycle: current round of rendering.\n        seriesId: // {string} The id of this series.\n        seriesName: // {string} The name of this series.\n        seriesIndex: // {number} The index of this series.\n        dataIndex: // {number} The index of this data item.\n        dataIndexInside: // {number} The index of this data item in the current data window (see dataZoom).\n        dataInsideLength: // {number} The count of data in the current data window (see dataZoom).\n        actionType: // {string} The type of action that trigger this render.\n        coordSys: // coordSys is variable by different types of coordinate systems:\n        coordSys: {\n            type: 'cartesian2d',\n            x: // {number} x of grid rect\n            y: // {number} y of grid rect\n            width: // {number} width of grid rect\n            height: // {number} height of grid rect\n        },\n        coordSys: {\n            type: 'calendar',\n            x: // {number} x of calendar rect\n            y: // {number} y of calendar rect\n            width: // {number} width of calendar rect\n            height: // {number} height of calendar rect\n            cellWidth: // {number} calendar cellWidth\n            cellHeight: // {number} calendar cellHeight\n            rangeInfo: {\n                start: // date start of calendar.\n                end: // date end of calendar.\n                weeks: // number of weeks in calendar.\n                dayCount: // day count in calendar.\n            }\n        },\n        coordSys: {\n            type: 'geo',\n            x: // {number} x of geo rect\n            y: // {number} y of geo rect\n            width: // {number} width of geo rect\n            height: // {number} height of geo rect\n            zoom: // {number} zoom ratio, 1 if no zoom, 0.5 means shrink to 50%.\n        },\n        coordSys: {\n            type: 'polar',\n            cx: // {number} x of polar center.\n            cy: // {number} y of polar center.\n            r: // {number} outer radius of polar.\n            r0: // {number} inner radius of polar.\n        },\n        coordSys: {\n            type: 'singleAxis',\n            x: // {number} x of singleAxis rect\n            y: // {number} y of singleAxis rect\n            width: // {number} width of singleAxis rect\n            height: // {number} height of singleAxis rect\n        }\n    }\n    \n\nDifference between dataIndex and dataIndexInside: \n\n* dataIndex is the index of a dataItem in the original data.\n* dataIndexInside is the index of a dataItem in the current data window (see [dataZoom][0].\n\n[renderItem.arguments.api][1] uses dataIndexInside as the input parameter but not dataIndex, because conversion from dataIndex to dataIndexInside is time-consuming.\n\n[0]: #dataZoom\n[1]: #series-custom.renderItem.arguments.api"
    },
    "renderItem.arguments.api": {
        "desc": " The second parameter of renderItem. "
    },
    "renderItem.arguments.api.value": {
        "desc": " Get value on the given dimension. \n\n    @param {number} dimension The given dimension. (index from 0).\n    @param {number} [dataIndexInside] In most cases it is not necessary.\n    @return {number} The value.\n    \n\n"
    },
    "renderItem.arguments.api.coord": {
        "desc": " Convert data to coordinate. \n\n    @param {Array.} data.\n    @return {Array.} Point on canvas, at least includes [x, y].\n            In polar, it also contains:\n            polar: [x, y, radius, angle]\n    \n\n"
    },
    "renderItem.arguments.api.size": {
        "desc": " Get the size by the given data range. For example, in cartesian2d, suppose calling api.size([2, 4]) returns [12.4, 55]. It represents that on x axis, data range 2 corresponds to size 12.4, and on y axis data range 4 corresponds to size 55. In some coordinate systems (for example, polar) or when log axis is used, the size is different in different point. So the second parameter is necessary to calculate size on the given point. \n\n    @param {Array.} dataSize Data range.\n    @param {Array.} dataItem The point where the size will be calculated.\n    @return {Array.} The size.\n    \n\n"
    },
    "renderItem.arguments.api.style": {
        "desc": " The method obtains style info defined in [series.itemStyle][0], and visual info obtained by visual mapping, and return them. Those returned info can be assigned to style attribute of graphic element definition directly. Developers can also override style info by calling this method like this: api.style({fill: 'green', stroke: 'yellow'}). \n\n    @param {Object} [extra] Extra style info.\n    @param {number} [dataIndexInside] In most cases, this parameter is not necessary.\n    @return {Object} Style info, which can be assigned to `style` attribute of graphic element definition directly.\n    \n\n[0]: #series-custom.itemStyle"
    },
    "renderItem.arguments.api.styleEmphasis": {
        "desc": " The method obtains style info defined in [series.itemStyle.emphasis][0], and visual info obtained by visual mapping, and return them. Those returned info can be assigned to style attribute of graphic element definition directly. Developers can also override style info by calling this method like this: api.style({fill: 'green', stroke: 'yellow'}). \n\n    @param {Object} [extra] Extra style info.\n    @param {number} [dataIndexInside] In most cases, this parameter is not necessary.\n    @return {Object} Style info, which can be assigned to `style` attribute of graphic element definition directly.\n    \n\n[0]: #series-custom.itemStyle.emphasis"
    },
    "renderItem.arguments.api.visual": {
        "desc": " Get the visual info. It is rarely be used. \n\n    @param {string} visualType 'color', 'symbol', 'symbolSize', ...\n    @param {number} [dataIndexInside] In most cases, this parameter is not necessary.\n    @return {string|number} The value of visual.\n    \n\n"
    },
    "renderItem.arguments.api.barLayout": {
        "desc": " When barLayout is needed, (for example, when attaching some extra graphic elements to bar chart), this method can be used to obtain bar layout info. See a [sample][0]. \n\n    @param {Object} opt\n    @param {number} opt.count How many bars in each group.\n    @param {number|string} [opt.barWidth] Width of a bar.\n            Can be an absolute value like `40` or a percent value like `'60%'`.\n            The percent is based on the calculated category width.\n    @param {number|string} [opt.barMaxWidth] Max width of a bar.\n            Can be an absolute value like `40` or a percent value like `'60%'`.\n            The percent is based on the calculated category width.\n            Has higer priority than `opt.barWidth`.\n    @param {number|string} [opt.barMinWidth] Min width of a bar.\n            Can be an absolute value like `40` or a percent value like `'60%'`.\n            The percent is based on the calculated category width.\n            Has higer priority than `opt.barWidth`.\n    @param {number} [opt.barGap] Gap of bars in a group.\n    @param {number} [opt.barCategoryGap] Gap of groups.\n    @return {Array.} [{\n            width: {number} Width of a bar.\n            offset: {number} Offset of a bar, based on the left most edge.\n            offsetCenter: {number} bar Offset of a bar, based on the center of the bar.\n        }, ...]\n    \n\n[0]: https://echarts.apache.org/examples/en/editor.html?c=custom-bar-trend"
    },
    "renderItem.arguments.api.currentSeriesIndices": {
        "desc": " Obtain the current series index. Notice that the currentSeriesIndex is different from seriesIndex when legend is used to filter some series. \n\n    @return {number}\n    \n\n"
    },
    "renderItem.arguments.api.font": {
        "desc": " Obtain font string, which can be used on style setting directly. \n\n    @param {Object} opt\n    @param {string} [opt.fontStyle]\n    @param {number} [opt.fontWeight]\n    @param {number} [opt.fontSize]\n    @param {string} [opt.fontFamily]\n    @return {string} font string.\n    \n\n"
    },
    "renderItem.arguments.api.getWidth": {
        "desc": "    @return {number} Width of echarts containter.\n    \n\n"
    },
    "renderItem.arguments.api.getHeight": {
        "desc": "    @return {number} Height of echarts container.\n    \n\n"
    },
    "renderItem.arguments.api.getZr": {
        "desc": "    @return {module:zrender} zrender instance.\n    \n\n"
    },
    "renderItem.arguments.api.getDevicePixelRatio": {
        "desc": "    @return {number} The current devicePixelRatio.\n    \n\n"
    },
    "renderItem.return": {
        "desc": "renderItem should returns graphic element definitions. Each graphic element is an object. See [graphic][0] for detailed info. (But width\\height\\top\\bottom is not supported here) If nothing should be rendered in this data item, just returns nothing. For example: \n\n    // Returns a rectangular.\n    {\n        type: 'rect',\n        shape: {\n            x: x, y: y, width: width, height: height\n        },\n        style: api.style()\n    }\n    \n\n    // Returns a group of elements.\n    {\n        type: 'group',\n        // If diffChildrenByName is set as `true`, `child.name` will be used\n        // to diff children, which improves animation transition but degrade\n        // performance. The default value is `false`.\n        // diffChildrenByName: true,\n        children: [{\n            type: 'circle',\n            shape: {\n                cx: cx, cy: cy, r: r\n            },\n            style: api.style()\n        }, {\n            type: 'line',\n            shape: {\n                x1: x1, y1: y1, x2: x2, y2: y2\n            },\n            style: api.style()\n        }]\n    }\n    \n\n\n\n[0]: #graphic.elements"
    },
    "renderItem.return_group": {
        "desc": "group is the only type that can contain children, so that a group of elements can be positioned and transformed together. "
    },
    "renderItem.return_group.type": {
        "desc": " Must be specified when define a graphic element at the first time. Optional values: [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #series-custom.renderItem.return_image\n[1]: #series-custom.renderItem.return_text\n[2]: #series-custom.renderItem.return_circle\n[3]: #series-custom.renderItem.return_sector\n[4]: #series-custom.renderItem.return_ring\n[5]: #series-custom.renderItem.return_polygon\n[6]: #series-custom.renderItem.return_polyline\n[7]: #series-custom.renderItem.return_rect\n[8]: #series-custom.renderItem.return_line\n[9]: #series-custom.renderItem.return_bezierCurve\n[10]: #series-custom.renderItem.return_arc\n[11]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_group.id": {
        "desc": " id is used to specifying element when willing to update it. id can be ignored if you do not need it. "
    },
    "renderItem.return_group.x": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_group.x\n[1]: #series-custom.renderItem.return_group.y\n[2]: #series-custom.renderItem.return_group.rotation\n[3]: #series-custom.renderItem.return_group.scaleX\n[4]: #series-custom.renderItem.return_group.scaleY\n[5]: #series-custom.renderItem.return_group.originX\n[6]: #series-custom.renderItem.return_group.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_group.y": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_group.x\n[1]: #series-custom.renderItem.return_group.y\n[2]: #series-custom.renderItem.return_group.rotation\n[3]: #series-custom.renderItem.return_group.scaleX\n[4]: #series-custom.renderItem.return_group.scaleY\n[5]: #series-custom.renderItem.return_group.originX\n[6]: #series-custom.renderItem.return_group.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_group.rotation": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_group.x\n[1]: #series-custom.renderItem.return_group.y\n[2]: #series-custom.renderItem.return_group.rotation\n[3]: #series-custom.renderItem.return_group.scaleX\n[4]: #series-custom.renderItem.return_group.scaleY\n[5]: #series-custom.renderItem.return_group.originX\n[6]: #series-custom.renderItem.return_group.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_group.scaleX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_group.x\n[1]: #series-custom.renderItem.return_group.y\n[2]: #series-custom.renderItem.return_group.rotation\n[3]: #series-custom.renderItem.return_group.scaleX\n[4]: #series-custom.renderItem.return_group.scaleY\n[5]: #series-custom.renderItem.return_group.originX\n[6]: #series-custom.renderItem.return_group.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_group.scaleY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_group.x\n[1]: #series-custom.renderItem.return_group.y\n[2]: #series-custom.renderItem.return_group.rotation\n[3]: #series-custom.renderItem.return_group.scaleX\n[4]: #series-custom.renderItem.return_group.scaleY\n[5]: #series-custom.renderItem.return_group.originX\n[6]: #series-custom.renderItem.return_group.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_group.originX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_group.x\n[1]: #series-custom.renderItem.return_group.y\n[2]: #series-custom.renderItem.return_group.rotation\n[3]: #series-custom.renderItem.return_group.scaleX\n[4]: #series-custom.renderItem.return_group.scaleY\n[5]: #series-custom.renderItem.return_group.originX\n[6]: #series-custom.renderItem.return_group.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_group.originY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_group.x\n[1]: #series-custom.renderItem.return_group.y\n[2]: #series-custom.renderItem.return_group.rotation\n[3]: #series-custom.renderItem.return_group.scaleX\n[4]: #series-custom.renderItem.return_group.scaleY\n[5]: #series-custom.renderItem.return_group.originX\n[6]: #series-custom.renderItem.return_group.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_group.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. The properties can only be: \n\n* Transform related properties: ['x'][0], ['y'][1], ['scaleX'][2], ['scaleY'][3], ['rotation'][4], ['originX'][5], ['originY'][6]. For example:\n\n      renderItem: function (params, api) {\n          var coord = api.coord([api.value(0), api.value[1]);\n          return {\n              type: 'rect',\n              x: coord[0],\n              y: coord[1],\n              shape: {\n                  x: 0,\n                  y: 0,\n                  width: api.value(2),\n                  height: 100\n              },\n              transition: ['x', 'y', 'width']\n          }\n      }\n* Shortcut to transition all of the properties in ['shape'][7], ['style'][8], ['extra'][9]. For example:\n\n      renderItem: function (params, api) {\n          return {\n              type: 'rect',\n              shape: {\n                  x: api.value(0),\n                  y: api.value(1),\n                  width: api.value(2),\n                  height: api.value(3)\n              },\n              // Indicate that all props in `shape` will\n              // have transition animation.\n              transition: 'shape',\n          };\n      }\n    \n\nIt is equivalent to:\n\n      renderItem: function (params, api) {\n          return {\n              type: 'rect',\n              shape: {\n                  x: api.value(0),\n                  y: api.value(1),\n                  width: api.value(2),\n                  height: api.value(3),\n                  // This usage can only enable part of the\n                  // properties transition.\n                  transition: ['x', 'y', 'width', 'height']\n              }\n          };\n      }\n\nBy default, ['x'][0] and ['y'][1] are transitioned. If you want to disable the default transition, just set it as: \n\n    transition: [] // Am empty array.\n    \n\nSee this [example][10] please.\n\n[0]: #series-custom.renderItem.return_group.x\n[1]: #series-custom.renderItem.return_group.y\n[2]: #series-custom.renderItem.return_group.scaleX\n[3]: #series-custom.renderItem.return_group.scaleY\n[4]: #series-custom.renderItem.return_group.rotation\n[5]: #series-custom.renderItem.return_group.originX\n[6]: #series-custom.renderItem.return_group.originY\n[7]: #series-custom.renderItem.return_group.shape\n[8]: #series-custom.renderItem.return_group.style\n[9]: #series-custom.renderItem.return_group.extra\n[10]: https://echarts.apache.org/examples/en/editor.html?c=doc-example/custom-transition-simple&edit=1&reset=1"
    },
    "renderItem.return_group.z2": {
        "desc": " Define the overlap relationship between graphic elements. "
    },
    "renderItem.return_group.name": {
        "desc": " See [diffChildrenByName][0].\n\n[0]: #series-custom.renderItem.return_group.diffChildrenByName"
    },
    "renderItem.return_group.info": {
        "desc": " User defined data, can be visited in event listeners. \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "renderItem.return_group.silent": {
        "desc": " Whether response to mouse events / touch events. "
    },
    "renderItem.return_group.invisible": {
        "desc": " Whether the element is visible. "
    },
    "renderItem.return_group.ignore": {
        "desc": " Whether the element is totally ignored (neither render nor listen events). "
    },
    "renderItem.return_group.textContent": {
        "desc": " Text block attached to an element and layout based on the element by textConfig. The props the the same as [text][0].\n\n[0]: option.html#series-custom.renderItem.return_text"
    },
    "renderItem.return_group.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "renderItem.return_group.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "renderItem.return_group.textConfig.rotation": {
        "desc": " Rotation of textContent. In radian. "
    },
    "renderItem.return_group.textConfig.layoutRect": {
        "desc": " Rect that textContent will be positioned. Default to be the bounding box of host element. \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "renderItem.return_group.textConfig.offset": {
        "desc": " Offset of the textContent. The difference of offset and position is that offset will be applied in the rotation. "
    },
    "renderItem.return_group.textConfig.origin": {
        "desc": "origin is relative to the bounding box of the host element. Can be percent value. Relative to the bounding box. If 'center' specified, it will be center of the bounding box. Only available when position and rotation are both set. \n\n* like [12, 33]\n* or like ['50%', '50%']\n* 'center'\n\n"
    },
    "renderItem.return_group.textConfig.distance": {
        "desc": " Distance to the layoutRectã€‚ "
    },
    "renderItem.return_group.textConfig.local": {
        "desc": " If true, it will apply host's transform. "
    },
    "renderItem.return_group.textConfig.insideFill": {
        "desc": "insideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" In most cases, \"auto-calculated-fill\" is white. "
    },
    "renderItem.return_group.textConfig.insideStroke": {
        "desc": "insideStroke is a color string or left empty. If a textContent is \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be the same as fill of this element if possible, or null.\n\n"
    },
    "renderItem.return_group.textConfig.outsideFill": {
        "desc": "outsideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "renderItem.return_group.textConfig.outsideStroke": {
        "desc": "outsideStroke is a color string or left empty. If a textContent is not \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be a near white color to distinguish \"front end\" label with messy background (like other text label, line or other graphic).\n\n"
    },
    "renderItem.return_group.textConfig.inside": {
        "desc": " Tell echarts that I can make sure this text is inside or not. "
    },
    "renderItem.return_group.during": {
        "desc": "during callback enable users to set props to an element in each animation frame. \n\n    (duringAPI: CustomDuringAPI) => void\n    \n    interface CustomDuringAPI {\n        // Set transform prop value.\n        // Transform prop see `TransformProp`.\n        setTransform(key: TransformProp, val: unknown): void;\n        // Get transform prop value of the current animation frame.\n        getTransform(key: TransformProp): unknown;\n        // Set shape prop value.\n        // Shape prop is like `{ type: 'rect', shape: { xxxProp: xxxValue } }`.\n        setShape(key: string, val: unknown): void;\n        // Get shape prop value of the current animation frame.\n        getShape(key: string): unknown;\n        // Set style prop value.\n        // Style prop is like `{ type: 'rect', style: { xxxProp: xxxValue } }`.\n        setStyle(key: string, val: unknown): void;\n        // Get style prop value of the current animation frame.\n        getStyle(key: string): unknown;\n        // Set extra prop value.\n        // Extra prop is like `{ type: 'rect', extra: { xxxProp: xxxValue } }`.\n        setExtra(key: string, val: unknown): void;\n        // Get extra prop value of the current animation frame.\n        getExtra(key: string): unknown;\n    }\n    \n    type TransformProp =\n        'x' | 'y' | 'scaleX' | 'scaleY' | 'originX' | 'originY' | 'rotation';\n    \n\nIn most cases users do not need this during callback. For example, if some props are specified in [transition][0], echarts will make interpolation for these props internally and therefore have animation based on these props automatically. But if this kind of internal interpolation does not match the user requirements of animation, users can use this during callback to customize them. For example, if users are using [polygon][1] shape. The shape is described by [shape.points][2], which is an points array like: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: [[12, 33], [15, 36], [19, 39], ...]\n        },\n        // ...\n    }\n    \n\nIf users specify them into [transition][3] like: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: [[12, 33], [15, 36], [19, 39], ...],\n        },\n        transition: 'shape'\n        // ...\n    }\n    \n\nAlthough the points will be interpolated, the consequent animation will be like that each point runs straight to the target position, which might do not match the user requirement if some kind of track like spiral is actually needed. In this case, users can use the during callback like that: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: calculatePoints(initialDegree),\n            transition: 'points'\n        },\n        extra: {\n            degree: nextDegree\n        },\n        // Make echarts interpolate `extra.degree` internally, based on which\n        // we calculate the `points` in each animation frame.\n        transition: 'extra',\n        during: function (duringAPI) {\n            var currentDegree = duringAPI.getExtra('degree');\n            duringAPI.setShape(calculatePoints(currentDegree));\n        }\n        // ...\n    }\n    \n\nSee this example [example][4].\n\n[0]: option.html#series-custom.renderItem.return_rect.transition\n[1]: option.html#series-custom.renderItem.return_polygon\n[2]: option.html#series-custom.renderItem.return_polygon.shape.points\n[3]: option.html#series-custom.renderItem.return_polygon.transition\n[4]: https://echarts.apache.org/examples/en/editor.html?c=custom-spiral-race&edit=1&reset=1"
    },
    "renderItem.return_group.extra": {
        "desc": " Users can define their own props in this extra field. See [during][0] for the major usage of extra.\n\n[0]: option.html#series-custom.renderItem.return_rect.during"
    },
    "renderItem.return_group.extra.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this extra. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            extra: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            extra: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `extra` will\n            // have transition animation.\n            transition: 'extra',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_group.width": {
        "desc": " Specify width of this group. This width is only used for the positioning of its children. When width is 0, children can also be positioned according to its parent using left: 'center'. "
    },
    "renderItem.return_group.height": {
        "desc": " Specify height of this group. This height is only used for the positioning of its children. When height is 0, children can also be positioned according to its parent using top: 'middle'. "
    },
    "renderItem.return_group.diffChildrenByName": {
        "desc": " In [custom series][0], when diffChildrenByName is set as true, for each [group][1] returned from [renderItem][2], \"diff\" will be performed to its [children][3] according to the [name][4] attribute of each graphic elements. Here \"diff\" means that map the coming graphic elements to the existing graphic elements when repainting according to name, which enables the transition animation if data is modified. But notice that the operation is performance consuming, do not use it for large data amount.\n\n[0]: #series-custom\n[1]: #series-custom.renderItem.return_group\n[2]: #series-custom.renderItem\n[3]: #series-custom.renderItem.return_group.children\n[4]: #series-custom.renderItem.return_polygon.name"
    },
    "renderItem.return_group.children": {
        "desc": " A list of children, each item is a declaration of an element. "
    },
    "renderItem.return_path": {
        "desc": " Use [SVG PathData][0] to describe a path. Can be used to draw icons or any other shapes fitting the specified size by auto transforming. See examples: [icons][1] and [shapes][2]. About width/height, cover/contain, see [layout][3].\n\n[0]: http://www.w3.org/TR/SVG/paths.html#PathData\n[1]: https://echarts.apache.org/examples/en/editor.html?c=custom-calendar-icon\n[2]: https://echarts.apache.org/examples/en/editor.html?c=custom-gantt-flight\n[3]: #series-custom.renderItem.return_path.shape.layout"
    },
    "renderItem.return_path.type": {
        "desc": " Must be specified when define a graphic element at the first time. Optional values: [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #series-custom.renderItem.return_image\n[1]: #series-custom.renderItem.return_text\n[2]: #series-custom.renderItem.return_circle\n[3]: #series-custom.renderItem.return_sector\n[4]: #series-custom.renderItem.return_ring\n[5]: #series-custom.renderItem.return_polygon\n[6]: #series-custom.renderItem.return_polyline\n[7]: #series-custom.renderItem.return_rect\n[8]: #series-custom.renderItem.return_line\n[9]: #series-custom.renderItem.return_bezierCurve\n[10]: #series-custom.renderItem.return_arc\n[11]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_path.id": {
        "desc": " id is used to specifying element when willing to update it. id can be ignored if you do not need it. "
    },
    "renderItem.return_path.x": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_path.x\n[1]: #series-custom.renderItem.return_path.y\n[2]: #series-custom.renderItem.return_path.rotation\n[3]: #series-custom.renderItem.return_path.scaleX\n[4]: #series-custom.renderItem.return_path.scaleY\n[5]: #series-custom.renderItem.return_path.originX\n[6]: #series-custom.renderItem.return_path.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_path.y": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_path.x\n[1]: #series-custom.renderItem.return_path.y\n[2]: #series-custom.renderItem.return_path.rotation\n[3]: #series-custom.renderItem.return_path.scaleX\n[4]: #series-custom.renderItem.return_path.scaleY\n[5]: #series-custom.renderItem.return_path.originX\n[6]: #series-custom.renderItem.return_path.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_path.rotation": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_path.x\n[1]: #series-custom.renderItem.return_path.y\n[2]: #series-custom.renderItem.return_path.rotation\n[3]: #series-custom.renderItem.return_path.scaleX\n[4]: #series-custom.renderItem.return_path.scaleY\n[5]: #series-custom.renderItem.return_path.originX\n[6]: #series-custom.renderItem.return_path.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_path.scaleX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_path.x\n[1]: #series-custom.renderItem.return_path.y\n[2]: #series-custom.renderItem.return_path.rotation\n[3]: #series-custom.renderItem.return_path.scaleX\n[4]: #series-custom.renderItem.return_path.scaleY\n[5]: #series-custom.renderItem.return_path.originX\n[6]: #series-custom.renderItem.return_path.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_path.scaleY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_path.x\n[1]: #series-custom.renderItem.return_path.y\n[2]: #series-custom.renderItem.return_path.rotation\n[3]: #series-custom.renderItem.return_path.scaleX\n[4]: #series-custom.renderItem.return_path.scaleY\n[5]: #series-custom.renderItem.return_path.originX\n[6]: #series-custom.renderItem.return_path.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_path.originX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_path.x\n[1]: #series-custom.renderItem.return_path.y\n[2]: #series-custom.renderItem.return_path.rotation\n[3]: #series-custom.renderItem.return_path.scaleX\n[4]: #series-custom.renderItem.return_path.scaleY\n[5]: #series-custom.renderItem.return_path.originX\n[6]: #series-custom.renderItem.return_path.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_path.originY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_path.x\n[1]: #series-custom.renderItem.return_path.y\n[2]: #series-custom.renderItem.return_path.rotation\n[3]: #series-custom.renderItem.return_path.scaleX\n[4]: #series-custom.renderItem.return_path.scaleY\n[5]: #series-custom.renderItem.return_path.originX\n[6]: #series-custom.renderItem.return_path.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_path.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. The properties can only be: \n\n* Transform related properties: ['x'][0], ['y'][1], ['scaleX'][2], ['scaleY'][3], ['rotation'][4], ['originX'][5], ['originY'][6]. For example:\n\n      renderItem: function (params, api) {\n          var coord = api.coord([api.value(0), api.value[1]);\n          return {\n              type: 'rect',\n              x: coord[0],\n              y: coord[1],\n              shape: {\n                  x: 0,\n                  y: 0,\n                  width: api.value(2),\n                  height: 100\n              },\n              transition: ['x', 'y', 'width']\n          }\n      }\n* Shortcut to transition all of the properties in ['shape'][7], ['style'][8], ['extra'][9]. For example:\n\n      renderItem: function (params, api) {\n          return {\n              type: 'rect',\n              shape: {\n                  x: api.value(0),\n                  y: api.value(1),\n                  width: api.value(2),\n                  height: api.value(3)\n              },\n              // Indicate that all props in `shape` will\n              // have transition animation.\n              transition: 'shape',\n          };\n      }\n    \n\nIt is equivalent to:\n\n      renderItem: function (params, api) {\n          return {\n              type: 'rect',\n              shape: {\n                  x: api.value(0),\n                  y: api.value(1),\n                  width: api.value(2),\n                  height: api.value(3),\n                  // This usage can only enable part of the\n                  // properties transition.\n                  transition: ['x', 'y', 'width', 'height']\n              }\n          };\n      }\n\nBy default, ['x'][0] and ['y'][1] are transitioned. If you want to disable the default transition, just set it as: \n\n    transition: [] // Am empty array.\n    \n\nSee this [example][10] please.\n\n[0]: #series-custom.renderItem.return_path.x\n[1]: #series-custom.renderItem.return_path.y\n[2]: #series-custom.renderItem.return_path.scaleX\n[3]: #series-custom.renderItem.return_path.scaleY\n[4]: #series-custom.renderItem.return_path.rotation\n[5]: #series-custom.renderItem.return_path.originX\n[6]: #series-custom.renderItem.return_path.originY\n[7]: #series-custom.renderItem.return_path.shape\n[8]: #series-custom.renderItem.return_path.style\n[9]: #series-custom.renderItem.return_path.extra\n[10]: https://echarts.apache.org/examples/en/editor.html?c=doc-example/custom-transition-simple&edit=1&reset=1"
    },
    "renderItem.return_path.morph": {
        "desc": " Whether to enable morphing animation. **When morphing animation happen?** If morph is set as true, the morphing animation will happen according to the following rule: Each time the render process happen, custom series will diff the old data and the new data. If a set of old data items (say, \"old set\") are value-equal to a set of new data items (say, \"new set\") in name or the specified dimensions (see parameter [transition][0] in setOption), we found a pair of sets as transition candidates. Three type of transition animation can be performed between the two sets: \n\n* one-to-one: if both the two sets has only one data item.\n* one-to-many(separate): if the \"old set\" has only one data item, and the \"new set\" has more than one data items.\n* many-to-one(combine): if the \"old set\" has more than one data items, and the \"new set\" has only one data item.\n\nNote: we do not support transition animation for the case many-to-many. Then custom series find graphic elements that has morph: true declared in these two sets, and map them for one to one morphing or combining or separating. See examples: [custom-one-to-one-morph][1] and [custom-combine-separate-morph][2].\n\n[0]: api.html#echartsInstance.setOption\n[1]: https://echarts.apache.org/examples/en/editor.html?c=custom-one-to-one-morph&edit=1&reset=1\n[2]: https://echarts.apache.org/examples/en/editor.html?c=custom-combine-separate-morph&edit=1&reset=1"
    },
    "renderItem.return_path.z2": {
        "desc": " Define the overlap relationship between graphic elements. "
    },
    "renderItem.return_path.name": {
        "desc": " See [diffChildrenByName][0].\n\n[0]: #series-custom.renderItem.return_path.diffChildrenByName"
    },
    "renderItem.return_path.info": {
        "desc": " User defined data, can be visited in event listeners. \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "renderItem.return_path.silent": {
        "desc": " Whether response to mouse events / touch events. "
    },
    "renderItem.return_path.invisible": {
        "desc": " Whether the element is visible. "
    },
    "renderItem.return_path.ignore": {
        "desc": " Whether the element is totally ignored (neither render nor listen events). "
    },
    "renderItem.return_path.textContent": {
        "desc": " Text block attached to an element and layout based on the element by textConfig. The props the the same as [text][0].\n\n[0]: option.html#series-custom.renderItem.return_text"
    },
    "renderItem.return_path.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "renderItem.return_path.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "renderItem.return_path.textConfig.rotation": {
        "desc": " Rotation of textContent. In radian. "
    },
    "renderItem.return_path.textConfig.layoutRect": {
        "desc": " Rect that textContent will be positioned. Default to be the bounding box of host element. \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "renderItem.return_path.textConfig.offset": {
        "desc": " Offset of the textContent. The difference of offset and position is that offset will be applied in the rotation. "
    },
    "renderItem.return_path.textConfig.origin": {
        "desc": "origin is relative to the bounding box of the host element. Can be percent value. Relative to the bounding box. If 'center' specified, it will be center of the bounding box. Only available when position and rotation are both set. \n\n* like [12, 33]\n* or like ['50%', '50%']\n* 'center'\n\n"
    },
    "renderItem.return_path.textConfig.distance": {
        "desc": " Distance to the layoutRectã€‚ "
    },
    "renderItem.return_path.textConfig.local": {
        "desc": " If true, it will apply host's transform. "
    },
    "renderItem.return_path.textConfig.insideFill": {
        "desc": "insideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" In most cases, \"auto-calculated-fill\" is white. "
    },
    "renderItem.return_path.textConfig.insideStroke": {
        "desc": "insideStroke is a color string or left empty. If a textContent is \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be the same as fill of this element if possible, or null.\n\n"
    },
    "renderItem.return_path.textConfig.outsideFill": {
        "desc": "outsideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "renderItem.return_path.textConfig.outsideStroke": {
        "desc": "outsideStroke is a color string or left empty. If a textContent is not \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be a near white color to distinguish \"front end\" label with messy background (like other text label, line or other graphic).\n\n"
    },
    "renderItem.return_path.textConfig.inside": {
        "desc": " Tell echarts that I can make sure this text is inside or not. "
    },
    "renderItem.return_path.during": {
        "desc": "during callback enable users to set props to an element in each animation frame. \n\n    (duringAPI: CustomDuringAPI) => void\n    \n    interface CustomDuringAPI {\n        // Set transform prop value.\n        // Transform prop see `TransformProp`.\n        setTransform(key: TransformProp, val: unknown): void;\n        // Get transform prop value of the current animation frame.\n        getTransform(key: TransformProp): unknown;\n        // Set shape prop value.\n        // Shape prop is like `{ type: 'rect', shape: { xxxProp: xxxValue } }`.\n        setShape(key: string, val: unknown): void;\n        // Get shape prop value of the current animation frame.\n        getShape(key: string): unknown;\n        // Set style prop value.\n        // Style prop is like `{ type: 'rect', style: { xxxProp: xxxValue } }`.\n        setStyle(key: string, val: unknown): void;\n        // Get style prop value of the current animation frame.\n        getStyle(key: string): unknown;\n        // Set extra prop value.\n        // Extra prop is like `{ type: 'rect', extra: { xxxProp: xxxValue } }`.\n        setExtra(key: string, val: unknown): void;\n        // Get extra prop value of the current animation frame.\n        getExtra(key: string): unknown;\n    }\n    \n    type TransformProp =\n        'x' | 'y' | 'scaleX' | 'scaleY' | 'originX' | 'originY' | 'rotation';\n    \n\nIn most cases users do not need this during callback. For example, if some props are specified in [transition][0], echarts will make interpolation for these props internally and therefore have animation based on these props automatically. But if this kind of internal interpolation does not match the user requirements of animation, users can use this during callback to customize them. For example, if users are using [polygon][1] shape. The shape is described by [shape.points][2], which is an points array like: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: [[12, 33], [15, 36], [19, 39], ...]\n        },\n        // ...\n    }\n    \n\nIf users specify them into [transition][3] like: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: [[12, 33], [15, 36], [19, 39], ...],\n        },\n        transition: 'shape'\n        // ...\n    }\n    \n\nAlthough the points will be interpolated, the consequent animation will be like that each point runs straight to the target position, which might do not match the user requirement if some kind of track like spiral is actually needed. In this case, users can use the during callback like that: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: calculatePoints(initialDegree),\n            transition: 'points'\n        },\n        extra: {\n            degree: nextDegree\n        },\n        // Make echarts interpolate `extra.degree` internally, based on which\n        // we calculate the `points` in each animation frame.\n        transition: 'extra',\n        during: function (duringAPI) {\n            var currentDegree = duringAPI.getExtra('degree');\n            duringAPI.setShape(calculatePoints(currentDegree));\n        }\n        // ...\n    }\n    \n\nSee this example [example][4].\n\n[0]: option.html#series-custom.renderItem.return_rect.transition\n[1]: option.html#series-custom.renderItem.return_polygon\n[2]: option.html#series-custom.renderItem.return_polygon.shape.points\n[3]: option.html#series-custom.renderItem.return_polygon.transition\n[4]: https://echarts.apache.org/examples/en/editor.html?c=custom-spiral-race&edit=1&reset=1"
    },
    "renderItem.return_path.extra": {
        "desc": " Users can define their own props in this extra field. See [during][0] for the major usage of extra.\n\n[0]: option.html#series-custom.renderItem.return_rect.during"
    },
    "renderItem.return_path.extra.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this extra. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            extra: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            extra: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `extra` will\n            // have transition animation.\n            transition: 'extra',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_path.shape": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "renderItem.return_path.shape.pathData": {
        "desc": "[SVG PathData][0]. For example, 'M0,0 L0,-20 L30,-20 C42,-20 38,-1 50,-1 L70,-1 L70,0 Z'. If [width][1], [height][2], [x][3] and [y][4] specified, pathData will be transformed to fit the defined rect. If they are not specified, do not do that. [layout][5] can be used to specify the transform strategy. See examples: [icons][6] and [shapes][7].\n\n[0]: http://www.w3.org/TR/SVG/paths.html#PathData\n[1]: #series-custom.renderItem.return_path.shape.width\n[2]: #series-custom.renderItem.return_path.shape.height\n[3]: #series-custom.renderItem.return_path.shape.x\n[4]: #series-custom.renderItem.return_path.shape.y\n[5]: #series-custom.renderItem.return_path.shape.layout\n[6]: https://echarts.apache.org/examples/en/editor.html?c=custom-calendar-icon\n[7]: https://echarts.apache.org/examples/en/editor.html?c=custom-gantt-flight"
    },
    "renderItem.return_path.shape.d": {
        "desc": " Alias of [pathData][0].\n\n[0]: #series-custom.renderItem.return_path.shape.pathData"
    },
    "renderItem.return_path.shape.layout": {
        "desc": " If [width][0], [height][1], [x][2] and [y][3] specified, pathData will be transformed to fit the defined rect. layout can be used to specify the transform strategy. Optional value: \n\n* 'center': Keep aspect ratio, put the path in the center of the rect, expand as far as possible but never overflow.\n* 'cover': Transform the path according to the aspect ratio of the rect, fill the rect and do not overflow.\n\n\n\n[0]: #series-custom.renderItem.return_path.shape.width\n[1]: #series-custom.renderItem.return_path.shape.height\n[2]: #series-custom.renderItem.return_path.shape.x\n[3]: #series-custom.renderItem.return_path.shape.y"
    },
    "renderItem.return_path.shape.x": {
        "desc": " The x value of the left-top corner of the element in the coordinate system of its parent. "
    },
    "renderItem.return_path.shape.y": {
        "desc": " The y value of the left-top corner of the element in the coordinate system of its parent. "
    },
    "renderItem.return_path.shape.width": {
        "desc": " The width of the shape of the element. "
    },
    "renderItem.return_path.shape.height": {
        "desc": " The height of the shape of the element. "
    },
    "renderItem.return_path.shape.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this shape. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            shape: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            shape: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `shape` will\n            // have transition animation.\n            transition: 'shape',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_path.style": {
        "desc": " More attributes in style (for example, [rich text][0]), see the style related attributes in [zrender/graphic/Displayable][1]. Notice, the attribute names of the style of graphic elements is derived from zrender, which may be different from the attribute names in echarts label, echarts itemStyle, etc., although they have the same meaning. For example: \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#Rich%20Text\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "renderItem.return_path.style.fill": {
        "desc": " Color filled in this element. "
    },
    "renderItem.return_path.style.stroke": {
        "desc": " Color of stroke. "
    },
    "renderItem.return_path.style.lineWidth": {
        "desc": " Width of stroke. "
    },
    "renderItem.return_path.style.shadowBlur": {
        "desc": " Width of shadow. "
    },
    "renderItem.return_path.style.shadowOffsetX": {
        "desc": " X offset of shadow. "
    },
    "renderItem.return_path.style.shadowOffsetY": {
        "desc": " Y offset of shadow. "
    },
    "renderItem.return_path.style.shadowColor": {
        "desc": " color of shadow. "
    },
    "renderItem.return_path.style.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this style. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            style: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            style: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `style` will\n            // have transition animation.\n            transition: 'style',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_path.focus": {
        "desc": ">  Since > v5.0.0 When it's highlighted, whether to fade out of other data to focus the highlighted. The following configurations are supported: \n\n* 'none' Do not fade out other data, it's by default.\n* 'self' Only focus (not fade out) the element of the currently highlighted data.\n* 'series' Focus on all elements of the series which the currently highlighted data belongs to.\n\n"
    },
    "renderItem.return_path.blurScope": {
        "desc": ">  Since > v5.0.0 The range of fade out when focus is enabled. Support the following configurations \n\n* 'coordinateSystem'\n* 'series'\n* 'global'\n\n"
    },
    "renderItem.return_path.emphasis": {
        "desc": " Emphasis state of the element. "
    },
    "renderItem.return_path.emphasis.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_path.blur": {
        "desc": ">  Since > v5.0.0 Blur state, available when focus is set. "
    },
    "renderItem.return_path.blur.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_path.select": {
        "desc": ">  Since > v5.0.0 Select state, available when [selectedMode][0] is set.\n\n[0]: #series-custom.selectedMode"
    },
    "renderItem.return_path.select.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_image": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "renderItem.return_image.type": {
        "desc": " Must be specified when define a graphic element at the first time. Optional values: [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #series-custom.renderItem.return_image\n[1]: #series-custom.renderItem.return_text\n[2]: #series-custom.renderItem.return_circle\n[3]: #series-custom.renderItem.return_sector\n[4]: #series-custom.renderItem.return_ring\n[5]: #series-custom.renderItem.return_polygon\n[6]: #series-custom.renderItem.return_polyline\n[7]: #series-custom.renderItem.return_rect\n[8]: #series-custom.renderItem.return_line\n[9]: #series-custom.renderItem.return_bezierCurve\n[10]: #series-custom.renderItem.return_arc\n[11]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_image.id": {
        "desc": " id is used to specifying element when willing to update it. id can be ignored if you do not need it. "
    },
    "renderItem.return_image.x": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_image.x\n[1]: #series-custom.renderItem.return_image.y\n[2]: #series-custom.renderItem.return_image.rotation\n[3]: #series-custom.renderItem.return_image.scaleX\n[4]: #series-custom.renderItem.return_image.scaleY\n[5]: #series-custom.renderItem.return_image.originX\n[6]: #series-custom.renderItem.return_image.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_image.y": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_image.x\n[1]: #series-custom.renderItem.return_image.y\n[2]: #series-custom.renderItem.return_image.rotation\n[3]: #series-custom.renderItem.return_image.scaleX\n[4]: #series-custom.renderItem.return_image.scaleY\n[5]: #series-custom.renderItem.return_image.originX\n[6]: #series-custom.renderItem.return_image.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_image.rotation": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_image.x\n[1]: #series-custom.renderItem.return_image.y\n[2]: #series-custom.renderItem.return_image.rotation\n[3]: #series-custom.renderItem.return_image.scaleX\n[4]: #series-custom.renderItem.return_image.scaleY\n[5]: #series-custom.renderItem.return_image.originX\n[6]: #series-custom.renderItem.return_image.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_image.scaleX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_image.x\n[1]: #series-custom.renderItem.return_image.y\n[2]: #series-custom.renderItem.return_image.rotation\n[3]: #series-custom.renderItem.return_image.scaleX\n[4]: #series-custom.renderItem.return_image.scaleY\n[5]: #series-custom.renderItem.return_image.originX\n[6]: #series-custom.renderItem.return_image.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_image.scaleY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_image.x\n[1]: #series-custom.renderItem.return_image.y\n[2]: #series-custom.renderItem.return_image.rotation\n[3]: #series-custom.renderItem.return_image.scaleX\n[4]: #series-custom.renderItem.return_image.scaleY\n[5]: #series-custom.renderItem.return_image.originX\n[6]: #series-custom.renderItem.return_image.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_image.originX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_image.x\n[1]: #series-custom.renderItem.return_image.y\n[2]: #series-custom.renderItem.return_image.rotation\n[3]: #series-custom.renderItem.return_image.scaleX\n[4]: #series-custom.renderItem.return_image.scaleY\n[5]: #series-custom.renderItem.return_image.originX\n[6]: #series-custom.renderItem.return_image.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_image.originY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_image.x\n[1]: #series-custom.renderItem.return_image.y\n[2]: #series-custom.renderItem.return_image.rotation\n[3]: #series-custom.renderItem.return_image.scaleX\n[4]: #series-custom.renderItem.return_image.scaleY\n[5]: #series-custom.renderItem.return_image.originX\n[6]: #series-custom.renderItem.return_image.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_image.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. The properties can only be: \n\n* Transform related properties: ['x'][0], ['y'][1], ['scaleX'][2], ['scaleY'][3], ['rotation'][4], ['originX'][5], ['originY'][6]. For example:\n\n      renderItem: function (params, api) {\n          var coord = api.coord([api.value(0), api.value[1]);\n          return {\n              type: 'rect',\n              x: coord[0],\n              y: coord[1],\n              shape: {\n                  x: 0,\n                  y: 0,\n                  width: api.value(2),\n                  height: 100\n              },\n              transition: ['x', 'y', 'width']\n          }\n      }\n* Shortcut to transition all of the properties in ['shape'][7], ['style'][8], ['extra'][9]. For example:\n\n      renderItem: function (params, api) {\n          return {\n              type: 'rect',\n              shape: {\n                  x: api.value(0),\n                  y: api.value(1),\n                  width: api.value(2),\n                  height: api.value(3)\n              },\n              // Indicate that all props in `shape` will\n              // have transition animation.\n              transition: 'shape',\n          };\n      }\n    \n\nIt is equivalent to:\n\n      renderItem: function (params, api) {\n          return {\n              type: 'rect',\n              shape: {\n                  x: api.value(0),\n                  y: api.value(1),\n                  width: api.value(2),\n                  height: api.value(3),\n                  // This usage can only enable part of the\n                  // properties transition.\n                  transition: ['x', 'y', 'width', 'height']\n              }\n          };\n      }\n\nBy default, ['x'][0] and ['y'][1] are transitioned. If you want to disable the default transition, just set it as: \n\n    transition: [] // Am empty array.\n    \n\nSee this [example][10] please.\n\n[0]: #series-custom.renderItem.return_image.x\n[1]: #series-custom.renderItem.return_image.y\n[2]: #series-custom.renderItem.return_image.scaleX\n[3]: #series-custom.renderItem.return_image.scaleY\n[4]: #series-custom.renderItem.return_image.rotation\n[5]: #series-custom.renderItem.return_image.originX\n[6]: #series-custom.renderItem.return_image.originY\n[7]: #series-custom.renderItem.return_image.shape\n[8]: #series-custom.renderItem.return_image.style\n[9]: #series-custom.renderItem.return_image.extra\n[10]: https://echarts.apache.org/examples/en/editor.html?c=doc-example/custom-transition-simple&edit=1&reset=1"
    },
    "renderItem.return_image.z2": {
        "desc": " Define the overlap relationship between graphic elements. "
    },
    "renderItem.return_image.name": {
        "desc": " See [diffChildrenByName][0].\n\n[0]: #series-custom.renderItem.return_image.diffChildrenByName"
    },
    "renderItem.return_image.info": {
        "desc": " User defined data, can be visited in event listeners. \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "renderItem.return_image.silent": {
        "desc": " Whether response to mouse events / touch events. "
    },
    "renderItem.return_image.invisible": {
        "desc": " Whether the element is visible. "
    },
    "renderItem.return_image.ignore": {
        "desc": " Whether the element is totally ignored (neither render nor listen events). "
    },
    "renderItem.return_image.textContent": {
        "desc": " Text block attached to an element and layout based on the element by textConfig. The props the the same as [text][0].\n\n[0]: option.html#series-custom.renderItem.return_text"
    },
    "renderItem.return_image.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "renderItem.return_image.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "renderItem.return_image.textConfig.rotation": {
        "desc": " Rotation of textContent. In radian. "
    },
    "renderItem.return_image.textConfig.layoutRect": {
        "desc": " Rect that textContent will be positioned. Default to be the bounding box of host element. \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "renderItem.return_image.textConfig.offset": {
        "desc": " Offset of the textContent. The difference of offset and position is that offset will be applied in the rotation. "
    },
    "renderItem.return_image.textConfig.origin": {
        "desc": "origin is relative to the bounding box of the host element. Can be percent value. Relative to the bounding box. If 'center' specified, it will be center of the bounding box. Only available when position and rotation are both set. \n\n* like [12, 33]\n* or like ['50%', '50%']\n* 'center'\n\n"
    },
    "renderItem.return_image.textConfig.distance": {
        "desc": " Distance to the layoutRectã€‚ "
    },
    "renderItem.return_image.textConfig.local": {
        "desc": " If true, it will apply host's transform. "
    },
    "renderItem.return_image.textConfig.insideFill": {
        "desc": "insideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" In most cases, \"auto-calculated-fill\" is white. "
    },
    "renderItem.return_image.textConfig.insideStroke": {
        "desc": "insideStroke is a color string or left empty. If a textContent is \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be the same as fill of this element if possible, or null.\n\n"
    },
    "renderItem.return_image.textConfig.outsideFill": {
        "desc": "outsideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "renderItem.return_image.textConfig.outsideStroke": {
        "desc": "outsideStroke is a color string or left empty. If a textContent is not \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be a near white color to distinguish \"front end\" label with messy background (like other text label, line or other graphic).\n\n"
    },
    "renderItem.return_image.textConfig.inside": {
        "desc": " Tell echarts that I can make sure this text is inside or not. "
    },
    "renderItem.return_image.during": {
        "desc": "during callback enable users to set props to an element in each animation frame. \n\n    (duringAPI: CustomDuringAPI) => void\n    \n    interface CustomDuringAPI {\n        // Set transform prop value.\n        // Transform prop see `TransformProp`.\n        setTransform(key: TransformProp, val: unknown): void;\n        // Get transform prop value of the current animation frame.\n        getTransform(key: TransformProp): unknown;\n        // Set shape prop value.\n        // Shape prop is like `{ type: 'rect', shape: { xxxProp: xxxValue } }`.\n        setShape(key: string, val: unknown): void;\n        // Get shape prop value of the current animation frame.\n        getShape(key: string): unknown;\n        // Set style prop value.\n        // Style prop is like `{ type: 'rect', style: { xxxProp: xxxValue } }`.\n        setStyle(key: string, val: unknown): void;\n        // Get style prop value of the current animation frame.\n        getStyle(key: string): unknown;\n        // Set extra prop value.\n        // Extra prop is like `{ type: 'rect', extra: { xxxProp: xxxValue } }`.\n        setExtra(key: string, val: unknown): void;\n        // Get extra prop value of the current animation frame.\n        getExtra(key: string): unknown;\n    }\n    \n    type TransformProp =\n        'x' | 'y' | 'scaleX' | 'scaleY' | 'originX' | 'originY' | 'rotation';\n    \n\nIn most cases users do not need this during callback. For example, if some props are specified in [transition][0], echarts will make interpolation for these props internally and therefore have animation based on these props automatically. But if this kind of internal interpolation does not match the user requirements of animation, users can use this during callback to customize them. For example, if users are using [polygon][1] shape. The shape is described by [shape.points][2], which is an points array like: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: [[12, 33], [15, 36], [19, 39], ...]\n        },\n        // ...\n    }\n    \n\nIf users specify them into [transition][3] like: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: [[12, 33], [15, 36], [19, 39], ...],\n        },\n        transition: 'shape'\n        // ...\n    }\n    \n\nAlthough the points will be interpolated, the consequent animation will be like that each point runs straight to the target position, which might do not match the user requirement if some kind of track like spiral is actually needed. In this case, users can use the during callback like that: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: calculatePoints(initialDegree),\n            transition: 'points'\n        },\n        extra: {\n            degree: nextDegree\n        },\n        // Make echarts interpolate `extra.degree` internally, based on which\n        // we calculate the `points` in each animation frame.\n        transition: 'extra',\n        during: function (duringAPI) {\n            var currentDegree = duringAPI.getExtra('degree');\n            duringAPI.setShape(calculatePoints(currentDegree));\n        }\n        // ...\n    }\n    \n\nSee this example [example][4].\n\n[0]: option.html#series-custom.renderItem.return_rect.transition\n[1]: option.html#series-custom.renderItem.return_polygon\n[2]: option.html#series-custom.renderItem.return_polygon.shape.points\n[3]: option.html#series-custom.renderItem.return_polygon.transition\n[4]: https://echarts.apache.org/examples/en/editor.html?c=custom-spiral-race&edit=1&reset=1"
    },
    "renderItem.return_image.extra": {
        "desc": " Users can define their own props in this extra field. See [during][0] for the major usage of extra.\n\n[0]: option.html#series-custom.renderItem.return_rect.during"
    },
    "renderItem.return_image.extra.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this extra. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            extra: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            extra: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `extra` will\n            // have transition animation.\n            transition: 'extra',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_image.style": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "renderItem.return_image.style.image": {
        "desc": " Specify content of the image, can be a URL, or [dataURI][0].\n\n[0]: https://tools.ietf.org/html/rfc2397"
    },
    "renderItem.return_image.style.x": {
        "desc": " The x value of the left-top corner of the element in the coordinate system of its parent. "
    },
    "renderItem.return_image.style.y": {
        "desc": " The y value of the left-top corner of the element in the coordinate system of its parent. "
    },
    "renderItem.return_image.style.width": {
        "desc": " The width of the shape of the element. "
    },
    "renderItem.return_image.style.height": {
        "desc": " The height of the shape of the element. More attributes in style (for example, [rich text][0]), see the style related attributes in [zrender/graphic/Displayable][1]. Notice, the attribute names of the style of graphic elements is derived from zrender, which may be different from the attribute names in echarts label, echarts itemStyle, etc., although they have the same meaning. For example: \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#Rich%20Text\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "renderItem.return_image.style.fill": {
        "desc": " Color filled in this element. "
    },
    "renderItem.return_image.style.stroke": {
        "desc": " Color of stroke. "
    },
    "renderItem.return_image.style.lineWidth": {
        "desc": " Width of stroke. "
    },
    "renderItem.return_image.style.shadowBlur": {
        "desc": " Width of shadow. "
    },
    "renderItem.return_image.style.shadowOffsetX": {
        "desc": " X offset of shadow. "
    },
    "renderItem.return_image.style.shadowOffsetY": {
        "desc": " Y offset of shadow. "
    },
    "renderItem.return_image.style.shadowColor": {
        "desc": " color of shadow. "
    },
    "renderItem.return_image.style.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this style. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            style: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            style: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `style` will\n            // have transition animation.\n            transition: 'style',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_image.focus": {
        "desc": ">  Since > v5.0.0 When it's highlighted, whether to fade out of other data to focus the highlighted. The following configurations are supported: \n\n* 'none' Do not fade out other data, it's by default.\n* 'self' Only focus (not fade out) the element of the currently highlighted data.\n* 'series' Focus on all elements of the series which the currently highlighted data belongs to.\n\n"
    },
    "renderItem.return_image.blurScope": {
        "desc": ">  Since > v5.0.0 The range of fade out when focus is enabled. Support the following configurations \n\n* 'coordinateSystem'\n* 'series'\n* 'global'\n\n"
    },
    "renderItem.return_image.emphasis": {
        "desc": " Emphasis state of the element. "
    },
    "renderItem.return_image.emphasis.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_image.blur": {
        "desc": ">  Since > v5.0.0 Blur state, available when focus is set. "
    },
    "renderItem.return_image.blur.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_image.select": {
        "desc": ">  Since > v5.0.0 Select state, available when [selectedMode][0] is set.\n\n[0]: #series-custom.selectedMode"
    },
    "renderItem.return_image.select.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_text": {
        "desc": " Text block. "
    },
    "renderItem.return_text.type": {
        "desc": " Must be specified when define a graphic element at the first time. Optional values: [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #series-custom.renderItem.return_image\n[1]: #series-custom.renderItem.return_text\n[2]: #series-custom.renderItem.return_circle\n[3]: #series-custom.renderItem.return_sector\n[4]: #series-custom.renderItem.return_ring\n[5]: #series-custom.renderItem.return_polygon\n[6]: #series-custom.renderItem.return_polyline\n[7]: #series-custom.renderItem.return_rect\n[8]: #series-custom.renderItem.return_line\n[9]: #series-custom.renderItem.return_bezierCurve\n[10]: #series-custom.renderItem.return_arc\n[11]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_text.id": {
        "desc": " id is used to specifying element when willing to update it. id can be ignored if you do not need it. "
    },
    "renderItem.return_text.x": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_text.x\n[1]: #series-custom.renderItem.return_text.y\n[2]: #series-custom.renderItem.return_text.rotation\n[3]: #series-custom.renderItem.return_text.scaleX\n[4]: #series-custom.renderItem.return_text.scaleY\n[5]: #series-custom.renderItem.return_text.originX\n[6]: #series-custom.renderItem.return_text.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_text.y": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_text.x\n[1]: #series-custom.renderItem.return_text.y\n[2]: #series-custom.renderItem.return_text.rotation\n[3]: #series-custom.renderItem.return_text.scaleX\n[4]: #series-custom.renderItem.return_text.scaleY\n[5]: #series-custom.renderItem.return_text.originX\n[6]: #series-custom.renderItem.return_text.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_text.rotation": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_text.x\n[1]: #series-custom.renderItem.return_text.y\n[2]: #series-custom.renderItem.return_text.rotation\n[3]: #series-custom.renderItem.return_text.scaleX\n[4]: #series-custom.renderItem.return_text.scaleY\n[5]: #series-custom.renderItem.return_text.originX\n[6]: #series-custom.renderItem.return_text.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_text.scaleX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_text.x\n[1]: #series-custom.renderItem.return_text.y\n[2]: #series-custom.renderItem.return_text.rotation\n[3]: #series-custom.renderItem.return_text.scaleX\n[4]: #series-custom.renderItem.return_text.scaleY\n[5]: #series-custom.renderItem.return_text.originX\n[6]: #series-custom.renderItem.return_text.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_text.scaleY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_text.x\n[1]: #series-custom.renderItem.return_text.y\n[2]: #series-custom.renderItem.return_text.rotation\n[3]: #series-custom.renderItem.return_text.scaleX\n[4]: #series-custom.renderItem.return_text.scaleY\n[5]: #series-custom.renderItem.return_text.originX\n[6]: #series-custom.renderItem.return_text.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_text.originX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_text.x\n[1]: #series-custom.renderItem.return_text.y\n[2]: #series-custom.renderItem.return_text.rotation\n[3]: #series-custom.renderItem.return_text.scaleX\n[4]: #series-custom.renderItem.return_text.scaleY\n[5]: #series-custom.renderItem.return_text.originX\n[6]: #series-custom.renderItem.return_text.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_text.originY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_text.x\n[1]: #series-custom.renderItem.return_text.y\n[2]: #series-custom.renderItem.return_text.rotation\n[3]: #series-custom.renderItem.return_text.scaleX\n[4]: #series-custom.renderItem.return_text.scaleY\n[5]: #series-custom.renderItem.return_text.originX\n[6]: #series-custom.renderItem.return_text.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_text.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. The properties can only be: \n\n* Transform related properties: ['x'][0], ['y'][1], ['scaleX'][2], ['scaleY'][3], ['rotation'][4], ['originX'][5], ['originY'][6]. For example:\n\n      renderItem: function (params, api) {\n          var coord = api.coord([api.value(0), api.value[1]);\n          return {\n              type: 'rect',\n              x: coord[0],\n              y: coord[1],\n              shape: {\n                  x: 0,\n                  y: 0,\n                  width: api.value(2),\n                  height: 100\n              },\n              transition: ['x', 'y', 'width']\n          }\n      }\n* Shortcut to transition all of the properties in ['shape'][7], ['style'][8], ['extra'][9]. For example:\n\n      renderItem: function (params, api) {\n          return {\n              type: 'rect',\n              shape: {\n                  x: api.value(0),\n                  y: api.value(1),\n                  width: api.value(2),\n                  height: api.value(3)\n              },\n              // Indicate that all props in `shape` will\n              // have transition animation.\n              transition: 'shape',\n          };\n      }\n    \n\nIt is equivalent to:\n\n      renderItem: function (params, api) {\n          return {\n              type: 'rect',\n              shape: {\n                  x: api.value(0),\n                  y: api.value(1),\n                  width: api.value(2),\n                  height: api.value(3),\n                  // This usage can only enable part of the\n                  // properties transition.\n                  transition: ['x', 'y', 'width', 'height']\n              }\n          };\n      }\n\nBy default, ['x'][0] and ['y'][1] are transitioned. If you want to disable the default transition, just set it as: \n\n    transition: [] // Am empty array.\n    \n\nSee this [example][10] please.\n\n[0]: #series-custom.renderItem.return_text.x\n[1]: #series-custom.renderItem.return_text.y\n[2]: #series-custom.renderItem.return_text.scaleX\n[3]: #series-custom.renderItem.return_text.scaleY\n[4]: #series-custom.renderItem.return_text.rotation\n[5]: #series-custom.renderItem.return_text.originX\n[6]: #series-custom.renderItem.return_text.originY\n[7]: #series-custom.renderItem.return_text.shape\n[8]: #series-custom.renderItem.return_text.style\n[9]: #series-custom.renderItem.return_text.extra\n[10]: https://echarts.apache.org/examples/en/editor.html?c=doc-example/custom-transition-simple&edit=1&reset=1"
    },
    "renderItem.return_text.z2": {
        "desc": " Define the overlap relationship between graphic elements. "
    },
    "renderItem.return_text.name": {
        "desc": " See [diffChildrenByName][0].\n\n[0]: #series-custom.renderItem.return_text.diffChildrenByName"
    },
    "renderItem.return_text.info": {
        "desc": " User defined data, can be visited in event listeners. \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "renderItem.return_text.silent": {
        "desc": " Whether response to mouse events / touch events. "
    },
    "renderItem.return_text.invisible": {
        "desc": " Whether the element is visible. "
    },
    "renderItem.return_text.ignore": {
        "desc": " Whether the element is totally ignored (neither render nor listen events). "
    },
    "renderItem.return_text.textContent": {
        "desc": " Text block attached to an element and layout based on the element by textConfig. The props the the same as [text][0].\n\n[0]: option.html#series-custom.renderItem.return_text"
    },
    "renderItem.return_text.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "renderItem.return_text.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "renderItem.return_text.textConfig.rotation": {
        "desc": " Rotation of textContent. In radian. "
    },
    "renderItem.return_text.textConfig.layoutRect": {
        "desc": " Rect that textContent will be positioned. Default to be the bounding box of host element. \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "renderItem.return_text.textConfig.offset": {
        "desc": " Offset of the textContent. The difference of offset and position is that offset will be applied in the rotation. "
    },
    "renderItem.return_text.textConfig.origin": {
        "desc": "origin is relative to the bounding box of the host element. Can be percent value. Relative to the bounding box. If 'center' specified, it will be center of the bounding box. Only available when position and rotation are both set. \n\n* like [12, 33]\n* or like ['50%', '50%']\n* 'center'\n\n"
    },
    "renderItem.return_text.textConfig.distance": {
        "desc": " Distance to the layoutRectã€‚ "
    },
    "renderItem.return_text.textConfig.local": {
        "desc": " If true, it will apply host's transform. "
    },
    "renderItem.return_text.textConfig.insideFill": {
        "desc": "insideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" In most cases, \"auto-calculated-fill\" is white. "
    },
    "renderItem.return_text.textConfig.insideStroke": {
        "desc": "insideStroke is a color string or left empty. If a textContent is \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be the same as fill of this element if possible, or null.\n\n"
    },
    "renderItem.return_text.textConfig.outsideFill": {
        "desc": "outsideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "renderItem.return_text.textConfig.outsideStroke": {
        "desc": "outsideStroke is a color string or left empty. If a textContent is not \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be a near white color to distinguish \"front end\" label with messy background (like other text label, line or other graphic).\n\n"
    },
    "renderItem.return_text.textConfig.inside": {
        "desc": " Tell echarts that I can make sure this text is inside or not. "
    },
    "renderItem.return_text.during": {
        "desc": "during callback enable users to set props to an element in each animation frame. \n\n    (duringAPI: CustomDuringAPI) => void\n    \n    interface CustomDuringAPI {\n        // Set transform prop value.\n        // Transform prop see `TransformProp`.\n        setTransform(key: TransformProp, val: unknown): void;\n        // Get transform prop value of the current animation frame.\n        getTransform(key: TransformProp): unknown;\n        // Set shape prop value.\n        // Shape prop is like `{ type: 'rect', shape: { xxxProp: xxxValue } }`.\n        setShape(key: string, val: unknown): void;\n        // Get shape prop value of the current animation frame.\n        getShape(key: string): unknown;\n        // Set style prop value.\n        // Style prop is like `{ type: 'rect', style: { xxxProp: xxxValue } }`.\n        setStyle(key: string, val: unknown): void;\n        // Get style prop value of the current animation frame.\n        getStyle(key: string): unknown;\n        // Set extra prop value.\n        // Extra prop is like `{ type: 'rect', extra: { xxxProp: xxxValue } }`.\n        setExtra(key: string, val: unknown): void;\n        // Get extra prop value of the current animation frame.\n        getExtra(key: string): unknown;\n    }\n    \n    type TransformProp =\n        'x' | 'y' | 'scaleX' | 'scaleY' | 'originX' | 'originY' | 'rotation';\n    \n\nIn most cases users do not need this during callback. For example, if some props are specified in [transition][0], echarts will make interpolation for these props internally and therefore have animation based on these props automatically. But if this kind of internal interpolation does not match the user requirements of animation, users can use this during callback to customize them. For example, if users are using [polygon][1] shape. The shape is described by [shape.points][2], which is an points array like: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: [[12, 33], [15, 36], [19, 39], ...]\n        },\n        // ...\n    }\n    \n\nIf users specify them into [transition][3] like: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: [[12, 33], [15, 36], [19, 39], ...],\n        },\n        transition: 'shape'\n        // ...\n    }\n    \n\nAlthough the points will be interpolated, the consequent animation will be like that each point runs straight to the target position, which might do not match the user requirement if some kind of track like spiral is actually needed. In this case, users can use the during callback like that: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: calculatePoints(initialDegree),\n            transition: 'points'\n        },\n        extra: {\n            degree: nextDegree\n        },\n        // Make echarts interpolate `extra.degree` internally, based on which\n        // we calculate the `points` in each animation frame.\n        transition: 'extra',\n        during: function (duringAPI) {\n            var currentDegree = duringAPI.getExtra('degree');\n            duringAPI.setShape(calculatePoints(currentDegree));\n        }\n        // ...\n    }\n    \n\nSee this example [example][4].\n\n[0]: option.html#series-custom.renderItem.return_rect.transition\n[1]: option.html#series-custom.renderItem.return_polygon\n[2]: option.html#series-custom.renderItem.return_polygon.shape.points\n[3]: option.html#series-custom.renderItem.return_polygon.transition\n[4]: https://echarts.apache.org/examples/en/editor.html?c=custom-spiral-race&edit=1&reset=1"
    },
    "renderItem.return_text.extra": {
        "desc": " Users can define their own props in this extra field. See [during][0] for the major usage of extra.\n\n[0]: option.html#series-custom.renderItem.return_rect.during"
    },
    "renderItem.return_text.extra.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this extra. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            extra: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            extra: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `extra` will\n            // have transition animation.\n            transition: 'extra',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_text.style": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "renderItem.return_text.style.text": {
        "desc": " Text content. \\n can be used as a line break. "
    },
    "renderItem.return_text.style.x": {
        "desc": " The x value of the left-top corner of the element in the coordinate system of its parent. "
    },
    "renderItem.return_text.style.y": {
        "desc": " The y value of the left-top corner of the element in the coordinate system of its parent. "
    },
    "renderItem.return_text.style.font": {
        "desc": " Font size, font type, font weight, font color, follow the form of [css font][0]. For example: \n\n    // size | family\n    font: '2em \"STHeiti\", sans-serif'\n    \n    // style | weight | size | family\n    font: 'italic bolder 16px cursive'\n    \n    // weight | size | family\n    font: 'bolder 2em \"Microsoft YaHei\", sans-serif'\n    \n\n[0]: https://developer.mozilla.org/en-US/docs/Web/CSS/font"
    },
    "renderItem.return_text.style.textAlign": {
        "desc": " Text horizontal alignment. Optional values: 'left', 'center', 'right'. 'left' means the left side of the text block is specified by the [style.x][0], while 'right' means the right side of the text block is specified by [style.y][1].\n\n[0]: #series-custom.renderItem.return_text.style.x\n[1]: #series-custom.renderItem.return_text.style.y"
    },
    "renderItem.return_text.style.textVerticalAlign": {
        "desc": " Text vertical alignment. Optional values: 'top', 'middle', 'bottom'. More attributes in style (for example, [rich text][0]), see the style related attributes in [zrender/graphic/Displayable][1]. Notice, the attribute names of the style of graphic elements is derived from zrender, which may be different from the attribute names in echarts label, echarts itemStyle, etc., although they have the same meaning. For example: \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#Rich%20Text\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "renderItem.return_text.style.fill": {
        "desc": " Color filled in this element. "
    },
    "renderItem.return_text.style.stroke": {
        "desc": " Color of stroke. "
    },
    "renderItem.return_text.style.lineWidth": {
        "desc": " Width of stroke. "
    },
    "renderItem.return_text.style.shadowBlur": {
        "desc": " Width of shadow. "
    },
    "renderItem.return_text.style.shadowOffsetX": {
        "desc": " X offset of shadow. "
    },
    "renderItem.return_text.style.shadowOffsetY": {
        "desc": " Y offset of shadow. "
    },
    "renderItem.return_text.style.shadowColor": {
        "desc": " color of shadow. "
    },
    "renderItem.return_text.style.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this style. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            style: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            style: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `style` will\n            // have transition animation.\n            transition: 'style',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_text.focus": {
        "desc": ">  Since > v5.0.0 When it's highlighted, whether to fade out of other data to focus the highlighted. The following configurations are supported: \n\n* 'none' Do not fade out other data, it's by default.\n* 'self' Only focus (not fade out) the element of the currently highlighted data.\n* 'series' Focus on all elements of the series which the currently highlighted data belongs to.\n\n"
    },
    "renderItem.return_text.blurScope": {
        "desc": ">  Since > v5.0.0 The range of fade out when focus is enabled. Support the following configurations \n\n* 'coordinateSystem'\n* 'series'\n* 'global'\n\n"
    },
    "renderItem.return_text.emphasis": {
        "desc": " Emphasis state of the element. "
    },
    "renderItem.return_text.emphasis.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_text.blur": {
        "desc": ">  Since > v5.0.0 Blur state, available when focus is set. "
    },
    "renderItem.return_text.blur.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_text.select": {
        "desc": ">  Since > v5.0.0 Select state, available when [selectedMode][0] is set.\n\n[0]: #series-custom.selectedMode"
    },
    "renderItem.return_text.select.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_rect": {
        "desc": " Rectangle element. "
    },
    "renderItem.return_rect.type": {
        "desc": " Must be specified when define a graphic element at the first time. Optional values: [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #series-custom.renderItem.return_image\n[1]: #series-custom.renderItem.return_text\n[2]: #series-custom.renderItem.return_circle\n[3]: #series-custom.renderItem.return_sector\n[4]: #series-custom.renderItem.return_ring\n[5]: #series-custom.renderItem.return_polygon\n[6]: #series-custom.renderItem.return_polyline\n[7]: #series-custom.renderItem.return_rect\n[8]: #series-custom.renderItem.return_line\n[9]: #series-custom.renderItem.return_bezierCurve\n[10]: #series-custom.renderItem.return_arc\n[11]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_rect.id": {
        "desc": " id is used to specifying element when willing to update it. id can be ignored if you do not need it. "
    },
    "renderItem.return_rect.x": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_rect.x\n[1]: #series-custom.renderItem.return_rect.y\n[2]: #series-custom.renderItem.return_rect.rotation\n[3]: #series-custom.renderItem.return_rect.scaleX\n[4]: #series-custom.renderItem.return_rect.scaleY\n[5]: #series-custom.renderItem.return_rect.originX\n[6]: #series-custom.renderItem.return_rect.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_rect.y": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_rect.x\n[1]: #series-custom.renderItem.return_rect.y\n[2]: #series-custom.renderItem.return_rect.rotation\n[3]: #series-custom.renderItem.return_rect.scaleX\n[4]: #series-custom.renderItem.return_rect.scaleY\n[5]: #series-custom.renderItem.return_rect.originX\n[6]: #series-custom.renderItem.return_rect.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_rect.rotation": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_rect.x\n[1]: #series-custom.renderItem.return_rect.y\n[2]: #series-custom.renderItem.return_rect.rotation\n[3]: #series-custom.renderItem.return_rect.scaleX\n[4]: #series-custom.renderItem.return_rect.scaleY\n[5]: #series-custom.renderItem.return_rect.originX\n[6]: #series-custom.renderItem.return_rect.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_rect.scaleX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_rect.x\n[1]: #series-custom.renderItem.return_rect.y\n[2]: #series-custom.renderItem.return_rect.rotation\n[3]: #series-custom.renderItem.return_rect.scaleX\n[4]: #series-custom.renderItem.return_rect.scaleY\n[5]: #series-custom.renderItem.return_rect.originX\n[6]: #series-custom.renderItem.return_rect.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_rect.scaleY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_rect.x\n[1]: #series-custom.renderItem.return_rect.y\n[2]: #series-custom.renderItem.return_rect.rotation\n[3]: #series-custom.renderItem.return_rect.scaleX\n[4]: #series-custom.renderItem.return_rect.scaleY\n[5]: #series-custom.renderItem.return_rect.originX\n[6]: #series-custom.renderItem.return_rect.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_rect.originX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_rect.x\n[1]: #series-custom.renderItem.return_rect.y\n[2]: #series-custom.renderItem.return_rect.rotation\n[3]: #series-custom.renderItem.return_rect.scaleX\n[4]: #series-custom.renderItem.return_rect.scaleY\n[5]: #series-custom.renderItem.return_rect.originX\n[6]: #series-custom.renderItem.return_rect.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_rect.originY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_rect.x\n[1]: #series-custom.renderItem.return_rect.y\n[2]: #series-custom.renderItem.return_rect.rotation\n[3]: #series-custom.renderItem.return_rect.scaleX\n[4]: #series-custom.renderItem.return_rect.scaleY\n[5]: #series-custom.renderItem.return_rect.originX\n[6]: #series-custom.renderItem.return_rect.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_rect.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. The properties can only be: \n\n* Transform related properties: ['x'][0], ['y'][1], ['scaleX'][2], ['scaleY'][3], ['rotation'][4], ['originX'][5], ['originY'][6]. For example:\n\n      renderItem: function (params, api) {\n          var coord = api.coord([api.value(0), api.value[1]);\n          return {\n              type: 'rect',\n              x: coord[0],\n              y: coord[1],\n              shape: {\n                  x: 0,\n                  y: 0,\n                  width: api.value(2),\n                  height: 100\n              },\n              transition: ['x', 'y', 'width']\n          }\n      }\n* Shortcut to transition all of the properties in ['shape'][7], ['style'][8], ['extra'][9]. For example:\n\n      renderItem: function (params, api) {\n          return {\n              type: 'rect',\n              shape: {\n                  x: api.value(0),\n                  y: api.value(1),\n                  width: api.value(2),\n                  height: api.value(3)\n              },\n              // Indicate that all props in `shape` will\n              // have transition animation.\n              transition: 'shape',\n          };\n      }\n    \n\nIt is equivalent to:\n\n      renderItem: function (params, api) {\n          return {\n              type: 'rect',\n              shape: {\n                  x: api.value(0),\n                  y: api.value(1),\n                  width: api.value(2),\n                  height: api.value(3),\n                  // This usage can only enable part of the\n                  // properties transition.\n                  transition: ['x', 'y', 'width', 'height']\n              }\n          };\n      }\n\nBy default, ['x'][0] and ['y'][1] are transitioned. If you want to disable the default transition, just set it as: \n\n    transition: [] // Am empty array.\n    \n\nSee this [example][10] please.\n\n[0]: #series-custom.renderItem.return_rect.x\n[1]: #series-custom.renderItem.return_rect.y\n[2]: #series-custom.renderItem.return_rect.scaleX\n[3]: #series-custom.renderItem.return_rect.scaleY\n[4]: #series-custom.renderItem.return_rect.rotation\n[5]: #series-custom.renderItem.return_rect.originX\n[6]: #series-custom.renderItem.return_rect.originY\n[7]: #series-custom.renderItem.return_rect.shape\n[8]: #series-custom.renderItem.return_rect.style\n[9]: #series-custom.renderItem.return_rect.extra\n[10]: https://echarts.apache.org/examples/en/editor.html?c=doc-example/custom-transition-simple&edit=1&reset=1"
    },
    "renderItem.return_rect.morph": {
        "desc": " Whether to enable morphing animation. **When morphing animation happen?** If morph is set as true, the morphing animation will happen according to the following rule: Each time the render process happen, custom series will diff the old data and the new data. If a set of old data items (say, \"old set\") are value-equal to a set of new data items (say, \"new set\") in name or the specified dimensions (see parameter [transition][0] in setOption), we found a pair of sets as transition candidates. Three type of transition animation can be performed between the two sets: \n\n* one-to-one: if both the two sets has only one data item.\n* one-to-many(separate): if the \"old set\" has only one data item, and the \"new set\" has more than one data items.\n* many-to-one(combine): if the \"old set\" has more than one data items, and the \"new set\" has only one data item.\n\nNote: we do not support transition animation for the case many-to-many. Then custom series find graphic elements that has morph: true declared in these two sets, and map them for one to one morphing or combining or separating. See examples: [custom-one-to-one-morph][1] and [custom-combine-separate-morph][2].\n\n[0]: api.html#echartsInstance.setOption\n[1]: https://echarts.apache.org/examples/en/editor.html?c=custom-one-to-one-morph&edit=1&reset=1\n[2]: https://echarts.apache.org/examples/en/editor.html?c=custom-combine-separate-morph&edit=1&reset=1"
    },
    "renderItem.return_rect.z2": {
        "desc": " Define the overlap relationship between graphic elements. "
    },
    "renderItem.return_rect.name": {
        "desc": " See [diffChildrenByName][0].\n\n[0]: #series-custom.renderItem.return_rect.diffChildrenByName"
    },
    "renderItem.return_rect.info": {
        "desc": " User defined data, can be visited in event listeners. \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "renderItem.return_rect.silent": {
        "desc": " Whether response to mouse events / touch events. "
    },
    "renderItem.return_rect.invisible": {
        "desc": " Whether the element is visible. "
    },
    "renderItem.return_rect.ignore": {
        "desc": " Whether the element is totally ignored (neither render nor listen events). "
    },
    "renderItem.return_rect.textContent": {
        "desc": " Text block attached to an element and layout based on the element by textConfig. The props the the same as [text][0].\n\n[0]: option.html#series-custom.renderItem.return_text"
    },
    "renderItem.return_rect.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "renderItem.return_rect.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "renderItem.return_rect.textConfig.rotation": {
        "desc": " Rotation of textContent. In radian. "
    },
    "renderItem.return_rect.textConfig.layoutRect": {
        "desc": " Rect that textContent will be positioned. Default to be the bounding box of host element. \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "renderItem.return_rect.textConfig.offset": {
        "desc": " Offset of the textContent. The difference of offset and position is that offset will be applied in the rotation. "
    },
    "renderItem.return_rect.textConfig.origin": {
        "desc": "origin is relative to the bounding box of the host element. Can be percent value. Relative to the bounding box. If 'center' specified, it will be center of the bounding box. Only available when position and rotation are both set. \n\n* like [12, 33]\n* or like ['50%', '50%']\n* 'center'\n\n"
    },
    "renderItem.return_rect.textConfig.distance": {
        "desc": " Distance to the layoutRectã€‚ "
    },
    "renderItem.return_rect.textConfig.local": {
        "desc": " If true, it will apply host's transform. "
    },
    "renderItem.return_rect.textConfig.insideFill": {
        "desc": "insideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" In most cases, \"auto-calculated-fill\" is white. "
    },
    "renderItem.return_rect.textConfig.insideStroke": {
        "desc": "insideStroke is a color string or left empty. If a textContent is \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be the same as fill of this element if possible, or null.\n\n"
    },
    "renderItem.return_rect.textConfig.outsideFill": {
        "desc": "outsideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "renderItem.return_rect.textConfig.outsideStroke": {
        "desc": "outsideStroke is a color string or left empty. If a textContent is not \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be a near white color to distinguish \"front end\" label with messy background (like other text label, line or other graphic).\n\n"
    },
    "renderItem.return_rect.textConfig.inside": {
        "desc": " Tell echarts that I can make sure this text is inside or not. "
    },
    "renderItem.return_rect.during": {
        "desc": "during callback enable users to set props to an element in each animation frame. \n\n    (duringAPI: CustomDuringAPI) => void\n    \n    interface CustomDuringAPI {\n        // Set transform prop value.\n        // Transform prop see `TransformProp`.\n        setTransform(key: TransformProp, val: unknown): void;\n        // Get transform prop value of the current animation frame.\n        getTransform(key: TransformProp): unknown;\n        // Set shape prop value.\n        // Shape prop is like `{ type: 'rect', shape: { xxxProp: xxxValue } }`.\n        setShape(key: string, val: unknown): void;\n        // Get shape prop value of the current animation frame.\n        getShape(key: string): unknown;\n        // Set style prop value.\n        // Style prop is like `{ type: 'rect', style: { xxxProp: xxxValue } }`.\n        setStyle(key: string, val: unknown): void;\n        // Get style prop value of the current animation frame.\n        getStyle(key: string): unknown;\n        // Set extra prop value.\n        // Extra prop is like `{ type: 'rect', extra: { xxxProp: xxxValue } }`.\n        setExtra(key: string, val: unknown): void;\n        // Get extra prop value of the current animation frame.\n        getExtra(key: string): unknown;\n    }\n    \n    type TransformProp =\n        'x' | 'y' | 'scaleX' | 'scaleY' | 'originX' | 'originY' | 'rotation';\n    \n\nIn most cases users do not need this during callback. For example, if some props are specified in [transition][0], echarts will make interpolation for these props internally and therefore have animation based on these props automatically. But if this kind of internal interpolation does not match the user requirements of animation, users can use this during callback to customize them. For example, if users are using [polygon][1] shape. The shape is described by [shape.points][2], which is an points array like: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: [[12, 33], [15, 36], [19, 39], ...]\n        },\n        // ...\n    }\n    \n\nIf users specify them into [transition][3] like: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: [[12, 33], [15, 36], [19, 39], ...],\n        },\n        transition: 'shape'\n        // ...\n    }\n    \n\nAlthough the points will be interpolated, the consequent animation will be like that each point runs straight to the target position, which might do not match the user requirement if some kind of track like spiral is actually needed. In this case, users can use the during callback like that: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: calculatePoints(initialDegree),\n            transition: 'points'\n        },\n        extra: {\n            degree: nextDegree\n        },\n        // Make echarts interpolate `extra.degree` internally, based on which\n        // we calculate the `points` in each animation frame.\n        transition: 'extra',\n        during: function (duringAPI) {\n            var currentDegree = duringAPI.getExtra('degree');\n            duringAPI.setShape(calculatePoints(currentDegree));\n        }\n        // ...\n    }\n    \n\nSee this example [example][4].\n\n[0]: option.html#series-custom.renderItem.return_rect.transition\n[1]: option.html#series-custom.renderItem.return_polygon\n[2]: option.html#series-custom.renderItem.return_polygon.shape.points\n[3]: option.html#series-custom.renderItem.return_polygon.transition\n[4]: https://echarts.apache.org/examples/en/editor.html?c=custom-spiral-race&edit=1&reset=1"
    },
    "renderItem.return_rect.extra": {
        "desc": " Users can define their own props in this extra field. See [during][0] for the major usage of extra.\n\n[0]: option.html#series-custom.renderItem.return_rect.during"
    },
    "renderItem.return_rect.extra.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this extra. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            extra: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            extra: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `extra` will\n            // have transition animation.\n            transition: 'extra',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_rect.shape": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "renderItem.return_rect.shape.x": {
        "desc": " The x value of the left-top corner of the element in the coordinate system of its parent. "
    },
    "renderItem.return_rect.shape.y": {
        "desc": " The y value of the left-top corner of the element in the coordinate system of its parent. "
    },
    "renderItem.return_rect.shape.width": {
        "desc": " The width of the shape of the element. "
    },
    "renderItem.return_rect.shape.height": {
        "desc": " The height of the shape of the element. "
    },
    "renderItem.return_rect.shape.r": {
        "desc": " Specify border radius of the rectangular here. Generally, r should be [topLeftRadius, topRightRadius, BottomRightRadius, bottomLeftRadius], where each item is a number. Abbreviation is enabled, for example: \n\n* r: 1 means [1, 1, 1, 1]\n* r: [1] means [1, 1, 1, 1]\n* r: [1, 2] means [1, 2, 1, 2]\n* r: [1, 2, 3] means [1, 2, 3, 2]\n\n"
    },
    "renderItem.return_rect.shape.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this shape. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            shape: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            shape: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `shape` will\n            // have transition animation.\n            transition: 'shape',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_rect.style": {
        "desc": " More attributes in style (for example, [rich text][0]), see the style related attributes in [zrender/graphic/Displayable][1]. Notice, the attribute names of the style of graphic elements is derived from zrender, which may be different from the attribute names in echarts label, echarts itemStyle, etc., although they have the same meaning. For example: \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#Rich%20Text\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "renderItem.return_rect.style.fill": {
        "desc": " Color filled in this element. "
    },
    "renderItem.return_rect.style.stroke": {
        "desc": " Color of stroke. "
    },
    "renderItem.return_rect.style.lineWidth": {
        "desc": " Width of stroke. "
    },
    "renderItem.return_rect.style.shadowBlur": {
        "desc": " Width of shadow. "
    },
    "renderItem.return_rect.style.shadowOffsetX": {
        "desc": " X offset of shadow. "
    },
    "renderItem.return_rect.style.shadowOffsetY": {
        "desc": " Y offset of shadow. "
    },
    "renderItem.return_rect.style.shadowColor": {
        "desc": " color of shadow. "
    },
    "renderItem.return_rect.style.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this style. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            style: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            style: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `style` will\n            // have transition animation.\n            transition: 'style',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_rect.focus": {
        "desc": ">  Since > v5.0.0 When it's highlighted, whether to fade out of other data to focus the highlighted. The following configurations are supported: \n\n* 'none' Do not fade out other data, it's by default.\n* 'self' Only focus (not fade out) the element of the currently highlighted data.\n* 'series' Focus on all elements of the series which the currently highlighted data belongs to.\n\n"
    },
    "renderItem.return_rect.blurScope": {
        "desc": ">  Since > v5.0.0 The range of fade out when focus is enabled. Support the following configurations \n\n* 'coordinateSystem'\n* 'series'\n* 'global'\n\n"
    },
    "renderItem.return_rect.emphasis": {
        "desc": " Emphasis state of the element. "
    },
    "renderItem.return_rect.emphasis.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_rect.blur": {
        "desc": ">  Since > v5.0.0 Blur state, available when focus is set. "
    },
    "renderItem.return_rect.blur.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_rect.select": {
        "desc": ">  Since > v5.0.0 Select state, available when [selectedMode][0] is set.\n\n[0]: #series-custom.selectedMode"
    },
    "renderItem.return_rect.select.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_circle": {
        "desc": " Circle element. "
    },
    "renderItem.return_circle.type": {
        "desc": " Must be specified when define a graphic element at the first time. Optional values: [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #series-custom.renderItem.return_image\n[1]: #series-custom.renderItem.return_text\n[2]: #series-custom.renderItem.return_circle\n[3]: #series-custom.renderItem.return_sector\n[4]: #series-custom.renderItem.return_ring\n[5]: #series-custom.renderItem.return_polygon\n[6]: #series-custom.renderItem.return_polyline\n[7]: #series-custom.renderItem.return_rect\n[8]: #series-custom.renderItem.return_line\n[9]: #series-custom.renderItem.return_bezierCurve\n[10]: #series-custom.renderItem.return_arc\n[11]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_circle.id": {
        "desc": " id is used to specifying element when willing to update it. id can be ignored if you do not need it. "
    },
    "renderItem.return_circle.x": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_circle.x\n[1]: #series-custom.renderItem.return_circle.y\n[2]: #series-custom.renderItem.return_circle.rotation\n[3]: #series-custom.renderItem.return_circle.scaleX\n[4]: #series-custom.renderItem.return_circle.scaleY\n[5]: #series-custom.renderItem.return_circle.originX\n[6]: #series-custom.renderItem.return_circle.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_circle.y": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_circle.x\n[1]: #series-custom.renderItem.return_circle.y\n[2]: #series-custom.renderItem.return_circle.rotation\n[3]: #series-custom.renderItem.return_circle.scaleX\n[4]: #series-custom.renderItem.return_circle.scaleY\n[5]: #series-custom.renderItem.return_circle.originX\n[6]: #series-custom.renderItem.return_circle.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_circle.rotation": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_circle.x\n[1]: #series-custom.renderItem.return_circle.y\n[2]: #series-custom.renderItem.return_circle.rotation\n[3]: #series-custom.renderItem.return_circle.scaleX\n[4]: #series-custom.renderItem.return_circle.scaleY\n[5]: #series-custom.renderItem.return_circle.originX\n[6]: #series-custom.renderItem.return_circle.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_circle.scaleX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_circle.x\n[1]: #series-custom.renderItem.return_circle.y\n[2]: #series-custom.renderItem.return_circle.rotation\n[3]: #series-custom.renderItem.return_circle.scaleX\n[4]: #series-custom.renderItem.return_circle.scaleY\n[5]: #series-custom.renderItem.return_circle.originX\n[6]: #series-custom.renderItem.return_circle.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_circle.scaleY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_circle.x\n[1]: #series-custom.renderItem.return_circle.y\n[2]: #series-custom.renderItem.return_circle.rotation\n[3]: #series-custom.renderItem.return_circle.scaleX\n[4]: #series-custom.renderItem.return_circle.scaleY\n[5]: #series-custom.renderItem.return_circle.originX\n[6]: #series-custom.renderItem.return_circle.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_circle.originX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_circle.x\n[1]: #series-custom.renderItem.return_circle.y\n[2]: #series-custom.renderItem.return_circle.rotation\n[3]: #series-custom.renderItem.return_circle.scaleX\n[4]: #series-custom.renderItem.return_circle.scaleY\n[5]: #series-custom.renderItem.return_circle.originX\n[6]: #series-custom.renderItem.return_circle.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_circle.originY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_circle.x\n[1]: #series-custom.renderItem.return_circle.y\n[2]: #series-custom.renderItem.return_circle.rotation\n[3]: #series-custom.renderItem.return_circle.scaleX\n[4]: #series-custom.renderItem.return_circle.scaleY\n[5]: #series-custom.renderItem.return_circle.originX\n[6]: #series-custom.renderItem.return_circle.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_circle.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. The properties can only be: \n\n* Transform related properties: ['x'][0], ['y'][1], ['scaleX'][2], ['scaleY'][3], ['rotation'][4], ['originX'][5], ['originY'][6]. For example:\n\n      renderItem: function (params, api) {\n          var coord = api.coord([api.value(0), api.value[1]);\n          return {\n              type: 'rect',\n              x: coord[0],\n              y: coord[1],\n              shape: {\n                  x: 0,\n                  y: 0,\n                  width: api.value(2),\n                  height: 100\n              },\n              transition: ['x', 'y', 'width']\n          }\n      }\n* Shortcut to transition all of the properties in ['shape'][7], ['style'][8], ['extra'][9]. For example:\n\n      renderItem: function (params, api) {\n          return {\n              type: 'rect',\n              shape: {\n                  x: api.value(0),\n                  y: api.value(1),\n                  width: api.value(2),\n                  height: api.value(3)\n              },\n              // Indicate that all props in `shape` will\n              // have transition animation.\n              transition: 'shape',\n          };\n      }\n    \n\nIt is equivalent to:\n\n      renderItem: function (params, api) {\n          return {\n              type: 'rect',\n              shape: {\n                  x: api.value(0),\n                  y: api.value(1),\n                  width: api.value(2),\n                  height: api.value(3),\n                  // This usage can only enable part of the\n                  // properties transition.\n                  transition: ['x', 'y', 'width', 'height']\n              }\n          };\n      }\n\nBy default, ['x'][0] and ['y'][1] are transitioned. If you want to disable the default transition, just set it as: \n\n    transition: [] // Am empty array.\n    \n\nSee this [example][10] please.\n\n[0]: #series-custom.renderItem.return_circle.x\n[1]: #series-custom.renderItem.return_circle.y\n[2]: #series-custom.renderItem.return_circle.scaleX\n[3]: #series-custom.renderItem.return_circle.scaleY\n[4]: #series-custom.renderItem.return_circle.rotation\n[5]: #series-custom.renderItem.return_circle.originX\n[6]: #series-custom.renderItem.return_circle.originY\n[7]: #series-custom.renderItem.return_circle.shape\n[8]: #series-custom.renderItem.return_circle.style\n[9]: #series-custom.renderItem.return_circle.extra\n[10]: https://echarts.apache.org/examples/en/editor.html?c=doc-example/custom-transition-simple&edit=1&reset=1"
    },
    "renderItem.return_circle.morph": {
        "desc": " Whether to enable morphing animation. **When morphing animation happen?** If morph is set as true, the morphing animation will happen according to the following rule: Each time the render process happen, custom series will diff the old data and the new data. If a set of old data items (say, \"old set\") are value-equal to a set of new data items (say, \"new set\") in name or the specified dimensions (see parameter [transition][0] in setOption), we found a pair of sets as transition candidates. Three type of transition animation can be performed between the two sets: \n\n* one-to-one: if both the two sets has only one data item.\n* one-to-many(separate): if the \"old set\" has only one data item, and the \"new set\" has more than one data items.\n* many-to-one(combine): if the \"old set\" has more than one data items, and the \"new set\" has only one data item.\n\nNote: we do not support transition animation for the case many-to-many. Then custom series find graphic elements that has morph: true declared in these two sets, and map them for one to one morphing or combining or separating. See examples: [custom-one-to-one-morph][1] and [custom-combine-separate-morph][2].\n\n[0]: api.html#echartsInstance.setOption\n[1]: https://echarts.apache.org/examples/en/editor.html?c=custom-one-to-one-morph&edit=1&reset=1\n[2]: https://echarts.apache.org/examples/en/editor.html?c=custom-combine-separate-morph&edit=1&reset=1"
    },
    "renderItem.return_circle.z2": {
        "desc": " Define the overlap relationship between graphic elements. "
    },
    "renderItem.return_circle.name": {
        "desc": " See [diffChildrenByName][0].\n\n[0]: #series-custom.renderItem.return_circle.diffChildrenByName"
    },
    "renderItem.return_circle.info": {
        "desc": " User defined data, can be visited in event listeners. \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "renderItem.return_circle.silent": {
        "desc": " Whether response to mouse events / touch events. "
    },
    "renderItem.return_circle.invisible": {
        "desc": " Whether the element is visible. "
    },
    "renderItem.return_circle.ignore": {
        "desc": " Whether the element is totally ignored (neither render nor listen events). "
    },
    "renderItem.return_circle.textContent": {
        "desc": " Text block attached to an element and layout based on the element by textConfig. The props the the same as [text][0].\n\n[0]: option.html#series-custom.renderItem.return_text"
    },
    "renderItem.return_circle.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "renderItem.return_circle.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "renderItem.return_circle.textConfig.rotation": {
        "desc": " Rotation of textContent. In radian. "
    },
    "renderItem.return_circle.textConfig.layoutRect": {
        "desc": " Rect that textContent will be positioned. Default to be the bounding box of host element. \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "renderItem.return_circle.textConfig.offset": {
        "desc": " Offset of the textContent. The difference of offset and position is that offset will be applied in the rotation. "
    },
    "renderItem.return_circle.textConfig.origin": {
        "desc": "origin is relative to the bounding box of the host element. Can be percent value. Relative to the bounding box. If 'center' specified, it will be center of the bounding box. Only available when position and rotation are both set. \n\n* like [12, 33]\n* or like ['50%', '50%']\n* 'center'\n\n"
    },
    "renderItem.return_circle.textConfig.distance": {
        "desc": " Distance to the layoutRectã€‚ "
    },
    "renderItem.return_circle.textConfig.local": {
        "desc": " If true, it will apply host's transform. "
    },
    "renderItem.return_circle.textConfig.insideFill": {
        "desc": "insideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" In most cases, \"auto-calculated-fill\" is white. "
    },
    "renderItem.return_circle.textConfig.insideStroke": {
        "desc": "insideStroke is a color string or left empty. If a textContent is \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be the same as fill of this element if possible, or null.\n\n"
    },
    "renderItem.return_circle.textConfig.outsideFill": {
        "desc": "outsideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "renderItem.return_circle.textConfig.outsideStroke": {
        "desc": "outsideStroke is a color string or left empty. If a textContent is not \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be a near white color to distinguish \"front end\" label with messy background (like other text label, line or other graphic).\n\n"
    },
    "renderItem.return_circle.textConfig.inside": {
        "desc": " Tell echarts that I can make sure this text is inside or not. "
    },
    "renderItem.return_circle.during": {
        "desc": "during callback enable users to set props to an element in each animation frame. \n\n    (duringAPI: CustomDuringAPI) => void\n    \n    interface CustomDuringAPI {\n        // Set transform prop value.\n        // Transform prop see `TransformProp`.\n        setTransform(key: TransformProp, val: unknown): void;\n        // Get transform prop value of the current animation frame.\n        getTransform(key: TransformProp): unknown;\n        // Set shape prop value.\n        // Shape prop is like `{ type: 'rect', shape: { xxxProp: xxxValue } }`.\n        setShape(key: string, val: unknown): void;\n        // Get shape prop value of the current animation frame.\n        getShape(key: string): unknown;\n        // Set style prop value.\n        // Style prop is like `{ type: 'rect', style: { xxxProp: xxxValue } }`.\n        setStyle(key: string, val: unknown): void;\n        // Get style prop value of the current animation frame.\n        getStyle(key: string): unknown;\n        // Set extra prop value.\n        // Extra prop is like `{ type: 'rect', extra: { xxxProp: xxxValue } }`.\n        setExtra(key: string, val: unknown): void;\n        // Get extra prop value of the current animation frame.\n        getExtra(key: string): unknown;\n    }\n    \n    type TransformProp =\n        'x' | 'y' | 'scaleX' | 'scaleY' | 'originX' | 'originY' | 'rotation';\n    \n\nIn most cases users do not need this during callback. For example, if some props are specified in [transition][0], echarts will make interpolation for these props internally and therefore have animation based on these props automatically. But if this kind of internal interpolation does not match the user requirements of animation, users can use this during callback to customize them. For example, if users are using [polygon][1] shape. The shape is described by [shape.points][2], which is an points array like: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: [[12, 33], [15, 36], [19, 39], ...]\n        },\n        // ...\n    }\n    \n\nIf users specify them into [transition][3] like: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: [[12, 33], [15, 36], [19, 39], ...],\n        },\n        transition: 'shape'\n        // ...\n    }\n    \n\nAlthough the points will be interpolated, the consequent animation will be like that each point runs straight to the target position, which might do not match the user requirement if some kind of track like spiral is actually needed. In this case, users can use the during callback like that: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: calculatePoints(initialDegree),\n            transition: 'points'\n        },\n        extra: {\n            degree: nextDegree\n        },\n        // Make echarts interpolate `extra.degree` internally, based on which\n        // we calculate the `points` in each animation frame.\n        transition: 'extra',\n        during: function (duringAPI) {\n            var currentDegree = duringAPI.getExtra('degree');\n            duringAPI.setShape(calculatePoints(currentDegree));\n        }\n        // ...\n    }\n    \n\nSee this example [example][4].\n\n[0]: option.html#series-custom.renderItem.return_rect.transition\n[1]: option.html#series-custom.renderItem.return_polygon\n[2]: option.html#series-custom.renderItem.return_polygon.shape.points\n[3]: option.html#series-custom.renderItem.return_polygon.transition\n[4]: https://echarts.apache.org/examples/en/editor.html?c=custom-spiral-race&edit=1&reset=1"
    },
    "renderItem.return_circle.extra": {
        "desc": " Users can define their own props in this extra field. See [during][0] for the major usage of extra.\n\n[0]: option.html#series-custom.renderItem.return_rect.during"
    },
    "renderItem.return_circle.extra.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this extra. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            extra: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            extra: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `extra` will\n            // have transition animation.\n            transition: 'extra',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_circle.shape": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "renderItem.return_circle.shape.cx": {
        "desc": " The x value of the center of the element in the coordinate system of its parent. "
    },
    "renderItem.return_circle.shape.cy": {
        "desc": " The y value of the center of the element in the coordinate system of its parent. "
    },
    "renderItem.return_circle.shape.r": {
        "desc": " Outside radius. "
    },
    "renderItem.return_circle.shape.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this shape. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            shape: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            shape: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `shape` will\n            // have transition animation.\n            transition: 'shape',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_circle.style": {
        "desc": " More attributes in style (for example, [rich text][0]), see the style related attributes in [zrender/graphic/Displayable][1]. Notice, the attribute names of the style of graphic elements is derived from zrender, which may be different from the attribute names in echarts label, echarts itemStyle, etc., although they have the same meaning. For example: \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#Rich%20Text\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "renderItem.return_circle.style.fill": {
        "desc": " Color filled in this element. "
    },
    "renderItem.return_circle.style.stroke": {
        "desc": " Color of stroke. "
    },
    "renderItem.return_circle.style.lineWidth": {
        "desc": " Width of stroke. "
    },
    "renderItem.return_circle.style.shadowBlur": {
        "desc": " Width of shadow. "
    },
    "renderItem.return_circle.style.shadowOffsetX": {
        "desc": " X offset of shadow. "
    },
    "renderItem.return_circle.style.shadowOffsetY": {
        "desc": " Y offset of shadow. "
    },
    "renderItem.return_circle.style.shadowColor": {
        "desc": " color of shadow. "
    },
    "renderItem.return_circle.style.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this style. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            style: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            style: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `style` will\n            // have transition animation.\n            transition: 'style',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_circle.focus": {
        "desc": ">  Since > v5.0.0 When it's highlighted, whether to fade out of other data to focus the highlighted. The following configurations are supported: \n\n* 'none' Do not fade out other data, it's by default.\n* 'self' Only focus (not fade out) the element of the currently highlighted data.\n* 'series' Focus on all elements of the series which the currently highlighted data belongs to.\n\n"
    },
    "renderItem.return_circle.blurScope": {
        "desc": ">  Since > v5.0.0 The range of fade out when focus is enabled. Support the following configurations \n\n* 'coordinateSystem'\n* 'series'\n* 'global'\n\n"
    },
    "renderItem.return_circle.emphasis": {
        "desc": " Emphasis state of the element. "
    },
    "renderItem.return_circle.emphasis.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_circle.blur": {
        "desc": ">  Since > v5.0.0 Blur state, available when focus is set. "
    },
    "renderItem.return_circle.blur.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_circle.select": {
        "desc": ">  Since > v5.0.0 Select state, available when [selectedMode][0] is set.\n\n[0]: #series-custom.selectedMode"
    },
    "renderItem.return_circle.select.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_ring": {
        "desc": " Ring element. "
    },
    "renderItem.return_ring.type": {
        "desc": " Must be specified when define a graphic element at the first time. Optional values: [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #series-custom.renderItem.return_image\n[1]: #series-custom.renderItem.return_text\n[2]: #series-custom.renderItem.return_circle\n[3]: #series-custom.renderItem.return_sector\n[4]: #series-custom.renderItem.return_ring\n[5]: #series-custom.renderItem.return_polygon\n[6]: #series-custom.renderItem.return_polyline\n[7]: #series-custom.renderItem.return_rect\n[8]: #series-custom.renderItem.return_line\n[9]: #series-custom.renderItem.return_bezierCurve\n[10]: #series-custom.renderItem.return_arc\n[11]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_ring.id": {
        "desc": " id is used to specifying element when willing to update it. id can be ignored if you do not need it. "
    },
    "renderItem.return_ring.x": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_ring.x\n[1]: #series-custom.renderItem.return_ring.y\n[2]: #series-custom.renderItem.return_ring.rotation\n[3]: #series-custom.renderItem.return_ring.scaleX\n[4]: #series-custom.renderItem.return_ring.scaleY\n[5]: #series-custom.renderItem.return_ring.originX\n[6]: #series-custom.renderItem.return_ring.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_ring.y": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_ring.x\n[1]: #series-custom.renderItem.return_ring.y\n[2]: #series-custom.renderItem.return_ring.rotation\n[3]: #series-custom.renderItem.return_ring.scaleX\n[4]: #series-custom.renderItem.return_ring.scaleY\n[5]: #series-custom.renderItem.return_ring.originX\n[6]: #series-custom.renderItem.return_ring.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_ring.rotation": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_ring.x\n[1]: #series-custom.renderItem.return_ring.y\n[2]: #series-custom.renderItem.return_ring.rotation\n[3]: #series-custom.renderItem.return_ring.scaleX\n[4]: #series-custom.renderItem.return_ring.scaleY\n[5]: #series-custom.renderItem.return_ring.originX\n[6]: #series-custom.renderItem.return_ring.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_ring.scaleX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_ring.x\n[1]: #series-custom.renderItem.return_ring.y\n[2]: #series-custom.renderItem.return_ring.rotation\n[3]: #series-custom.renderItem.return_ring.scaleX\n[4]: #series-custom.renderItem.return_ring.scaleY\n[5]: #series-custom.renderItem.return_ring.originX\n[6]: #series-custom.renderItem.return_ring.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_ring.scaleY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_ring.x\n[1]: #series-custom.renderItem.return_ring.y\n[2]: #series-custom.renderItem.return_ring.rotation\n[3]: #series-custom.renderItem.return_ring.scaleX\n[4]: #series-custom.renderItem.return_ring.scaleY\n[5]: #series-custom.renderItem.return_ring.originX\n[6]: #series-custom.renderItem.return_ring.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_ring.originX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_ring.x\n[1]: #series-custom.renderItem.return_ring.y\n[2]: #series-custom.renderItem.return_ring.rotation\n[3]: #series-custom.renderItem.return_ring.scaleX\n[4]: #series-custom.renderItem.return_ring.scaleY\n[5]: #series-custom.renderItem.return_ring.originX\n[6]: #series-custom.renderItem.return_ring.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_ring.originY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_ring.x\n[1]: #series-custom.renderItem.return_ring.y\n[2]: #series-custom.renderItem.return_ring.rotation\n[3]: #series-custom.renderItem.return_ring.scaleX\n[4]: #series-custom.renderItem.return_ring.scaleY\n[5]: #series-custom.renderItem.return_ring.originX\n[6]: #series-custom.renderItem.return_ring.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_ring.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. The properties can only be: \n\n* Transform related properties: ['x'][0], ['y'][1], ['scaleX'][2], ['scaleY'][3], ['rotation'][4], ['originX'][5], ['originY'][6]. For example:\n\n      renderItem: function (params, api) {\n          var coord = api.coord([api.value(0), api.value[1]);\n          return {\n              type: 'rect',\n              x: coord[0],\n              y: coord[1],\n              shape: {\n                  x: 0,\n                  y: 0,\n                  width: api.value(2),\n                  height: 100\n              },\n              transition: ['x', 'y', 'width']\n          }\n      }\n* Shortcut to transition all of the properties in ['shape'][7], ['style'][8], ['extra'][9]. For example:\n\n      renderItem: function (params, api) {\n          return {\n              type: 'rect',\n              shape: {\n                  x: api.value(0),\n                  y: api.value(1),\n                  width: api.value(2),\n                  height: api.value(3)\n              },\n              // Indicate that all props in `shape` will\n              // have transition animation.\n              transition: 'shape',\n          };\n      }\n    \n\nIt is equivalent to:\n\n      renderItem: function (params, api) {\n          return {\n              type: 'rect',\n              shape: {\n                  x: api.value(0),\n                  y: api.value(1),\n                  width: api.value(2),\n                  height: api.value(3),\n                  // This usage can only enable part of the\n                  // properties transition.\n                  transition: ['x', 'y', 'width', 'height']\n              }\n          };\n      }\n\nBy default, ['x'][0] and ['y'][1] are transitioned. If you want to disable the default transition, just set it as: \n\n    transition: [] // Am empty array.\n    \n\nSee this [example][10] please.\n\n[0]: #series-custom.renderItem.return_ring.x\n[1]: #series-custom.renderItem.return_ring.y\n[2]: #series-custom.renderItem.return_ring.scaleX\n[3]: #series-custom.renderItem.return_ring.scaleY\n[4]: #series-custom.renderItem.return_ring.rotation\n[5]: #series-custom.renderItem.return_ring.originX\n[6]: #series-custom.renderItem.return_ring.originY\n[7]: #series-custom.renderItem.return_ring.shape\n[8]: #series-custom.renderItem.return_ring.style\n[9]: #series-custom.renderItem.return_ring.extra\n[10]: https://echarts.apache.org/examples/en/editor.html?c=doc-example/custom-transition-simple&edit=1&reset=1"
    },
    "renderItem.return_ring.morph": {
        "desc": " Whether to enable morphing animation. **When morphing animation happen?** If morph is set as true, the morphing animation will happen according to the following rule: Each time the render process happen, custom series will diff the old data and the new data. If a set of old data items (say, \"old set\") are value-equal to a set of new data items (say, \"new set\") in name or the specified dimensions (see parameter [transition][0] in setOption), we found a pair of sets as transition candidates. Three type of transition animation can be performed between the two sets: \n\n* one-to-one: if both the two sets has only one data item.\n* one-to-many(separate): if the \"old set\" has only one data item, and the \"new set\" has more than one data items.\n* many-to-one(combine): if the \"old set\" has more than one data items, and the \"new set\" has only one data item.\n\nNote: we do not support transition animation for the case many-to-many. Then custom series find graphic elements that has morph: true declared in these two sets, and map them for one to one morphing or combining or separating. See examples: [custom-one-to-one-morph][1] and [custom-combine-separate-morph][2].\n\n[0]: api.html#echartsInstance.setOption\n[1]: https://echarts.apache.org/examples/en/editor.html?c=custom-one-to-one-morph&edit=1&reset=1\n[2]: https://echarts.apache.org/examples/en/editor.html?c=custom-combine-separate-morph&edit=1&reset=1"
    },
    "renderItem.return_ring.z2": {
        "desc": " Define the overlap relationship between graphic elements. "
    },
    "renderItem.return_ring.name": {
        "desc": " See [diffChildrenByName][0].\n\n[0]: #series-custom.renderItem.return_ring.diffChildrenByName"
    },
    "renderItem.return_ring.info": {
        "desc": " User defined data, can be visited in event listeners. \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "renderItem.return_ring.silent": {
        "desc": " Whether response to mouse events / touch events. "
    },
    "renderItem.return_ring.invisible": {
        "desc": " Whether the element is visible. "
    },
    "renderItem.return_ring.ignore": {
        "desc": " Whether the element is totally ignored (neither render nor listen events). "
    },
    "renderItem.return_ring.textContent": {
        "desc": " Text block attached to an element and layout based on the element by textConfig. The props the the same as [text][0].\n\n[0]: option.html#series-custom.renderItem.return_text"
    },
    "renderItem.return_ring.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "renderItem.return_ring.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "renderItem.return_ring.textConfig.rotation": {
        "desc": " Rotation of textContent. In radian. "
    },
    "renderItem.return_ring.textConfig.layoutRect": {
        "desc": " Rect that textContent will be positioned. Default to be the bounding box of host element. \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "renderItem.return_ring.textConfig.offset": {
        "desc": " Offset of the textContent. The difference of offset and position is that offset will be applied in the rotation. "
    },
    "renderItem.return_ring.textConfig.origin": {
        "desc": "origin is relative to the bounding box of the host element. Can be percent value. Relative to the bounding box. If 'center' specified, it will be center of the bounding box. Only available when position and rotation are both set. \n\n* like [12, 33]\n* or like ['50%', '50%']\n* 'center'\n\n"
    },
    "renderItem.return_ring.textConfig.distance": {
        "desc": " Distance to the layoutRectã€‚ "
    },
    "renderItem.return_ring.textConfig.local": {
        "desc": " If true, it will apply host's transform. "
    },
    "renderItem.return_ring.textConfig.insideFill": {
        "desc": "insideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" In most cases, \"auto-calculated-fill\" is white. "
    },
    "renderItem.return_ring.textConfig.insideStroke": {
        "desc": "insideStroke is a color string or left empty. If a textContent is \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be the same as fill of this element if possible, or null.\n\n"
    },
    "renderItem.return_ring.textConfig.outsideFill": {
        "desc": "outsideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "renderItem.return_ring.textConfig.outsideStroke": {
        "desc": "outsideStroke is a color string or left empty. If a textContent is not \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be a near white color to distinguish \"front end\" label with messy background (like other text label, line or other graphic).\n\n"
    },
    "renderItem.return_ring.textConfig.inside": {
        "desc": " Tell echarts that I can make sure this text is inside or not. "
    },
    "renderItem.return_ring.during": {
        "desc": "during callback enable users to set props to an element in each animation frame. \n\n    (duringAPI: CustomDuringAPI) => void\n    \n    interface CustomDuringAPI {\n        // Set transform prop value.\n        // Transform prop see `TransformProp`.\n        setTransform(key: TransformProp, val: unknown): void;\n        // Get transform prop value of the current animation frame.\n        getTransform(key: TransformProp): unknown;\n        // Set shape prop value.\n        // Shape prop is like `{ type: 'rect', shape: { xxxProp: xxxValue } }`.\n        setShape(key: string, val: unknown): void;\n        // Get shape prop value of the current animation frame.\n        getShape(key: string): unknown;\n        // Set style prop value.\n        // Style prop is like `{ type: 'rect', style: { xxxProp: xxxValue } }`.\n        setStyle(key: string, val: unknown): void;\n        // Get style prop value of the current animation frame.\n        getStyle(key: string): unknown;\n        // Set extra prop value.\n        // Extra prop is like `{ type: 'rect', extra: { xxxProp: xxxValue } }`.\n        setExtra(key: string, val: unknown): void;\n        // Get extra prop value of the current animation frame.\n        getExtra(key: string): unknown;\n    }\n    \n    type TransformProp =\n        'x' | 'y' | 'scaleX' | 'scaleY' | 'originX' | 'originY' | 'rotation';\n    \n\nIn most cases users do not need this during callback. For example, if some props are specified in [transition][0], echarts will make interpolation for these props internally and therefore have animation based on these props automatically. But if this kind of internal interpolation does not match the user requirements of animation, users can use this during callback to customize them. For example, if users are using [polygon][1] shape. The shape is described by [shape.points][2], which is an points array like: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: [[12, 33], [15, 36], [19, 39], ...]\n        },\n        // ...\n    }\n    \n\nIf users specify them into [transition][3] like: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: [[12, 33], [15, 36], [19, 39], ...],\n        },\n        transition: 'shape'\n        // ...\n    }\n    \n\nAlthough the points will be interpolated, the consequent animation will be like that each point runs straight to the target position, which might do not match the user requirement if some kind of track like spiral is actually needed. In this case, users can use the during callback like that: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: calculatePoints(initialDegree),\n            transition: 'points'\n        },\n        extra: {\n            degree: nextDegree\n        },\n        // Make echarts interpolate `extra.degree` internally, based on which\n        // we calculate the `points` in each animation frame.\n        transition: 'extra',\n        during: function (duringAPI) {\n            var currentDegree = duringAPI.getExtra('degree');\n            duringAPI.setShape(calculatePoints(currentDegree));\n        }\n        // ...\n    }\n    \n\nSee this example [example][4].\n\n[0]: option.html#series-custom.renderItem.return_rect.transition\n[1]: option.html#series-custom.renderItem.return_polygon\n[2]: option.html#series-custom.renderItem.return_polygon.shape.points\n[3]: option.html#series-custom.renderItem.return_polygon.transition\n[4]: https://echarts.apache.org/examples/en/editor.html?c=custom-spiral-race&edit=1&reset=1"
    },
    "renderItem.return_ring.extra": {
        "desc": " Users can define their own props in this extra field. See [during][0] for the major usage of extra.\n\n[0]: option.html#series-custom.renderItem.return_rect.during"
    },
    "renderItem.return_ring.extra.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this extra. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            extra: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            extra: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `extra` will\n            // have transition animation.\n            transition: 'extra',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_ring.shape": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "renderItem.return_ring.shape.cx": {
        "desc": " The x value of the center of the element in the coordinate system of its parent. "
    },
    "renderItem.return_ring.shape.cy": {
        "desc": " The y value of the center of the element in the coordinate system of its parent. "
    },
    "renderItem.return_ring.shape.r": {
        "desc": " Outside radius. "
    },
    "renderItem.return_ring.shape.r0": {
        "desc": " Inside radius. "
    },
    "renderItem.return_ring.shape.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this shape. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            shape: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            shape: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `shape` will\n            // have transition animation.\n            transition: 'shape',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_ring.style": {
        "desc": " More attributes in style (for example, [rich text][0]), see the style related attributes in [zrender/graphic/Displayable][1]. Notice, the attribute names of the style of graphic elements is derived from zrender, which may be different from the attribute names in echarts label, echarts itemStyle, etc., although they have the same meaning. For example: \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#Rich%20Text\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "renderItem.return_ring.style.fill": {
        "desc": " Color filled in this element. "
    },
    "renderItem.return_ring.style.stroke": {
        "desc": " Color of stroke. "
    },
    "renderItem.return_ring.style.lineWidth": {
        "desc": " Width of stroke. "
    },
    "renderItem.return_ring.style.shadowBlur": {
        "desc": " Width of shadow. "
    },
    "renderItem.return_ring.style.shadowOffsetX": {
        "desc": " X offset of shadow. "
    },
    "renderItem.return_ring.style.shadowOffsetY": {
        "desc": " Y offset of shadow. "
    },
    "renderItem.return_ring.style.shadowColor": {
        "desc": " color of shadow. "
    },
    "renderItem.return_ring.style.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this style. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            style: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            style: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `style` will\n            // have transition animation.\n            transition: 'style',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_ring.focus": {
        "desc": ">  Since > v5.0.0 When it's highlighted, whether to fade out of other data to focus the highlighted. The following configurations are supported: \n\n* 'none' Do not fade out other data, it's by default.\n* 'self' Only focus (not fade out) the element of the currently highlighted data.\n* 'series' Focus on all elements of the series which the currently highlighted data belongs to.\n\n"
    },
    "renderItem.return_ring.blurScope": {
        "desc": ">  Since > v5.0.0 The range of fade out when focus is enabled. Support the following configurations \n\n* 'coordinateSystem'\n* 'series'\n* 'global'\n\n"
    },
    "renderItem.return_ring.emphasis": {
        "desc": " Emphasis state of the element. "
    },
    "renderItem.return_ring.emphasis.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_ring.blur": {
        "desc": ">  Since > v5.0.0 Blur state, available when focus is set. "
    },
    "renderItem.return_ring.blur.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_ring.select": {
        "desc": ">  Since > v5.0.0 Select state, available when [selectedMode][0] is set.\n\n[0]: #series-custom.selectedMode"
    },
    "renderItem.return_ring.select.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_sector": {
        "desc": " Sector element. "
    },
    "renderItem.return_sector.type": {
        "desc": " Must be specified when define a graphic element at the first time. Optional values: [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #series-custom.renderItem.return_image\n[1]: #series-custom.renderItem.return_text\n[2]: #series-custom.renderItem.return_circle\n[3]: #series-custom.renderItem.return_sector\n[4]: #series-custom.renderItem.return_ring\n[5]: #series-custom.renderItem.return_polygon\n[6]: #series-custom.renderItem.return_polyline\n[7]: #series-custom.renderItem.return_rect\n[8]: #series-custom.renderItem.return_line\n[9]: #series-custom.renderItem.return_bezierCurve\n[10]: #series-custom.renderItem.return_arc\n[11]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_sector.id": {
        "desc": " id is used to specifying element when willing to update it. id can be ignored if you do not need it. "
    },
    "renderItem.return_sector.x": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_sector.x\n[1]: #series-custom.renderItem.return_sector.y\n[2]: #series-custom.renderItem.return_sector.rotation\n[3]: #series-custom.renderItem.return_sector.scaleX\n[4]: #series-custom.renderItem.return_sector.scaleY\n[5]: #series-custom.renderItem.return_sector.originX\n[6]: #series-custom.renderItem.return_sector.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_sector.y": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_sector.x\n[1]: #series-custom.renderItem.return_sector.y\n[2]: #series-custom.renderItem.return_sector.rotation\n[3]: #series-custom.renderItem.return_sector.scaleX\n[4]: #series-custom.renderItem.return_sector.scaleY\n[5]: #series-custom.renderItem.return_sector.originX\n[6]: #series-custom.renderItem.return_sector.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_sector.rotation": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_sector.x\n[1]: #series-custom.renderItem.return_sector.y\n[2]: #series-custom.renderItem.return_sector.rotation\n[3]: #series-custom.renderItem.return_sector.scaleX\n[4]: #series-custom.renderItem.return_sector.scaleY\n[5]: #series-custom.renderItem.return_sector.originX\n[6]: #series-custom.renderItem.return_sector.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_sector.scaleX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_sector.x\n[1]: #series-custom.renderItem.return_sector.y\n[2]: #series-custom.renderItem.return_sector.rotation\n[3]: #series-custom.renderItem.return_sector.scaleX\n[4]: #series-custom.renderItem.return_sector.scaleY\n[5]: #series-custom.renderItem.return_sector.originX\n[6]: #series-custom.renderItem.return_sector.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_sector.scaleY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_sector.x\n[1]: #series-custom.renderItem.return_sector.y\n[2]: #series-custom.renderItem.return_sector.rotation\n[3]: #series-custom.renderItem.return_sector.scaleX\n[4]: #series-custom.renderItem.return_sector.scaleY\n[5]: #series-custom.renderItem.return_sector.originX\n[6]: #series-custom.renderItem.return_sector.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_sector.originX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_sector.x\n[1]: #series-custom.renderItem.return_sector.y\n[2]: #series-custom.renderItem.return_sector.rotation\n[3]: #series-custom.renderItem.return_sector.scaleX\n[4]: #series-custom.renderItem.return_sector.scaleY\n[5]: #series-custom.renderItem.return_sector.originX\n[6]: #series-custom.renderItem.return_sector.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_sector.originY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_sector.x\n[1]: #series-custom.renderItem.return_sector.y\n[2]: #series-custom.renderItem.return_sector.rotation\n[3]: #series-custom.renderItem.return_sector.scaleX\n[4]: #series-custom.renderItem.return_sector.scaleY\n[5]: #series-custom.renderItem.return_sector.originX\n[6]: #series-custom.renderItem.return_sector.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_sector.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. The properties can only be: \n\n* Transform related properties: ['x'][0], ['y'][1], ['scaleX'][2], ['scaleY'][3], ['rotation'][4], ['originX'][5], ['originY'][6]. For example:\n\n      renderItem: function (params, api) {\n          var coord = api.coord([api.value(0), api.value[1]);\n          return {\n              type: 'rect',\n              x: coord[0],\n              y: coord[1],\n              shape: {\n                  x: 0,\n                  y: 0,\n                  width: api.value(2),\n                  height: 100\n              },\n              transition: ['x', 'y', 'width']\n          }\n      }\n* Shortcut to transition all of the properties in ['shape'][7], ['style'][8], ['extra'][9]. For example:\n\n      renderItem: function (params, api) {\n          return {\n              type: 'rect',\n              shape: {\n                  x: api.value(0),\n                  y: api.value(1),\n                  width: api.value(2),\n                  height: api.value(3)\n              },\n              // Indicate that all props in `shape` will\n              // have transition animation.\n              transition: 'shape',\n          };\n      }\n    \n\nIt is equivalent to:\n\n      renderItem: function (params, api) {\n          return {\n              type: 'rect',\n              shape: {\n                  x: api.value(0),\n                  y: api.value(1),\n                  width: api.value(2),\n                  height: api.value(3),\n                  // This usage can only enable part of the\n                  // properties transition.\n                  transition: ['x', 'y', 'width', 'height']\n              }\n          };\n      }\n\nBy default, ['x'][0] and ['y'][1] are transitioned. If you want to disable the default transition, just set it as: \n\n    transition: [] // Am empty array.\n    \n\nSee this [example][10] please.\n\n[0]: #series-custom.renderItem.return_sector.x\n[1]: #series-custom.renderItem.return_sector.y\n[2]: #series-custom.renderItem.return_sector.scaleX\n[3]: #series-custom.renderItem.return_sector.scaleY\n[4]: #series-custom.renderItem.return_sector.rotation\n[5]: #series-custom.renderItem.return_sector.originX\n[6]: #series-custom.renderItem.return_sector.originY\n[7]: #series-custom.renderItem.return_sector.shape\n[8]: #series-custom.renderItem.return_sector.style\n[9]: #series-custom.renderItem.return_sector.extra\n[10]: https://echarts.apache.org/examples/en/editor.html?c=doc-example/custom-transition-simple&edit=1&reset=1"
    },
    "renderItem.return_sector.morph": {
        "desc": " Whether to enable morphing animation. **When morphing animation happen?** If morph is set as true, the morphing animation will happen according to the following rule: Each time the render process happen, custom series will diff the old data and the new data. If a set of old data items (say, \"old set\") are value-equal to a set of new data items (say, \"new set\") in name or the specified dimensions (see parameter [transition][0] in setOption), we found a pair of sets as transition candidates. Three type of transition animation can be performed between the two sets: \n\n* one-to-one: if both the two sets has only one data item.\n* one-to-many(separate): if the \"old set\" has only one data item, and the \"new set\" has more than one data items.\n* many-to-one(combine): if the \"old set\" has more than one data items, and the \"new set\" has only one data item.\n\nNote: we do not support transition animation for the case many-to-many. Then custom series find graphic elements that has morph: true declared in these two sets, and map them for one to one morphing or combining or separating. See examples: [custom-one-to-one-morph][1] and [custom-combine-separate-morph][2].\n\n[0]: api.html#echartsInstance.setOption\n[1]: https://echarts.apache.org/examples/en/editor.html?c=custom-one-to-one-morph&edit=1&reset=1\n[2]: https://echarts.apache.org/examples/en/editor.html?c=custom-combine-separate-morph&edit=1&reset=1"
    },
    "renderItem.return_sector.z2": {
        "desc": " Define the overlap relationship between graphic elements. "
    },
    "renderItem.return_sector.name": {
        "desc": " See [diffChildrenByName][0].\n\n[0]: #series-custom.renderItem.return_sector.diffChildrenByName"
    },
    "renderItem.return_sector.info": {
        "desc": " User defined data, can be visited in event listeners. \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "renderItem.return_sector.silent": {
        "desc": " Whether response to mouse events / touch events. "
    },
    "renderItem.return_sector.invisible": {
        "desc": " Whether the element is visible. "
    },
    "renderItem.return_sector.ignore": {
        "desc": " Whether the element is totally ignored (neither render nor listen events). "
    },
    "renderItem.return_sector.textContent": {
        "desc": " Text block attached to an element and layout based on the element by textConfig. The props the the same as [text][0].\n\n[0]: option.html#series-custom.renderItem.return_text"
    },
    "renderItem.return_sector.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "renderItem.return_sector.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "renderItem.return_sector.textConfig.rotation": {
        "desc": " Rotation of textContent. In radian. "
    },
    "renderItem.return_sector.textConfig.layoutRect": {
        "desc": " Rect that textContent will be positioned. Default to be the bounding box of host element. \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "renderItem.return_sector.textConfig.offset": {
        "desc": " Offset of the textContent. The difference of offset and position is that offset will be applied in the rotation. "
    },
    "renderItem.return_sector.textConfig.origin": {
        "desc": "origin is relative to the bounding box of the host element. Can be percent value. Relative to the bounding box. If 'center' specified, it will be center of the bounding box. Only available when position and rotation are both set. \n\n* like [12, 33]\n* or like ['50%', '50%']\n* 'center'\n\n"
    },
    "renderItem.return_sector.textConfig.distance": {
        "desc": " Distance to the layoutRectã€‚ "
    },
    "renderItem.return_sector.textConfig.local": {
        "desc": " If true, it will apply host's transform. "
    },
    "renderItem.return_sector.textConfig.insideFill": {
        "desc": "insideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" In most cases, \"auto-calculated-fill\" is white. "
    },
    "renderItem.return_sector.textConfig.insideStroke": {
        "desc": "insideStroke is a color string or left empty. If a textContent is \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be the same as fill of this element if possible, or null.\n\n"
    },
    "renderItem.return_sector.textConfig.outsideFill": {
        "desc": "outsideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "renderItem.return_sector.textConfig.outsideStroke": {
        "desc": "outsideStroke is a color string or left empty. If a textContent is not \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be a near white color to distinguish \"front end\" label with messy background (like other text label, line or other graphic).\n\n"
    },
    "renderItem.return_sector.textConfig.inside": {
        "desc": " Tell echarts that I can make sure this text is inside or not. "
    },
    "renderItem.return_sector.during": {
        "desc": "during callback enable users to set props to an element in each animation frame. \n\n    (duringAPI: CustomDuringAPI) => void\n    \n    interface CustomDuringAPI {\n        // Set transform prop value.\n        // Transform prop see `TransformProp`.\n        setTransform(key: TransformProp, val: unknown): void;\n        // Get transform prop value of the current animation frame.\n        getTransform(key: TransformProp): unknown;\n        // Set shape prop value.\n        // Shape prop is like `{ type: 'rect', shape: { xxxProp: xxxValue } }`.\n        setShape(key: string, val: unknown): void;\n        // Get shape prop value of the current animation frame.\n        getShape(key: string): unknown;\n        // Set style prop value.\n        // Style prop is like `{ type: 'rect', style: { xxxProp: xxxValue } }`.\n        setStyle(key: string, val: unknown): void;\n        // Get style prop value of the current animation frame.\n        getStyle(key: string): unknown;\n        // Set extra prop value.\n        // Extra prop is like `{ type: 'rect', extra: { xxxProp: xxxValue } }`.\n        setExtra(key: string, val: unknown): void;\n        // Get extra prop value of the current animation frame.\n        getExtra(key: string): unknown;\n    }\n    \n    type TransformProp =\n        'x' | 'y' | 'scaleX' | 'scaleY' | 'originX' | 'originY' | 'rotation';\n    \n\nIn most cases users do not need this during callback. For example, if some props are specified in [transition][0], echarts will make interpolation for these props internally and therefore have animation based on these props automatically. But if this kind of internal interpolation does not match the user requirements of animation, users can use this during callback to customize them. For example, if users are using [polygon][1] shape. The shape is described by [shape.points][2], which is an points array like: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: [[12, 33], [15, 36], [19, 39], ...]\n        },\n        // ...\n    }\n    \n\nIf users specify them into [transition][3] like: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: [[12, 33], [15, 36], [19, 39], ...],\n        },\n        transition: 'shape'\n        // ...\n    }\n    \n\nAlthough the points will be interpolated, the consequent animation will be like that each point runs straight to the target position, which might do not match the user requirement if some kind of track like spiral is actually needed. In this case, users can use the during callback like that: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: calculatePoints(initialDegree),\n            transition: 'points'\n        },\n        extra: {\n            degree: nextDegree\n        },\n        // Make echarts interpolate `extra.degree` internally, based on which\n        // we calculate the `points` in each animation frame.\n        transition: 'extra',\n        during: function (duringAPI) {\n            var currentDegree = duringAPI.getExtra('degree');\n            duringAPI.setShape(calculatePoints(currentDegree));\n        }\n        // ...\n    }\n    \n\nSee this example [example][4].\n\n[0]: option.html#series-custom.renderItem.return_rect.transition\n[1]: option.html#series-custom.renderItem.return_polygon\n[2]: option.html#series-custom.renderItem.return_polygon.shape.points\n[3]: option.html#series-custom.renderItem.return_polygon.transition\n[4]: https://echarts.apache.org/examples/en/editor.html?c=custom-spiral-race&edit=1&reset=1"
    },
    "renderItem.return_sector.extra": {
        "desc": " Users can define their own props in this extra field. See [during][0] for the major usage of extra.\n\n[0]: option.html#series-custom.renderItem.return_rect.during"
    },
    "renderItem.return_sector.extra.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this extra. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            extra: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            extra: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `extra` will\n            // have transition animation.\n            transition: 'extra',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_sector.shape": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "renderItem.return_sector.shape.cx": {
        "desc": " The x value of the center of the element in the coordinate system of its parent. "
    },
    "renderItem.return_sector.shape.cy": {
        "desc": " The y value of the center of the element in the coordinate system of its parent. "
    },
    "renderItem.return_sector.shape.r": {
        "desc": " Outside radius. "
    },
    "renderItem.return_sector.shape.r0": {
        "desc": " Inside radius. "
    },
    "renderItem.return_sector.shape.startAngle": {
        "desc": " start angle, in radian. "
    },
    "renderItem.return_sector.shape.endAngle": {
        "desc": " end angle, in radian. "
    },
    "renderItem.return_sector.shape.clockwise": {
        "desc": " Whether draw clockwise. "
    },
    "renderItem.return_sector.shape.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this shape. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            shape: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            shape: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `shape` will\n            // have transition animation.\n            transition: 'shape',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_sector.style": {
        "desc": " More attributes in style (for example, [rich text][0]), see the style related attributes in [zrender/graphic/Displayable][1]. Notice, the attribute names of the style of graphic elements is derived from zrender, which may be different from the attribute names in echarts label, echarts itemStyle, etc., although they have the same meaning. For example: \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#Rich%20Text\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "renderItem.return_sector.style.fill": {
        "desc": " Color filled in this element. "
    },
    "renderItem.return_sector.style.stroke": {
        "desc": " Color of stroke. "
    },
    "renderItem.return_sector.style.lineWidth": {
        "desc": " Width of stroke. "
    },
    "renderItem.return_sector.style.shadowBlur": {
        "desc": " Width of shadow. "
    },
    "renderItem.return_sector.style.shadowOffsetX": {
        "desc": " X offset of shadow. "
    },
    "renderItem.return_sector.style.shadowOffsetY": {
        "desc": " Y offset of shadow. "
    },
    "renderItem.return_sector.style.shadowColor": {
        "desc": " color of shadow. "
    },
    "renderItem.return_sector.style.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this style. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            style: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            style: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `style` will\n            // have transition animation.\n            transition: 'style',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_sector.focus": {
        "desc": ">  Since > v5.0.0 When it's highlighted, whether to fade out of other data to focus the highlighted. The following configurations are supported: \n\n* 'none' Do not fade out other data, it's by default.\n* 'self' Only focus (not fade out) the element of the currently highlighted data.\n* 'series' Focus on all elements of the series which the currently highlighted data belongs to.\n\n"
    },
    "renderItem.return_sector.blurScope": {
        "desc": ">  Since > v5.0.0 The range of fade out when focus is enabled. Support the following configurations \n\n* 'coordinateSystem'\n* 'series'\n* 'global'\n\n"
    },
    "renderItem.return_sector.emphasis": {
        "desc": " Emphasis state of the element. "
    },
    "renderItem.return_sector.emphasis.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_sector.blur": {
        "desc": ">  Since > v5.0.0 Blur state, available when focus is set. "
    },
    "renderItem.return_sector.blur.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_sector.select": {
        "desc": ">  Since > v5.0.0 Select state, available when [selectedMode][0] is set.\n\n[0]: #series-custom.selectedMode"
    },
    "renderItem.return_sector.select.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_arc": {
        "desc": " Arc element. "
    },
    "renderItem.return_arc.type": {
        "desc": " Must be specified when define a graphic element at the first time. Optional values: [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #series-custom.renderItem.return_image\n[1]: #series-custom.renderItem.return_text\n[2]: #series-custom.renderItem.return_circle\n[3]: #series-custom.renderItem.return_sector\n[4]: #series-custom.renderItem.return_ring\n[5]: #series-custom.renderItem.return_polygon\n[6]: #series-custom.renderItem.return_polyline\n[7]: #series-custom.renderItem.return_rect\n[8]: #series-custom.renderItem.return_line\n[9]: #series-custom.renderItem.return_bezierCurve\n[10]: #series-custom.renderItem.return_arc\n[11]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_arc.id": {
        "desc": " id is used to specifying element when willing to update it. id can be ignored if you do not need it. "
    },
    "renderItem.return_arc.x": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_arc.x\n[1]: #series-custom.renderItem.return_arc.y\n[2]: #series-custom.renderItem.return_arc.rotation\n[3]: #series-custom.renderItem.return_arc.scaleX\n[4]: #series-custom.renderItem.return_arc.scaleY\n[5]: #series-custom.renderItem.return_arc.originX\n[6]: #series-custom.renderItem.return_arc.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_arc.y": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_arc.x\n[1]: #series-custom.renderItem.return_arc.y\n[2]: #series-custom.renderItem.return_arc.rotation\n[3]: #series-custom.renderItem.return_arc.scaleX\n[4]: #series-custom.renderItem.return_arc.scaleY\n[5]: #series-custom.renderItem.return_arc.originX\n[6]: #series-custom.renderItem.return_arc.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_arc.rotation": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_arc.x\n[1]: #series-custom.renderItem.return_arc.y\n[2]: #series-custom.renderItem.return_arc.rotation\n[3]: #series-custom.renderItem.return_arc.scaleX\n[4]: #series-custom.renderItem.return_arc.scaleY\n[5]: #series-custom.renderItem.return_arc.originX\n[6]: #series-custom.renderItem.return_arc.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_arc.scaleX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_arc.x\n[1]: #series-custom.renderItem.return_arc.y\n[2]: #series-custom.renderItem.return_arc.rotation\n[3]: #series-custom.renderItem.return_arc.scaleX\n[4]: #series-custom.renderItem.return_arc.scaleY\n[5]: #series-custom.renderItem.return_arc.originX\n[6]: #series-custom.renderItem.return_arc.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_arc.scaleY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_arc.x\n[1]: #series-custom.renderItem.return_arc.y\n[2]: #series-custom.renderItem.return_arc.rotation\n[3]: #series-custom.renderItem.return_arc.scaleX\n[4]: #series-custom.renderItem.return_arc.scaleY\n[5]: #series-custom.renderItem.return_arc.originX\n[6]: #series-custom.renderItem.return_arc.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_arc.originX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_arc.x\n[1]: #series-custom.renderItem.return_arc.y\n[2]: #series-custom.renderItem.return_arc.rotation\n[3]: #series-custom.renderItem.return_arc.scaleX\n[4]: #series-custom.renderItem.return_arc.scaleY\n[5]: #series-custom.renderItem.return_arc.originX\n[6]: #series-custom.renderItem.return_arc.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_arc.originY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_arc.x\n[1]: #series-custom.renderItem.return_arc.y\n[2]: #series-custom.renderItem.return_arc.rotation\n[3]: #series-custom.renderItem.return_arc.scaleX\n[4]: #series-custom.renderItem.return_arc.scaleY\n[5]: #series-custom.renderItem.return_arc.originX\n[6]: #series-custom.renderItem.return_arc.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_arc.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. The properties can only be: \n\n* Transform related properties: ['x'][0], ['y'][1], ['scaleX'][2], ['scaleY'][3], ['rotation'][4], ['originX'][5], ['originY'][6]. For example:\n\n      renderItem: function (params, api) {\n          var coord = api.coord([api.value(0), api.value[1]);\n          return {\n              type: 'rect',\n              x: coord[0],\n              y: coord[1],\n              shape: {\n                  x: 0,\n                  y: 0,\n                  width: api.value(2),\n                  height: 100\n              },\n              transition: ['x', 'y', 'width']\n          }\n      }\n* Shortcut to transition all of the properties in ['shape'][7], ['style'][8], ['extra'][9]. For example:\n\n      renderItem: function (params, api) {\n          return {\n              type: 'rect',\n              shape: {\n                  x: api.value(0),\n                  y: api.value(1),\n                  width: api.value(2),\n                  height: api.value(3)\n              },\n              // Indicate that all props in `shape` will\n              // have transition animation.\n              transition: 'shape',\n          };\n      }\n    \n\nIt is equivalent to:\n\n      renderItem: function (params, api) {\n          return {\n              type: 'rect',\n              shape: {\n                  x: api.value(0),\n                  y: api.value(1),\n                  width: api.value(2),\n                  height: api.value(3),\n                  // This usage can only enable part of the\n                  // properties transition.\n                  transition: ['x', 'y', 'width', 'height']\n              }\n          };\n      }\n\nBy default, ['x'][0] and ['y'][1] are transitioned. If you want to disable the default transition, just set it as: \n\n    transition: [] // Am empty array.\n    \n\nSee this [example][10] please.\n\n[0]: #series-custom.renderItem.return_arc.x\n[1]: #series-custom.renderItem.return_arc.y\n[2]: #series-custom.renderItem.return_arc.scaleX\n[3]: #series-custom.renderItem.return_arc.scaleY\n[4]: #series-custom.renderItem.return_arc.rotation\n[5]: #series-custom.renderItem.return_arc.originX\n[6]: #series-custom.renderItem.return_arc.originY\n[7]: #series-custom.renderItem.return_arc.shape\n[8]: #series-custom.renderItem.return_arc.style\n[9]: #series-custom.renderItem.return_arc.extra\n[10]: https://echarts.apache.org/examples/en/editor.html?c=doc-example/custom-transition-simple&edit=1&reset=1"
    },
    "renderItem.return_arc.morph": {
        "desc": " Whether to enable morphing animation. **When morphing animation happen?** If morph is set as true, the morphing animation will happen according to the following rule: Each time the render process happen, custom series will diff the old data and the new data. If a set of old data items (say, \"old set\") are value-equal to a set of new data items (say, \"new set\") in name or the specified dimensions (see parameter [transition][0] in setOption), we found a pair of sets as transition candidates. Three type of transition animation can be performed between the two sets: \n\n* one-to-one: if both the two sets has only one data item.\n* one-to-many(separate): if the \"old set\" has only one data item, and the \"new set\" has more than one data items.\n* many-to-one(combine): if the \"old set\" has more than one data items, and the \"new set\" has only one data item.\n\nNote: we do not support transition animation for the case many-to-many. Then custom series find graphic elements that has morph: true declared in these two sets, and map them for one to one morphing or combining or separating. See examples: [custom-one-to-one-morph][1] and [custom-combine-separate-morph][2].\n\n[0]: api.html#echartsInstance.setOption\n[1]: https://echarts.apache.org/examples/en/editor.html?c=custom-one-to-one-morph&edit=1&reset=1\n[2]: https://echarts.apache.org/examples/en/editor.html?c=custom-combine-separate-morph&edit=1&reset=1"
    },
    "renderItem.return_arc.z2": {
        "desc": " Define the overlap relationship between graphic elements. "
    },
    "renderItem.return_arc.name": {
        "desc": " See [diffChildrenByName][0].\n\n[0]: #series-custom.renderItem.return_arc.diffChildrenByName"
    },
    "renderItem.return_arc.info": {
        "desc": " User defined data, can be visited in event listeners. \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "renderItem.return_arc.silent": {
        "desc": " Whether response to mouse events / touch events. "
    },
    "renderItem.return_arc.invisible": {
        "desc": " Whether the element is visible. "
    },
    "renderItem.return_arc.ignore": {
        "desc": " Whether the element is totally ignored (neither render nor listen events). "
    },
    "renderItem.return_arc.textContent": {
        "desc": " Text block attached to an element and layout based on the element by textConfig. The props the the same as [text][0].\n\n[0]: option.html#series-custom.renderItem.return_text"
    },
    "renderItem.return_arc.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "renderItem.return_arc.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "renderItem.return_arc.textConfig.rotation": {
        "desc": " Rotation of textContent. In radian. "
    },
    "renderItem.return_arc.textConfig.layoutRect": {
        "desc": " Rect that textContent will be positioned. Default to be the bounding box of host element. \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "renderItem.return_arc.textConfig.offset": {
        "desc": " Offset of the textContent. The difference of offset and position is that offset will be applied in the rotation. "
    },
    "renderItem.return_arc.textConfig.origin": {
        "desc": "origin is relative to the bounding box of the host element. Can be percent value. Relative to the bounding box. If 'center' specified, it will be center of the bounding box. Only available when position and rotation are both set. \n\n* like [12, 33]\n* or like ['50%', '50%']\n* 'center'\n\n"
    },
    "renderItem.return_arc.textConfig.distance": {
        "desc": " Distance to the layoutRectã€‚ "
    },
    "renderItem.return_arc.textConfig.local": {
        "desc": " If true, it will apply host's transform. "
    },
    "renderItem.return_arc.textConfig.insideFill": {
        "desc": "insideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" In most cases, \"auto-calculated-fill\" is white. "
    },
    "renderItem.return_arc.textConfig.insideStroke": {
        "desc": "insideStroke is a color string or left empty. If a textContent is \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be the same as fill of this element if possible, or null.\n\n"
    },
    "renderItem.return_arc.textConfig.outsideFill": {
        "desc": "outsideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "renderItem.return_arc.textConfig.outsideStroke": {
        "desc": "outsideStroke is a color string or left empty. If a textContent is not \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be a near white color to distinguish \"front end\" label with messy background (like other text label, line or other graphic).\n\n"
    },
    "renderItem.return_arc.textConfig.inside": {
        "desc": " Tell echarts that I can make sure this text is inside or not. "
    },
    "renderItem.return_arc.during": {
        "desc": "during callback enable users to set props to an element in each animation frame. \n\n    (duringAPI: CustomDuringAPI) => void\n    \n    interface CustomDuringAPI {\n        // Set transform prop value.\n        // Transform prop see `TransformProp`.\n        setTransform(key: TransformProp, val: unknown): void;\n        // Get transform prop value of the current animation frame.\n        getTransform(key: TransformProp): unknown;\n        // Set shape prop value.\n        // Shape prop is like `{ type: 'rect', shape: { xxxProp: xxxValue } }`.\n        setShape(key: string, val: unknown): void;\n        // Get shape prop value of the current animation frame.\n        getShape(key: string): unknown;\n        // Set style prop value.\n        // Style prop is like `{ type: 'rect', style: { xxxProp: xxxValue } }`.\n        setStyle(key: string, val: unknown): void;\n        // Get style prop value of the current animation frame.\n        getStyle(key: string): unknown;\n        // Set extra prop value.\n        // Extra prop is like `{ type: 'rect', extra: { xxxProp: xxxValue } }`.\n        setExtra(key: string, val: unknown): void;\n        // Get extra prop value of the current animation frame.\n        getExtra(key: string): unknown;\n    }\n    \n    type TransformProp =\n        'x' | 'y' | 'scaleX' | 'scaleY' | 'originX' | 'originY' | 'rotation';\n    \n\nIn most cases users do not need this during callback. For example, if some props are specified in [transition][0], echarts will make interpolation for these props internally and therefore have animation based on these props automatically. But if this kind of internal interpolation does not match the user requirements of animation, users can use this during callback to customize them. For example, if users are using [polygon][1] shape. The shape is described by [shape.points][2], which is an points array like: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: [[12, 33], [15, 36], [19, 39], ...]\n        },\n        // ...\n    }\n    \n\nIf users specify them into [transition][3] like: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: [[12, 33], [15, 36], [19, 39], ...],\n        },\n        transition: 'shape'\n        // ...\n    }\n    \n\nAlthough the points will be interpolated, the consequent animation will be like that each point runs straight to the target position, which might do not match the user requirement if some kind of track like spiral is actually needed. In this case, users can use the during callback like that: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: calculatePoints(initialDegree),\n            transition: 'points'\n        },\n        extra: {\n            degree: nextDegree\n        },\n        // Make echarts interpolate `extra.degree` internally, based on which\n        // we calculate the `points` in each animation frame.\n        transition: 'extra',\n        during: function (duringAPI) {\n            var currentDegree = duringAPI.getExtra('degree');\n            duringAPI.setShape(calculatePoints(currentDegree));\n        }\n        // ...\n    }\n    \n\nSee this example [example][4].\n\n[0]: option.html#series-custom.renderItem.return_rect.transition\n[1]: option.html#series-custom.renderItem.return_polygon\n[2]: option.html#series-custom.renderItem.return_polygon.shape.points\n[3]: option.html#series-custom.renderItem.return_polygon.transition\n[4]: https://echarts.apache.org/examples/en/editor.html?c=custom-spiral-race&edit=1&reset=1"
    },
    "renderItem.return_arc.extra": {
        "desc": " Users can define their own props in this extra field. See [during][0] for the major usage of extra.\n\n[0]: option.html#series-custom.renderItem.return_rect.during"
    },
    "renderItem.return_arc.extra.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this extra. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            extra: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            extra: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `extra` will\n            // have transition animation.\n            transition: 'extra',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_arc.shape": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "renderItem.return_arc.shape.cx": {
        "desc": " The x value of the center of the element in the coordinate system of its parent. "
    },
    "renderItem.return_arc.shape.cy": {
        "desc": " The y value of the center of the element in the coordinate system of its parent. "
    },
    "renderItem.return_arc.shape.r": {
        "desc": " Outside radius. "
    },
    "renderItem.return_arc.shape.r0": {
        "desc": " Inside radius. "
    },
    "renderItem.return_arc.shape.startAngle": {
        "desc": " start angle, in radian. "
    },
    "renderItem.return_arc.shape.endAngle": {
        "desc": " end angle, in radian. "
    },
    "renderItem.return_arc.shape.clockwise": {
        "desc": " Whether draw clockwise. "
    },
    "renderItem.return_arc.shape.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this shape. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            shape: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            shape: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `shape` will\n            // have transition animation.\n            transition: 'shape',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_arc.style": {
        "desc": " More attributes in style (for example, [rich text][0]), see the style related attributes in [zrender/graphic/Displayable][1]. Notice, the attribute names of the style of graphic elements is derived from zrender, which may be different from the attribute names in echarts label, echarts itemStyle, etc., although they have the same meaning. For example: \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#Rich%20Text\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "renderItem.return_arc.style.fill": {
        "desc": " Color filled in this element. "
    },
    "renderItem.return_arc.style.stroke": {
        "desc": " Color of stroke. "
    },
    "renderItem.return_arc.style.lineWidth": {
        "desc": " Width of stroke. "
    },
    "renderItem.return_arc.style.shadowBlur": {
        "desc": " Width of shadow. "
    },
    "renderItem.return_arc.style.shadowOffsetX": {
        "desc": " X offset of shadow. "
    },
    "renderItem.return_arc.style.shadowOffsetY": {
        "desc": " Y offset of shadow. "
    },
    "renderItem.return_arc.style.shadowColor": {
        "desc": " color of shadow. "
    },
    "renderItem.return_arc.style.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this style. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            style: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            style: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `style` will\n            // have transition animation.\n            transition: 'style',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_arc.focus": {
        "desc": ">  Since > v5.0.0 When it's highlighted, whether to fade out of other data to focus the highlighted. The following configurations are supported: \n\n* 'none' Do not fade out other data, it's by default.\n* 'self' Only focus (not fade out) the element of the currently highlighted data.\n* 'series' Focus on all elements of the series which the currently highlighted data belongs to.\n\n"
    },
    "renderItem.return_arc.blurScope": {
        "desc": ">  Since > v5.0.0 The range of fade out when focus is enabled. Support the following configurations \n\n* 'coordinateSystem'\n* 'series'\n* 'global'\n\n"
    },
    "renderItem.return_arc.emphasis": {
        "desc": " Emphasis state of the element. "
    },
    "renderItem.return_arc.emphasis.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_arc.blur": {
        "desc": ">  Since > v5.0.0 Blur state, available when focus is set. "
    },
    "renderItem.return_arc.blur.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_arc.select": {
        "desc": ">  Since > v5.0.0 Select state, available when [selectedMode][0] is set.\n\n[0]: #series-custom.selectedMode"
    },
    "renderItem.return_arc.select.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_polygon": {
        "desc": " Polygon element. "
    },
    "renderItem.return_polygon.type": {
        "desc": " Must be specified when define a graphic element at the first time. Optional values: [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #series-custom.renderItem.return_image\n[1]: #series-custom.renderItem.return_text\n[2]: #series-custom.renderItem.return_circle\n[3]: #series-custom.renderItem.return_sector\n[4]: #series-custom.renderItem.return_ring\n[5]: #series-custom.renderItem.return_polygon\n[6]: #series-custom.renderItem.return_polyline\n[7]: #series-custom.renderItem.return_rect\n[8]: #series-custom.renderItem.return_line\n[9]: #series-custom.renderItem.return_bezierCurve\n[10]: #series-custom.renderItem.return_arc\n[11]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_polygon.id": {
        "desc": " id is used to specifying element when willing to update it. id can be ignored if you do not need it. "
    },
    "renderItem.return_polygon.x": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_polygon.x\n[1]: #series-custom.renderItem.return_polygon.y\n[2]: #series-custom.renderItem.return_polygon.rotation\n[3]: #series-custom.renderItem.return_polygon.scaleX\n[4]: #series-custom.renderItem.return_polygon.scaleY\n[5]: #series-custom.renderItem.return_polygon.originX\n[6]: #series-custom.renderItem.return_polygon.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_polygon.y": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_polygon.x\n[1]: #series-custom.renderItem.return_polygon.y\n[2]: #series-custom.renderItem.return_polygon.rotation\n[3]: #series-custom.renderItem.return_polygon.scaleX\n[4]: #series-custom.renderItem.return_polygon.scaleY\n[5]: #series-custom.renderItem.return_polygon.originX\n[6]: #series-custom.renderItem.return_polygon.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_polygon.rotation": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_polygon.x\n[1]: #series-custom.renderItem.return_polygon.y\n[2]: #series-custom.renderItem.return_polygon.rotation\n[3]: #series-custom.renderItem.return_polygon.scaleX\n[4]: #series-custom.renderItem.return_polygon.scaleY\n[5]: #series-custom.renderItem.return_polygon.originX\n[6]: #series-custom.renderItem.return_polygon.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_polygon.scaleX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_polygon.x\n[1]: #series-custom.renderItem.return_polygon.y\n[2]: #series-custom.renderItem.return_polygon.rotation\n[3]: #series-custom.renderItem.return_polygon.scaleX\n[4]: #series-custom.renderItem.return_polygon.scaleY\n[5]: #series-custom.renderItem.return_polygon.originX\n[6]: #series-custom.renderItem.return_polygon.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_polygon.scaleY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_polygon.x\n[1]: #series-custom.renderItem.return_polygon.y\n[2]: #series-custom.renderItem.return_polygon.rotation\n[3]: #series-custom.renderItem.return_polygon.scaleX\n[4]: #series-custom.renderItem.return_polygon.scaleY\n[5]: #series-custom.renderItem.return_polygon.originX\n[6]: #series-custom.renderItem.return_polygon.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_polygon.originX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_polygon.x\n[1]: #series-custom.renderItem.return_polygon.y\n[2]: #series-custom.renderItem.return_polygon.rotation\n[3]: #series-custom.renderItem.return_polygon.scaleX\n[4]: #series-custom.renderItem.return_polygon.scaleY\n[5]: #series-custom.renderItem.return_polygon.originX\n[6]: #series-custom.renderItem.return_polygon.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_polygon.originY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_polygon.x\n[1]: #series-custom.renderItem.return_polygon.y\n[2]: #series-custom.renderItem.return_polygon.rotation\n[3]: #series-custom.renderItem.return_polygon.scaleX\n[4]: #series-custom.renderItem.return_polygon.scaleY\n[5]: #series-custom.renderItem.return_polygon.originX\n[6]: #series-custom.renderItem.return_polygon.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_polygon.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. The properties can only be: \n\n* Transform related properties: ['x'][0], ['y'][1], ['scaleX'][2], ['scaleY'][3], ['rotation'][4], ['originX'][5], ['originY'][6]. For example:\n\n      renderItem: function (params, api) {\n          var coord = api.coord([api.value(0), api.value[1]);\n          return {\n              type: 'rect',\n              x: coord[0],\n              y: coord[1],\n              shape: {\n                  x: 0,\n                  y: 0,\n                  width: api.value(2),\n                  height: 100\n              },\n              transition: ['x', 'y', 'width']\n          }\n      }\n* Shortcut to transition all of the properties in ['shape'][7], ['style'][8], ['extra'][9]. For example:\n\n      renderItem: function (params, api) {\n          return {\n              type: 'rect',\n              shape: {\n                  x: api.value(0),\n                  y: api.value(1),\n                  width: api.value(2),\n                  height: api.value(3)\n              },\n              // Indicate that all props in `shape` will\n              // have transition animation.\n              transition: 'shape',\n          };\n      }\n    \n\nIt is equivalent to:\n\n      renderItem: function (params, api) {\n          return {\n              type: 'rect',\n              shape: {\n                  x: api.value(0),\n                  y: api.value(1),\n                  width: api.value(2),\n                  height: api.value(3),\n                  // This usage can only enable part of the\n                  // properties transition.\n                  transition: ['x', 'y', 'width', 'height']\n              }\n          };\n      }\n\nBy default, ['x'][0] and ['y'][1] are transitioned. If you want to disable the default transition, just set it as: \n\n    transition: [] // Am empty array.\n    \n\nSee this [example][10] please.\n\n[0]: #series-custom.renderItem.return_polygon.x\n[1]: #series-custom.renderItem.return_polygon.y\n[2]: #series-custom.renderItem.return_polygon.scaleX\n[3]: #series-custom.renderItem.return_polygon.scaleY\n[4]: #series-custom.renderItem.return_polygon.rotation\n[5]: #series-custom.renderItem.return_polygon.originX\n[6]: #series-custom.renderItem.return_polygon.originY\n[7]: #series-custom.renderItem.return_polygon.shape\n[8]: #series-custom.renderItem.return_polygon.style\n[9]: #series-custom.renderItem.return_polygon.extra\n[10]: https://echarts.apache.org/examples/en/editor.html?c=doc-example/custom-transition-simple&edit=1&reset=1"
    },
    "renderItem.return_polygon.morph": {
        "desc": " Whether to enable morphing animation. **When morphing animation happen?** If morph is set as true, the morphing animation will happen according to the following rule: Each time the render process happen, custom series will diff the old data and the new data. If a set of old data items (say, \"old set\") are value-equal to a set of new data items (say, \"new set\") in name or the specified dimensions (see parameter [transition][0] in setOption), we found a pair of sets as transition candidates. Three type of transition animation can be performed between the two sets: \n\n* one-to-one: if both the two sets has only one data item.\n* one-to-many(separate): if the \"old set\" has only one data item, and the \"new set\" has more than one data items.\n* many-to-one(combine): if the \"old set\" has more than one data items, and the \"new set\" has only one data item.\n\nNote: we do not support transition animation for the case many-to-many. Then custom series find graphic elements that has morph: true declared in these two sets, and map them for one to one morphing or combining or separating. See examples: [custom-one-to-one-morph][1] and [custom-combine-separate-morph][2].\n\n[0]: api.html#echartsInstance.setOption\n[1]: https://echarts.apache.org/examples/en/editor.html?c=custom-one-to-one-morph&edit=1&reset=1\n[2]: https://echarts.apache.org/examples/en/editor.html?c=custom-combine-separate-morph&edit=1&reset=1"
    },
    "renderItem.return_polygon.z2": {
        "desc": " Define the overlap relationship between graphic elements. "
    },
    "renderItem.return_polygon.name": {
        "desc": " See [diffChildrenByName][0].\n\n[0]: #series-custom.renderItem.return_polygon.diffChildrenByName"
    },
    "renderItem.return_polygon.info": {
        "desc": " User defined data, can be visited in event listeners. \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "renderItem.return_polygon.silent": {
        "desc": " Whether response to mouse events / touch events. "
    },
    "renderItem.return_polygon.invisible": {
        "desc": " Whether the element is visible. "
    },
    "renderItem.return_polygon.ignore": {
        "desc": " Whether the element is totally ignored (neither render nor listen events). "
    },
    "renderItem.return_polygon.textContent": {
        "desc": " Text block attached to an element and layout based on the element by textConfig. The props the the same as [text][0].\n\n[0]: option.html#series-custom.renderItem.return_text"
    },
    "renderItem.return_polygon.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "renderItem.return_polygon.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "renderItem.return_polygon.textConfig.rotation": {
        "desc": " Rotation of textContent. In radian. "
    },
    "renderItem.return_polygon.textConfig.layoutRect": {
        "desc": " Rect that textContent will be positioned. Default to be the bounding box of host element. \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "renderItem.return_polygon.textConfig.offset": {
        "desc": " Offset of the textContent. The difference of offset and position is that offset will be applied in the rotation. "
    },
    "renderItem.return_polygon.textConfig.origin": {
        "desc": "origin is relative to the bounding box of the host element. Can be percent value. Relative to the bounding box. If 'center' specified, it will be center of the bounding box. Only available when position and rotation are both set. \n\n* like [12, 33]\n* or like ['50%', '50%']\n* 'center'\n\n"
    },
    "renderItem.return_polygon.textConfig.distance": {
        "desc": " Distance to the layoutRectã€‚ "
    },
    "renderItem.return_polygon.textConfig.local": {
        "desc": " If true, it will apply host's transform. "
    },
    "renderItem.return_polygon.textConfig.insideFill": {
        "desc": "insideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" In most cases, \"auto-calculated-fill\" is white. "
    },
    "renderItem.return_polygon.textConfig.insideStroke": {
        "desc": "insideStroke is a color string or left empty. If a textContent is \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be the same as fill of this element if possible, or null.\n\n"
    },
    "renderItem.return_polygon.textConfig.outsideFill": {
        "desc": "outsideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "renderItem.return_polygon.textConfig.outsideStroke": {
        "desc": "outsideStroke is a color string or left empty. If a textContent is not \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be a near white color to distinguish \"front end\" label with messy background (like other text label, line or other graphic).\n\n"
    },
    "renderItem.return_polygon.textConfig.inside": {
        "desc": " Tell echarts that I can make sure this text is inside or not. "
    },
    "renderItem.return_polygon.during": {
        "desc": "during callback enable users to set props to an element in each animation frame. \n\n    (duringAPI: CustomDuringAPI) => void\n    \n    interface CustomDuringAPI {\n        // Set transform prop value.\n        // Transform prop see `TransformProp`.\n        setTransform(key: TransformProp, val: unknown): void;\n        // Get transform prop value of the current animation frame.\n        getTransform(key: TransformProp): unknown;\n        // Set shape prop value.\n        // Shape prop is like `{ type: 'rect', shape: { xxxProp: xxxValue } }`.\n        setShape(key: string, val: unknown): void;\n        // Get shape prop value of the current animation frame.\n        getShape(key: string): unknown;\n        // Set style prop value.\n        // Style prop is like `{ type: 'rect', style: { xxxProp: xxxValue } }`.\n        setStyle(key: string, val: unknown): void;\n        // Get style prop value of the current animation frame.\n        getStyle(key: string): unknown;\n        // Set extra prop value.\n        // Extra prop is like `{ type: 'rect', extra: { xxxProp: xxxValue } }`.\n        setExtra(key: string, val: unknown): void;\n        // Get extra prop value of the current animation frame.\n        getExtra(key: string): unknown;\n    }\n    \n    type TransformProp =\n        'x' | 'y' | 'scaleX' | 'scaleY' | 'originX' | 'originY' | 'rotation';\n    \n\nIn most cases users do not need this during callback. For example, if some props are specified in [transition][0], echarts will make interpolation for these props internally and therefore have animation based on these props automatically. But if this kind of internal interpolation does not match the user requirements of animation, users can use this during callback to customize them. For example, if users are using [polygon][1] shape. The shape is described by [shape.points][2], which is an points array like: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: [[12, 33], [15, 36], [19, 39], ...]\n        },\n        // ...\n    }\n    \n\nIf users specify them into [transition][3] like: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: [[12, 33], [15, 36], [19, 39], ...],\n        },\n        transition: 'shape'\n        // ...\n    }\n    \n\nAlthough the points will be interpolated, the consequent animation will be like that each point runs straight to the target position, which might do not match the user requirement if some kind of track like spiral is actually needed. In this case, users can use the during callback like that: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: calculatePoints(initialDegree),\n            transition: 'points'\n        },\n        extra: {\n            degree: nextDegree\n        },\n        // Make echarts interpolate `extra.degree` internally, based on which\n        // we calculate the `points` in each animation frame.\n        transition: 'extra',\n        during: function (duringAPI) {\n            var currentDegree = duringAPI.getExtra('degree');\n            duringAPI.setShape(calculatePoints(currentDegree));\n        }\n        // ...\n    }\n    \n\nSee this example [example][4].\n\n[0]: option.html#series-custom.renderItem.return_rect.transition\n[1]: option.html#series-custom.renderItem.return_polygon\n[2]: option.html#series-custom.renderItem.return_polygon.shape.points\n[3]: option.html#series-custom.renderItem.return_polygon.transition\n[4]: https://echarts.apache.org/examples/en/editor.html?c=custom-spiral-race&edit=1&reset=1"
    },
    "renderItem.return_polygon.extra": {
        "desc": " Users can define their own props in this extra field. See [during][0] for the major usage of extra.\n\n[0]: option.html#series-custom.renderItem.return_rect.during"
    },
    "renderItem.return_polygon.extra.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this extra. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            extra: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            extra: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `extra` will\n            // have transition animation.\n            transition: 'extra',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_polygon.shape": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "renderItem.return_polygon.shape.points": {
        "desc": " A list of points, which defines the shape, like [[22, 44], [44, 55], [11, 44], ...]. "
    },
    "renderItem.return_polygon.shape.smooth": {
        "desc": " Whether smooth the line. \n\n* If the value is number, bezier interpolation is used, and the value specified the level of smooth, which is in the range of [0, 1].\n* If the value is 'spline', Catmull-Rom spline interpolation is used.\n\n"
    },
    "renderItem.return_polygon.shape.smoothConstraint": {
        "desc": " Whether prevent the smooth process cause the line out of the bounding box. Only works when smooth is number (bezier smooth). "
    },
    "renderItem.return_polygon.shape.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this shape. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            shape: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            shape: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `shape` will\n            // have transition animation.\n            transition: 'shape',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_polygon.style": {
        "desc": " More attributes in style (for example, [rich text][0]), see the style related attributes in [zrender/graphic/Displayable][1]. Notice, the attribute names of the style of graphic elements is derived from zrender, which may be different from the attribute names in echarts label, echarts itemStyle, etc., although they have the same meaning. For example: \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#Rich%20Text\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "renderItem.return_polygon.style.fill": {
        "desc": " Color filled in this element. "
    },
    "renderItem.return_polygon.style.stroke": {
        "desc": " Color of stroke. "
    },
    "renderItem.return_polygon.style.lineWidth": {
        "desc": " Width of stroke. "
    },
    "renderItem.return_polygon.style.shadowBlur": {
        "desc": " Width of shadow. "
    },
    "renderItem.return_polygon.style.shadowOffsetX": {
        "desc": " X offset of shadow. "
    },
    "renderItem.return_polygon.style.shadowOffsetY": {
        "desc": " Y offset of shadow. "
    },
    "renderItem.return_polygon.style.shadowColor": {
        "desc": " color of shadow. "
    },
    "renderItem.return_polygon.style.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this style. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            style: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            style: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `style` will\n            // have transition animation.\n            transition: 'style',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_polygon.focus": {
        "desc": ">  Since > v5.0.0 When it's highlighted, whether to fade out of other data to focus the highlighted. The following configurations are supported: \n\n* 'none' Do not fade out other data, it's by default.\n* 'self' Only focus (not fade out) the element of the currently highlighted data.\n* 'series' Focus on all elements of the series which the currently highlighted data belongs to.\n\n"
    },
    "renderItem.return_polygon.blurScope": {
        "desc": ">  Since > v5.0.0 The range of fade out when focus is enabled. Support the following configurations \n\n* 'coordinateSystem'\n* 'series'\n* 'global'\n\n"
    },
    "renderItem.return_polygon.emphasis": {
        "desc": " Emphasis state of the element. "
    },
    "renderItem.return_polygon.emphasis.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_polygon.blur": {
        "desc": ">  Since > v5.0.0 Blur state, available when focus is set. "
    },
    "renderItem.return_polygon.blur.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_polygon.select": {
        "desc": ">  Since > v5.0.0 Select state, available when [selectedMode][0] is set.\n\n[0]: #series-custom.selectedMode"
    },
    "renderItem.return_polygon.select.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_polyline": {
        "desc": " Polyline element. "
    },
    "renderItem.return_polyline.type": {
        "desc": " Must be specified when define a graphic element at the first time. Optional values: [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #series-custom.renderItem.return_image\n[1]: #series-custom.renderItem.return_text\n[2]: #series-custom.renderItem.return_circle\n[3]: #series-custom.renderItem.return_sector\n[4]: #series-custom.renderItem.return_ring\n[5]: #series-custom.renderItem.return_polygon\n[6]: #series-custom.renderItem.return_polyline\n[7]: #series-custom.renderItem.return_rect\n[8]: #series-custom.renderItem.return_line\n[9]: #series-custom.renderItem.return_bezierCurve\n[10]: #series-custom.renderItem.return_arc\n[11]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_polyline.id": {
        "desc": " id is used to specifying element when willing to update it. id can be ignored if you do not need it. "
    },
    "renderItem.return_polyline.x": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_polyline.x\n[1]: #series-custom.renderItem.return_polyline.y\n[2]: #series-custom.renderItem.return_polyline.rotation\n[3]: #series-custom.renderItem.return_polyline.scaleX\n[4]: #series-custom.renderItem.return_polyline.scaleY\n[5]: #series-custom.renderItem.return_polyline.originX\n[6]: #series-custom.renderItem.return_polyline.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_polyline.y": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_polyline.x\n[1]: #series-custom.renderItem.return_polyline.y\n[2]: #series-custom.renderItem.return_polyline.rotation\n[3]: #series-custom.renderItem.return_polyline.scaleX\n[4]: #series-custom.renderItem.return_polyline.scaleY\n[5]: #series-custom.renderItem.return_polyline.originX\n[6]: #series-custom.renderItem.return_polyline.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_polyline.rotation": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_polyline.x\n[1]: #series-custom.renderItem.return_polyline.y\n[2]: #series-custom.renderItem.return_polyline.rotation\n[3]: #series-custom.renderItem.return_polyline.scaleX\n[4]: #series-custom.renderItem.return_polyline.scaleY\n[5]: #series-custom.renderItem.return_polyline.originX\n[6]: #series-custom.renderItem.return_polyline.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_polyline.scaleX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_polyline.x\n[1]: #series-custom.renderItem.return_polyline.y\n[2]: #series-custom.renderItem.return_polyline.rotation\n[3]: #series-custom.renderItem.return_polyline.scaleX\n[4]: #series-custom.renderItem.return_polyline.scaleY\n[5]: #series-custom.renderItem.return_polyline.originX\n[6]: #series-custom.renderItem.return_polyline.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_polyline.scaleY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_polyline.x\n[1]: #series-custom.renderItem.return_polyline.y\n[2]: #series-custom.renderItem.return_polyline.rotation\n[3]: #series-custom.renderItem.return_polyline.scaleX\n[4]: #series-custom.renderItem.return_polyline.scaleY\n[5]: #series-custom.renderItem.return_polyline.originX\n[6]: #series-custom.renderItem.return_polyline.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_polyline.originX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_polyline.x\n[1]: #series-custom.renderItem.return_polyline.y\n[2]: #series-custom.renderItem.return_polyline.rotation\n[3]: #series-custom.renderItem.return_polyline.scaleX\n[4]: #series-custom.renderItem.return_polyline.scaleY\n[5]: #series-custom.renderItem.return_polyline.originX\n[6]: #series-custom.renderItem.return_polyline.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_polyline.originY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_polyline.x\n[1]: #series-custom.renderItem.return_polyline.y\n[2]: #series-custom.renderItem.return_polyline.rotation\n[3]: #series-custom.renderItem.return_polyline.scaleX\n[4]: #series-custom.renderItem.return_polyline.scaleY\n[5]: #series-custom.renderItem.return_polyline.originX\n[6]: #series-custom.renderItem.return_polyline.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_polyline.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. The properties can only be: \n\n* Transform related properties: ['x'][0], ['y'][1], ['scaleX'][2], ['scaleY'][3], ['rotation'][4], ['originX'][5], ['originY'][6]. For example:\n\n      renderItem: function (params, api) {\n          var coord = api.coord([api.value(0), api.value[1]);\n          return {\n              type: 'rect',\n              x: coord[0],\n              y: coord[1],\n              shape: {\n                  x: 0,\n                  y: 0,\n                  width: api.value(2),\n                  height: 100\n              },\n              transition: ['x', 'y', 'width']\n          }\n      }\n* Shortcut to transition all of the properties in ['shape'][7], ['style'][8], ['extra'][9]. For example:\n\n      renderItem: function (params, api) {\n          return {\n              type: 'rect',\n              shape: {\n                  x: api.value(0),\n                  y: api.value(1),\n                  width: api.value(2),\n                  height: api.value(3)\n              },\n              // Indicate that all props in `shape` will\n              // have transition animation.\n              transition: 'shape',\n          };\n      }\n    \n\nIt is equivalent to:\n\n      renderItem: function (params, api) {\n          return {\n              type: 'rect',\n              shape: {\n                  x: api.value(0),\n                  y: api.value(1),\n                  width: api.value(2),\n                  height: api.value(3),\n                  // This usage can only enable part of the\n                  // properties transition.\n                  transition: ['x', 'y', 'width', 'height']\n              }\n          };\n      }\n\nBy default, ['x'][0] and ['y'][1] are transitioned. If you want to disable the default transition, just set it as: \n\n    transition: [] // Am empty array.\n    \n\nSee this [example][10] please.\n\n[0]: #series-custom.renderItem.return_polyline.x\n[1]: #series-custom.renderItem.return_polyline.y\n[2]: #series-custom.renderItem.return_polyline.scaleX\n[3]: #series-custom.renderItem.return_polyline.scaleY\n[4]: #series-custom.renderItem.return_polyline.rotation\n[5]: #series-custom.renderItem.return_polyline.originX\n[6]: #series-custom.renderItem.return_polyline.originY\n[7]: #series-custom.renderItem.return_polyline.shape\n[8]: #series-custom.renderItem.return_polyline.style\n[9]: #series-custom.renderItem.return_polyline.extra\n[10]: https://echarts.apache.org/examples/en/editor.html?c=doc-example/custom-transition-simple&edit=1&reset=1"
    },
    "renderItem.return_polyline.morph": {
        "desc": " Whether to enable morphing animation. **When morphing animation happen?** If morph is set as true, the morphing animation will happen according to the following rule: Each time the render process happen, custom series will diff the old data and the new data. If a set of old data items (say, \"old set\") are value-equal to a set of new data items (say, \"new set\") in name or the specified dimensions (see parameter [transition][0] in setOption), we found a pair of sets as transition candidates. Three type of transition animation can be performed between the two sets: \n\n* one-to-one: if both the two sets has only one data item.\n* one-to-many(separate): if the \"old set\" has only one data item, and the \"new set\" has more than one data items.\n* many-to-one(combine): if the \"old set\" has more than one data items, and the \"new set\" has only one data item.\n\nNote: we do not support transition animation for the case many-to-many. Then custom series find graphic elements that has morph: true declared in these two sets, and map them for one to one morphing or combining or separating. See examples: [custom-one-to-one-morph][1] and [custom-combine-separate-morph][2].\n\n[0]: api.html#echartsInstance.setOption\n[1]: https://echarts.apache.org/examples/en/editor.html?c=custom-one-to-one-morph&edit=1&reset=1\n[2]: https://echarts.apache.org/examples/en/editor.html?c=custom-combine-separate-morph&edit=1&reset=1"
    },
    "renderItem.return_polyline.z2": {
        "desc": " Define the overlap relationship between graphic elements. "
    },
    "renderItem.return_polyline.name": {
        "desc": " See [diffChildrenByName][0].\n\n[0]: #series-custom.renderItem.return_polyline.diffChildrenByName"
    },
    "renderItem.return_polyline.info": {
        "desc": " User defined data, can be visited in event listeners. \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "renderItem.return_polyline.silent": {
        "desc": " Whether response to mouse events / touch events. "
    },
    "renderItem.return_polyline.invisible": {
        "desc": " Whether the element is visible. "
    },
    "renderItem.return_polyline.ignore": {
        "desc": " Whether the element is totally ignored (neither render nor listen events). "
    },
    "renderItem.return_polyline.textContent": {
        "desc": " Text block attached to an element and layout based on the element by textConfig. The props the the same as [text][0].\n\n[0]: option.html#series-custom.renderItem.return_text"
    },
    "renderItem.return_polyline.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "renderItem.return_polyline.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "renderItem.return_polyline.textConfig.rotation": {
        "desc": " Rotation of textContent. In radian. "
    },
    "renderItem.return_polyline.textConfig.layoutRect": {
        "desc": " Rect that textContent will be positioned. Default to be the bounding box of host element. \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "renderItem.return_polyline.textConfig.offset": {
        "desc": " Offset of the textContent. The difference of offset and position is that offset will be applied in the rotation. "
    },
    "renderItem.return_polyline.textConfig.origin": {
        "desc": "origin is relative to the bounding box of the host element. Can be percent value. Relative to the bounding box. If 'center' specified, it will be center of the bounding box. Only available when position and rotation are both set. \n\n* like [12, 33]\n* or like ['50%', '50%']\n* 'center'\n\n"
    },
    "renderItem.return_polyline.textConfig.distance": {
        "desc": " Distance to the layoutRectã€‚ "
    },
    "renderItem.return_polyline.textConfig.local": {
        "desc": " If true, it will apply host's transform. "
    },
    "renderItem.return_polyline.textConfig.insideFill": {
        "desc": "insideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" In most cases, \"auto-calculated-fill\" is white. "
    },
    "renderItem.return_polyline.textConfig.insideStroke": {
        "desc": "insideStroke is a color string or left empty. If a textContent is \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be the same as fill of this element if possible, or null.\n\n"
    },
    "renderItem.return_polyline.textConfig.outsideFill": {
        "desc": "outsideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "renderItem.return_polyline.textConfig.outsideStroke": {
        "desc": "outsideStroke is a color string or left empty. If a textContent is not \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be a near white color to distinguish \"front end\" label with messy background (like other text label, line or other graphic).\n\n"
    },
    "renderItem.return_polyline.textConfig.inside": {
        "desc": " Tell echarts that I can make sure this text is inside or not. "
    },
    "renderItem.return_polyline.during": {
        "desc": "during callback enable users to set props to an element in each animation frame. \n\n    (duringAPI: CustomDuringAPI) => void\n    \n    interface CustomDuringAPI {\n        // Set transform prop value.\n        // Transform prop see `TransformProp`.\n        setTransform(key: TransformProp, val: unknown): void;\n        // Get transform prop value of the current animation frame.\n        getTransform(key: TransformProp): unknown;\n        // Set shape prop value.\n        // Shape prop is like `{ type: 'rect', shape: { xxxProp: xxxValue } }`.\n        setShape(key: string, val: unknown): void;\n        // Get shape prop value of the current animation frame.\n        getShape(key: string): unknown;\n        // Set style prop value.\n        // Style prop is like `{ type: 'rect', style: { xxxProp: xxxValue } }`.\n        setStyle(key: string, val: unknown): void;\n        // Get style prop value of the current animation frame.\n        getStyle(key: string): unknown;\n        // Set extra prop value.\n        // Extra prop is like `{ type: 'rect', extra: { xxxProp: xxxValue } }`.\n        setExtra(key: string, val: unknown): void;\n        // Get extra prop value of the current animation frame.\n        getExtra(key: string): unknown;\n    }\n    \n    type TransformProp =\n        'x' | 'y' | 'scaleX' | 'scaleY' | 'originX' | 'originY' | 'rotation';\n    \n\nIn most cases users do not need this during callback. For example, if some props are specified in [transition][0], echarts will make interpolation for these props internally and therefore have animation based on these props automatically. But if this kind of internal interpolation does not match the user requirements of animation, users can use this during callback to customize them. For example, if users are using [polygon][1] shape. The shape is described by [shape.points][2], which is an points array like: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: [[12, 33], [15, 36], [19, 39], ...]\n        },\n        // ...\n    }\n    \n\nIf users specify them into [transition][3] like: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: [[12, 33], [15, 36], [19, 39], ...],\n        },\n        transition: 'shape'\n        // ...\n    }\n    \n\nAlthough the points will be interpolated, the consequent animation will be like that each point runs straight to the target position, which might do not match the user requirement if some kind of track like spiral is actually needed. In this case, users can use the during callback like that: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: calculatePoints(initialDegree),\n            transition: 'points'\n        },\n        extra: {\n            degree: nextDegree\n        },\n        // Make echarts interpolate `extra.degree` internally, based on which\n        // we calculate the `points` in each animation frame.\n        transition: 'extra',\n        during: function (duringAPI) {\n            var currentDegree = duringAPI.getExtra('degree');\n            duringAPI.setShape(calculatePoints(currentDegree));\n        }\n        // ...\n    }\n    \n\nSee this example [example][4].\n\n[0]: option.html#series-custom.renderItem.return_rect.transition\n[1]: option.html#series-custom.renderItem.return_polygon\n[2]: option.html#series-custom.renderItem.return_polygon.shape.points\n[3]: option.html#series-custom.renderItem.return_polygon.transition\n[4]: https://echarts.apache.org/examples/en/editor.html?c=custom-spiral-race&edit=1&reset=1"
    },
    "renderItem.return_polyline.extra": {
        "desc": " Users can define their own props in this extra field. See [during][0] for the major usage of extra.\n\n[0]: option.html#series-custom.renderItem.return_rect.during"
    },
    "renderItem.return_polyline.extra.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this extra. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            extra: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            extra: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `extra` will\n            // have transition animation.\n            transition: 'extra',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_polyline.shape": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "renderItem.return_polyline.shape.points": {
        "desc": " A list of points, which defines the shape, like [[22, 44], [44, 55], [11, 44], ...]. "
    },
    "renderItem.return_polyline.shape.smooth": {
        "desc": " Whether smooth the line. \n\n* If the value is number, bezier interpolation is used, and the value specified the level of smooth, which is in the range of [0, 1].\n* If the value is 'spline', Catmull-Rom spline interpolation is used.\n\n"
    },
    "renderItem.return_polyline.shape.smoothConstraint": {
        "desc": " Whether prevent the smooth process cause the line out of the bounding box. Only works when smooth is number (bezier smooth). "
    },
    "renderItem.return_polyline.shape.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this shape. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            shape: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            shape: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `shape` will\n            // have transition animation.\n            transition: 'shape',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_polyline.style": {
        "desc": " More attributes in style (for example, [rich text][0]), see the style related attributes in [zrender/graphic/Displayable][1]. Notice, the attribute names of the style of graphic elements is derived from zrender, which may be different from the attribute names in echarts label, echarts itemStyle, etc., although they have the same meaning. For example: \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#Rich%20Text\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "renderItem.return_polyline.style.fill": {
        "desc": " Color filled in this element. "
    },
    "renderItem.return_polyline.style.stroke": {
        "desc": " Color of stroke. "
    },
    "renderItem.return_polyline.style.lineWidth": {
        "desc": " Width of stroke. "
    },
    "renderItem.return_polyline.style.shadowBlur": {
        "desc": " Width of shadow. "
    },
    "renderItem.return_polyline.style.shadowOffsetX": {
        "desc": " X offset of shadow. "
    },
    "renderItem.return_polyline.style.shadowOffsetY": {
        "desc": " Y offset of shadow. "
    },
    "renderItem.return_polyline.style.shadowColor": {
        "desc": " color of shadow. "
    },
    "renderItem.return_polyline.style.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this style. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            style: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            style: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `style` will\n            // have transition animation.\n            transition: 'style',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_polyline.focus": {
        "desc": ">  Since > v5.0.0 When it's highlighted, whether to fade out of other data to focus the highlighted. The following configurations are supported: \n\n* 'none' Do not fade out other data, it's by default.\n* 'self' Only focus (not fade out) the element of the currently highlighted data.\n* 'series' Focus on all elements of the series which the currently highlighted data belongs to.\n\n"
    },
    "renderItem.return_polyline.blurScope": {
        "desc": ">  Since > v5.0.0 The range of fade out when focus is enabled. Support the following configurations \n\n* 'coordinateSystem'\n* 'series'\n* 'global'\n\n"
    },
    "renderItem.return_polyline.emphasis": {
        "desc": " Emphasis state of the element. "
    },
    "renderItem.return_polyline.emphasis.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_polyline.blur": {
        "desc": ">  Since > v5.0.0 Blur state, available when focus is set. "
    },
    "renderItem.return_polyline.blur.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_polyline.select": {
        "desc": ">  Since > v5.0.0 Select state, available when [selectedMode][0] is set.\n\n[0]: #series-custom.selectedMode"
    },
    "renderItem.return_polyline.select.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_line": {
        "desc": " Line element. "
    },
    "renderItem.return_line.type": {
        "desc": " Must be specified when define a graphic element at the first time. Optional values: [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #series-custom.renderItem.return_image\n[1]: #series-custom.renderItem.return_text\n[2]: #series-custom.renderItem.return_circle\n[3]: #series-custom.renderItem.return_sector\n[4]: #series-custom.renderItem.return_ring\n[5]: #series-custom.renderItem.return_polygon\n[6]: #series-custom.renderItem.return_polyline\n[7]: #series-custom.renderItem.return_rect\n[8]: #series-custom.renderItem.return_line\n[9]: #series-custom.renderItem.return_bezierCurve\n[10]: #series-custom.renderItem.return_arc\n[11]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_line.id": {
        "desc": " id is used to specifying element when willing to update it. id can be ignored if you do not need it. "
    },
    "renderItem.return_line.x": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_line.x\n[1]: #series-custom.renderItem.return_line.y\n[2]: #series-custom.renderItem.return_line.rotation\n[3]: #series-custom.renderItem.return_line.scaleX\n[4]: #series-custom.renderItem.return_line.scaleY\n[5]: #series-custom.renderItem.return_line.originX\n[6]: #series-custom.renderItem.return_line.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_line.y": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_line.x\n[1]: #series-custom.renderItem.return_line.y\n[2]: #series-custom.renderItem.return_line.rotation\n[3]: #series-custom.renderItem.return_line.scaleX\n[4]: #series-custom.renderItem.return_line.scaleY\n[5]: #series-custom.renderItem.return_line.originX\n[6]: #series-custom.renderItem.return_line.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_line.rotation": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_line.x\n[1]: #series-custom.renderItem.return_line.y\n[2]: #series-custom.renderItem.return_line.rotation\n[3]: #series-custom.renderItem.return_line.scaleX\n[4]: #series-custom.renderItem.return_line.scaleY\n[5]: #series-custom.renderItem.return_line.originX\n[6]: #series-custom.renderItem.return_line.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_line.scaleX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_line.x\n[1]: #series-custom.renderItem.return_line.y\n[2]: #series-custom.renderItem.return_line.rotation\n[3]: #series-custom.renderItem.return_line.scaleX\n[4]: #series-custom.renderItem.return_line.scaleY\n[5]: #series-custom.renderItem.return_line.originX\n[6]: #series-custom.renderItem.return_line.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_line.scaleY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_line.x\n[1]: #series-custom.renderItem.return_line.y\n[2]: #series-custom.renderItem.return_line.rotation\n[3]: #series-custom.renderItem.return_line.scaleX\n[4]: #series-custom.renderItem.return_line.scaleY\n[5]: #series-custom.renderItem.return_line.originX\n[6]: #series-custom.renderItem.return_line.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_line.originX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_line.x\n[1]: #series-custom.renderItem.return_line.y\n[2]: #series-custom.renderItem.return_line.rotation\n[3]: #series-custom.renderItem.return_line.scaleX\n[4]: #series-custom.renderItem.return_line.scaleY\n[5]: #series-custom.renderItem.return_line.originX\n[6]: #series-custom.renderItem.return_line.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_line.originY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_line.x\n[1]: #series-custom.renderItem.return_line.y\n[2]: #series-custom.renderItem.return_line.rotation\n[3]: #series-custom.renderItem.return_line.scaleX\n[4]: #series-custom.renderItem.return_line.scaleY\n[5]: #series-custom.renderItem.return_line.originX\n[6]: #series-custom.renderItem.return_line.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_line.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. The properties can only be: \n\n* Transform related properties: ['x'][0], ['y'][1], ['scaleX'][2], ['scaleY'][3], ['rotation'][4], ['originX'][5], ['originY'][6]. For example:\n\n      renderItem: function (params, api) {\n          var coord = api.coord([api.value(0), api.value[1]);\n          return {\n              type: 'rect',\n              x: coord[0],\n              y: coord[1],\n              shape: {\n                  x: 0,\n                  y: 0,\n                  width: api.value(2),\n                  height: 100\n              },\n              transition: ['x', 'y', 'width']\n          }\n      }\n* Shortcut to transition all of the properties in ['shape'][7], ['style'][8], ['extra'][9]. For example:\n\n      renderItem: function (params, api) {\n          return {\n              type: 'rect',\n              shape: {\n                  x: api.value(0),\n                  y: api.value(1),\n                  width: api.value(2),\n                  height: api.value(3)\n              },\n              // Indicate that all props in `shape` will\n              // have transition animation.\n              transition: 'shape',\n          };\n      }\n    \n\nIt is equivalent to:\n\n      renderItem: function (params, api) {\n          return {\n              type: 'rect',\n              shape: {\n                  x: api.value(0),\n                  y: api.value(1),\n                  width: api.value(2),\n                  height: api.value(3),\n                  // This usage can only enable part of the\n                  // properties transition.\n                  transition: ['x', 'y', 'width', 'height']\n              }\n          };\n      }\n\nBy default, ['x'][0] and ['y'][1] are transitioned. If you want to disable the default transition, just set it as: \n\n    transition: [] // Am empty array.\n    \n\nSee this [example][10] please.\n\n[0]: #series-custom.renderItem.return_line.x\n[1]: #series-custom.renderItem.return_line.y\n[2]: #series-custom.renderItem.return_line.scaleX\n[3]: #series-custom.renderItem.return_line.scaleY\n[4]: #series-custom.renderItem.return_line.rotation\n[5]: #series-custom.renderItem.return_line.originX\n[6]: #series-custom.renderItem.return_line.originY\n[7]: #series-custom.renderItem.return_line.shape\n[8]: #series-custom.renderItem.return_line.style\n[9]: #series-custom.renderItem.return_line.extra\n[10]: https://echarts.apache.org/examples/en/editor.html?c=doc-example/custom-transition-simple&edit=1&reset=1"
    },
    "renderItem.return_line.morph": {
        "desc": " Whether to enable morphing animation. **When morphing animation happen?** If morph is set as true, the morphing animation will happen according to the following rule: Each time the render process happen, custom series will diff the old data and the new data. If a set of old data items (say, \"old set\") are value-equal to a set of new data items (say, \"new set\") in name or the specified dimensions (see parameter [transition][0] in setOption), we found a pair of sets as transition candidates. Three type of transition animation can be performed between the two sets: \n\n* one-to-one: if both the two sets has only one data item.\n* one-to-many(separate): if the \"old set\" has only one data item, and the \"new set\" has more than one data items.\n* many-to-one(combine): if the \"old set\" has more than one data items, and the \"new set\" has only one data item.\n\nNote: we do not support transition animation for the case many-to-many. Then custom series find graphic elements that has morph: true declared in these two sets, and map them for one to one morphing or combining or separating. See examples: [custom-one-to-one-morph][1] and [custom-combine-separate-morph][2].\n\n[0]: api.html#echartsInstance.setOption\n[1]: https://echarts.apache.org/examples/en/editor.html?c=custom-one-to-one-morph&edit=1&reset=1\n[2]: https://echarts.apache.org/examples/en/editor.html?c=custom-combine-separate-morph&edit=1&reset=1"
    },
    "renderItem.return_line.z2": {
        "desc": " Define the overlap relationship between graphic elements. "
    },
    "renderItem.return_line.name": {
        "desc": " See [diffChildrenByName][0].\n\n[0]: #series-custom.renderItem.return_line.diffChildrenByName"
    },
    "renderItem.return_line.info": {
        "desc": " User defined data, can be visited in event listeners. \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "renderItem.return_line.silent": {
        "desc": " Whether response to mouse events / touch events. "
    },
    "renderItem.return_line.invisible": {
        "desc": " Whether the element is visible. "
    },
    "renderItem.return_line.ignore": {
        "desc": " Whether the element is totally ignored (neither render nor listen events). "
    },
    "renderItem.return_line.textContent": {
        "desc": " Text block attached to an element and layout based on the element by textConfig. The props the the same as [text][0].\n\n[0]: option.html#series-custom.renderItem.return_text"
    },
    "renderItem.return_line.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "renderItem.return_line.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "renderItem.return_line.textConfig.rotation": {
        "desc": " Rotation of textContent. In radian. "
    },
    "renderItem.return_line.textConfig.layoutRect": {
        "desc": " Rect that textContent will be positioned. Default to be the bounding box of host element. \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "renderItem.return_line.textConfig.offset": {
        "desc": " Offset of the textContent. The difference of offset and position is that offset will be applied in the rotation. "
    },
    "renderItem.return_line.textConfig.origin": {
        "desc": "origin is relative to the bounding box of the host element. Can be percent value. Relative to the bounding box. If 'center' specified, it will be center of the bounding box. Only available when position and rotation are both set. \n\n* like [12, 33]\n* or like ['50%', '50%']\n* 'center'\n\n"
    },
    "renderItem.return_line.textConfig.distance": {
        "desc": " Distance to the layoutRectã€‚ "
    },
    "renderItem.return_line.textConfig.local": {
        "desc": " If true, it will apply host's transform. "
    },
    "renderItem.return_line.textConfig.insideFill": {
        "desc": "insideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" In most cases, \"auto-calculated-fill\" is white. "
    },
    "renderItem.return_line.textConfig.insideStroke": {
        "desc": "insideStroke is a color string or left empty. If a textContent is \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be the same as fill of this element if possible, or null.\n\n"
    },
    "renderItem.return_line.textConfig.outsideFill": {
        "desc": "outsideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "renderItem.return_line.textConfig.outsideStroke": {
        "desc": "outsideStroke is a color string or left empty. If a textContent is not \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be a near white color to distinguish \"front end\" label with messy background (like other text label, line or other graphic).\n\n"
    },
    "renderItem.return_line.textConfig.inside": {
        "desc": " Tell echarts that I can make sure this text is inside or not. "
    },
    "renderItem.return_line.during": {
        "desc": "during callback enable users to set props to an element in each animation frame. \n\n    (duringAPI: CustomDuringAPI) => void\n    \n    interface CustomDuringAPI {\n        // Set transform prop value.\n        // Transform prop see `TransformProp`.\n        setTransform(key: TransformProp, val: unknown): void;\n        // Get transform prop value of the current animation frame.\n        getTransform(key: TransformProp): unknown;\n        // Set shape prop value.\n        // Shape prop is like `{ type: 'rect', shape: { xxxProp: xxxValue } }`.\n        setShape(key: string, val: unknown): void;\n        // Get shape prop value of the current animation frame.\n        getShape(key: string): unknown;\n        // Set style prop value.\n        // Style prop is like `{ type: 'rect', style: { xxxProp: xxxValue } }`.\n        setStyle(key: string, val: unknown): void;\n        // Get style prop value of the current animation frame.\n        getStyle(key: string): unknown;\n        // Set extra prop value.\n        // Extra prop is like `{ type: 'rect', extra: { xxxProp: xxxValue } }`.\n        setExtra(key: string, val: unknown): void;\n        // Get extra prop value of the current animation frame.\n        getExtra(key: string): unknown;\n    }\n    \n    type TransformProp =\n        'x' | 'y' | 'scaleX' | 'scaleY' | 'originX' | 'originY' | 'rotation';\n    \n\nIn most cases users do not need this during callback. For example, if some props are specified in [transition][0], echarts will make interpolation for these props internally and therefore have animation based on these props automatically. But if this kind of internal interpolation does not match the user requirements of animation, users can use this during callback to customize them. For example, if users are using [polygon][1] shape. The shape is described by [shape.points][2], which is an points array like: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: [[12, 33], [15, 36], [19, 39], ...]\n        },\n        // ...\n    }\n    \n\nIf users specify them into [transition][3] like: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: [[12, 33], [15, 36], [19, 39], ...],\n        },\n        transition: 'shape'\n        // ...\n    }\n    \n\nAlthough the points will be interpolated, the consequent animation will be like that each point runs straight to the target position, which might do not match the user requirement if some kind of track like spiral is actually needed. In this case, users can use the during callback like that: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: calculatePoints(initialDegree),\n            transition: 'points'\n        },\n        extra: {\n            degree: nextDegree\n        },\n        // Make echarts interpolate `extra.degree` internally, based on which\n        // we calculate the `points` in each animation frame.\n        transition: 'extra',\n        during: function (duringAPI) {\n            var currentDegree = duringAPI.getExtra('degree');\n            duringAPI.setShape(calculatePoints(currentDegree));\n        }\n        // ...\n    }\n    \n\nSee this example [example][4].\n\n[0]: option.html#series-custom.renderItem.return_rect.transition\n[1]: option.html#series-custom.renderItem.return_polygon\n[2]: option.html#series-custom.renderItem.return_polygon.shape.points\n[3]: option.html#series-custom.renderItem.return_polygon.transition\n[4]: https://echarts.apache.org/examples/en/editor.html?c=custom-spiral-race&edit=1&reset=1"
    },
    "renderItem.return_line.extra": {
        "desc": " Users can define their own props in this extra field. See [during][0] for the major usage of extra.\n\n[0]: option.html#series-custom.renderItem.return_rect.during"
    },
    "renderItem.return_line.extra.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this extra. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            extra: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            extra: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `extra` will\n            // have transition animation.\n            transition: 'extra',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_line.shape": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "renderItem.return_line.shape.x1": {
        "desc": " x value of the start point. "
    },
    "renderItem.return_line.shape.y1": {
        "desc": " y value of the start point. "
    },
    "renderItem.return_line.shape.x2": {
        "desc": " x value of the end point. "
    },
    "renderItem.return_line.shape.y2": {
        "desc": " y value of the end point. "
    },
    "renderItem.return_line.shape.percent": {
        "desc": " Specify the percentage of drawing, useful in animation. Value range: [0, 1]. "
    },
    "renderItem.return_line.shape.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this shape. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            shape: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            shape: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `shape` will\n            // have transition animation.\n            transition: 'shape',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_line.style": {
        "desc": " More attributes in style (for example, [rich text][0]), see the style related attributes in [zrender/graphic/Displayable][1]. Notice, the attribute names of the style of graphic elements is derived from zrender, which may be different from the attribute names in echarts label, echarts itemStyle, etc., although they have the same meaning. For example: \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#Rich%20Text\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "renderItem.return_line.style.fill": {
        "desc": " Color filled in this element. "
    },
    "renderItem.return_line.style.stroke": {
        "desc": " Color of stroke. "
    },
    "renderItem.return_line.style.lineWidth": {
        "desc": " Width of stroke. "
    },
    "renderItem.return_line.style.shadowBlur": {
        "desc": " Width of shadow. "
    },
    "renderItem.return_line.style.shadowOffsetX": {
        "desc": " X offset of shadow. "
    },
    "renderItem.return_line.style.shadowOffsetY": {
        "desc": " Y offset of shadow. "
    },
    "renderItem.return_line.style.shadowColor": {
        "desc": " color of shadow. "
    },
    "renderItem.return_line.style.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this style. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            style: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            style: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `style` will\n            // have transition animation.\n            transition: 'style',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_line.focus": {
        "desc": ">  Since > v5.0.0 When it's highlighted, whether to fade out of other data to focus the highlighted. The following configurations are supported: \n\n* 'none' Do not fade out other data, it's by default.\n* 'self' Only focus (not fade out) the element of the currently highlighted data.\n* 'series' Focus on all elements of the series which the currently highlighted data belongs to.\n\n"
    },
    "renderItem.return_line.blurScope": {
        "desc": ">  Since > v5.0.0 The range of fade out when focus is enabled. Support the following configurations \n\n* 'coordinateSystem'\n* 'series'\n* 'global'\n\n"
    },
    "renderItem.return_line.emphasis": {
        "desc": " Emphasis state of the element. "
    },
    "renderItem.return_line.emphasis.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_line.blur": {
        "desc": ">  Since > v5.0.0 Blur state, available when focus is set. "
    },
    "renderItem.return_line.blur.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_line.select": {
        "desc": ">  Since > v5.0.0 Select state, available when [selectedMode][0] is set.\n\n[0]: #series-custom.selectedMode"
    },
    "renderItem.return_line.select.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_bezierCurve": {
        "desc": " Quadratic bezier curve or cubic bezier curve. "
    },
    "renderItem.return_bezierCurve.type": {
        "desc": " Must be specified when define a graphic element at the first time. Optional values: [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #series-custom.renderItem.return_image\n[1]: #series-custom.renderItem.return_text\n[2]: #series-custom.renderItem.return_circle\n[3]: #series-custom.renderItem.return_sector\n[4]: #series-custom.renderItem.return_ring\n[5]: #series-custom.renderItem.return_polygon\n[6]: #series-custom.renderItem.return_polyline\n[7]: #series-custom.renderItem.return_rect\n[8]: #series-custom.renderItem.return_line\n[9]: #series-custom.renderItem.return_bezierCurve\n[10]: #series-custom.renderItem.return_arc\n[11]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_bezierCurve.id": {
        "desc": " id is used to specifying element when willing to update it. id can be ignored if you do not need it. "
    },
    "renderItem.return_bezierCurve.x": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_bezierCurve.x\n[1]: #series-custom.renderItem.return_bezierCurve.y\n[2]: #series-custom.renderItem.return_bezierCurve.rotation\n[3]: #series-custom.renderItem.return_bezierCurve.scaleX\n[4]: #series-custom.renderItem.return_bezierCurve.scaleY\n[5]: #series-custom.renderItem.return_bezierCurve.originX\n[6]: #series-custom.renderItem.return_bezierCurve.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_bezierCurve.y": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_bezierCurve.x\n[1]: #series-custom.renderItem.return_bezierCurve.y\n[2]: #series-custom.renderItem.return_bezierCurve.rotation\n[3]: #series-custom.renderItem.return_bezierCurve.scaleX\n[4]: #series-custom.renderItem.return_bezierCurve.scaleY\n[5]: #series-custom.renderItem.return_bezierCurve.originX\n[6]: #series-custom.renderItem.return_bezierCurve.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_bezierCurve.rotation": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_bezierCurve.x\n[1]: #series-custom.renderItem.return_bezierCurve.y\n[2]: #series-custom.renderItem.return_bezierCurve.rotation\n[3]: #series-custom.renderItem.return_bezierCurve.scaleX\n[4]: #series-custom.renderItem.return_bezierCurve.scaleY\n[5]: #series-custom.renderItem.return_bezierCurve.originX\n[6]: #series-custom.renderItem.return_bezierCurve.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_bezierCurve.scaleX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_bezierCurve.x\n[1]: #series-custom.renderItem.return_bezierCurve.y\n[2]: #series-custom.renderItem.return_bezierCurve.rotation\n[3]: #series-custom.renderItem.return_bezierCurve.scaleX\n[4]: #series-custom.renderItem.return_bezierCurve.scaleY\n[5]: #series-custom.renderItem.return_bezierCurve.originX\n[6]: #series-custom.renderItem.return_bezierCurve.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_bezierCurve.scaleY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_bezierCurve.x\n[1]: #series-custom.renderItem.return_bezierCurve.y\n[2]: #series-custom.renderItem.return_bezierCurve.rotation\n[3]: #series-custom.renderItem.return_bezierCurve.scaleX\n[4]: #series-custom.renderItem.return_bezierCurve.scaleY\n[5]: #series-custom.renderItem.return_bezierCurve.originX\n[6]: #series-custom.renderItem.return_bezierCurve.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_bezierCurve.originX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_bezierCurve.x\n[1]: #series-custom.renderItem.return_bezierCurve.y\n[2]: #series-custom.renderItem.return_bezierCurve.rotation\n[3]: #series-custom.renderItem.return_bezierCurve.scaleX\n[4]: #series-custom.renderItem.return_bezierCurve.scaleY\n[5]: #series-custom.renderItem.return_bezierCurve.originX\n[6]: #series-custom.renderItem.return_bezierCurve.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_bezierCurve.originY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #series-custom.renderItem.return_bezierCurve.x\n[1]: #series-custom.renderItem.return_bezierCurve.y\n[2]: #series-custom.renderItem.return_bezierCurve.rotation\n[3]: #series-custom.renderItem.return_bezierCurve.scaleX\n[4]: #series-custom.renderItem.return_bezierCurve.scaleY\n[5]: #series-custom.renderItem.return_bezierCurve.originX\n[6]: #series-custom.renderItem.return_bezierCurve.originY\n[7]: #series-custom.renderItem.return_group"
    },
    "renderItem.return_bezierCurve.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. The properties can only be: \n\n* Transform related properties: ['x'][0], ['y'][1], ['scaleX'][2], ['scaleY'][3], ['rotation'][4], ['originX'][5], ['originY'][6]. For example:\n\n      renderItem: function (params, api) {\n          var coord = api.coord([api.value(0), api.value[1]);\n          return {\n              type: 'rect',\n              x: coord[0],\n              y: coord[1],\n              shape: {\n                  x: 0,\n                  y: 0,\n                  width: api.value(2),\n                  height: 100\n              },\n              transition: ['x', 'y', 'width']\n          }\n      }\n* Shortcut to transition all of the properties in ['shape'][7], ['style'][8], ['extra'][9]. For example:\n\n      renderItem: function (params, api) {\n          return {\n              type: 'rect',\n              shape: {\n                  x: api.value(0),\n                  y: api.value(1),\n                  width: api.value(2),\n                  height: api.value(3)\n              },\n              // Indicate that all props in `shape` will\n              // have transition animation.\n              transition: 'shape',\n          };\n      }\n    \n\nIt is equivalent to:\n\n      renderItem: function (params, api) {\n          return {\n              type: 'rect',\n              shape: {\n                  x: api.value(0),\n                  y: api.value(1),\n                  width: api.value(2),\n                  height: api.value(3),\n                  // This usage can only enable part of the\n                  // properties transition.\n                  transition: ['x', 'y', 'width', 'height']\n              }\n          };\n      }\n\nBy default, ['x'][0] and ['y'][1] are transitioned. If you want to disable the default transition, just set it as: \n\n    transition: [] // Am empty array.\n    \n\nSee this [example][10] please.\n\n[0]: #series-custom.renderItem.return_bezierCurve.x\n[1]: #series-custom.renderItem.return_bezierCurve.y\n[2]: #series-custom.renderItem.return_bezierCurve.scaleX\n[3]: #series-custom.renderItem.return_bezierCurve.scaleY\n[4]: #series-custom.renderItem.return_bezierCurve.rotation\n[5]: #series-custom.renderItem.return_bezierCurve.originX\n[6]: #series-custom.renderItem.return_bezierCurve.originY\n[7]: #series-custom.renderItem.return_bezierCurve.shape\n[8]: #series-custom.renderItem.return_bezierCurve.style\n[9]: #series-custom.renderItem.return_bezierCurve.extra\n[10]: https://echarts.apache.org/examples/en/editor.html?c=doc-example/custom-transition-simple&edit=1&reset=1"
    },
    "renderItem.return_bezierCurve.morph": {
        "desc": " Whether to enable morphing animation. **When morphing animation happen?** If morph is set as true, the morphing animation will happen according to the following rule: Each time the render process happen, custom series will diff the old data and the new data. If a set of old data items (say, \"old set\") are value-equal to a set of new data items (say, \"new set\") in name or the specified dimensions (see parameter [transition][0] in setOption), we found a pair of sets as transition candidates. Three type of transition animation can be performed between the two sets: \n\n* one-to-one: if both the two sets has only one data item.\n* one-to-many(separate): if the \"old set\" has only one data item, and the \"new set\" has more than one data items.\n* many-to-one(combine): if the \"old set\" has more than one data items, and the \"new set\" has only one data item.\n\nNote: we do not support transition animation for the case many-to-many. Then custom series find graphic elements that has morph: true declared in these two sets, and map them for one to one morphing or combining or separating. See examples: [custom-one-to-one-morph][1] and [custom-combine-separate-morph][2].\n\n[0]: api.html#echartsInstance.setOption\n[1]: https://echarts.apache.org/examples/en/editor.html?c=custom-one-to-one-morph&edit=1&reset=1\n[2]: https://echarts.apache.org/examples/en/editor.html?c=custom-combine-separate-morph&edit=1&reset=1"
    },
    "renderItem.return_bezierCurve.z2": {
        "desc": " Define the overlap relationship between graphic elements. "
    },
    "renderItem.return_bezierCurve.name": {
        "desc": " See [diffChildrenByName][0].\n\n[0]: #series-custom.renderItem.return_bezierCurve.diffChildrenByName"
    },
    "renderItem.return_bezierCurve.info": {
        "desc": " User defined data, can be visited in event listeners. \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "renderItem.return_bezierCurve.silent": {
        "desc": " Whether response to mouse events / touch events. "
    },
    "renderItem.return_bezierCurve.invisible": {
        "desc": " Whether the element is visible. "
    },
    "renderItem.return_bezierCurve.ignore": {
        "desc": " Whether the element is totally ignored (neither render nor listen events). "
    },
    "renderItem.return_bezierCurve.textContent": {
        "desc": " Text block attached to an element and layout based on the element by textConfig. The props the the same as [text][0].\n\n[0]: option.html#series-custom.renderItem.return_text"
    },
    "renderItem.return_bezierCurve.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "renderItem.return_bezierCurve.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "renderItem.return_bezierCurve.textConfig.rotation": {
        "desc": " Rotation of textContent. In radian. "
    },
    "renderItem.return_bezierCurve.textConfig.layoutRect": {
        "desc": " Rect that textContent will be positioned. Default to be the bounding box of host element. \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "renderItem.return_bezierCurve.textConfig.offset": {
        "desc": " Offset of the textContent. The difference of offset and position is that offset will be applied in the rotation. "
    },
    "renderItem.return_bezierCurve.textConfig.origin": {
        "desc": "origin is relative to the bounding box of the host element. Can be percent value. Relative to the bounding box. If 'center' specified, it will be center of the bounding box. Only available when position and rotation are both set. \n\n* like [12, 33]\n* or like ['50%', '50%']\n* 'center'\n\n"
    },
    "renderItem.return_bezierCurve.textConfig.distance": {
        "desc": " Distance to the layoutRectã€‚ "
    },
    "renderItem.return_bezierCurve.textConfig.local": {
        "desc": " If true, it will apply host's transform. "
    },
    "renderItem.return_bezierCurve.textConfig.insideFill": {
        "desc": "insideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" In most cases, \"auto-calculated-fill\" is white. "
    },
    "renderItem.return_bezierCurve.textConfig.insideStroke": {
        "desc": "insideStroke is a color string or left empty. If a textContent is \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be the same as fill of this element if possible, or null.\n\n"
    },
    "renderItem.return_bezierCurve.textConfig.outsideFill": {
        "desc": "outsideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "renderItem.return_bezierCurve.textConfig.outsideStroke": {
        "desc": "outsideStroke is a color string or left empty. If a textContent is not \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be a near white color to distinguish \"front end\" label with messy background (like other text label, line or other graphic).\n\n"
    },
    "renderItem.return_bezierCurve.textConfig.inside": {
        "desc": " Tell echarts that I can make sure this text is inside or not. "
    },
    "renderItem.return_bezierCurve.during": {
        "desc": "during callback enable users to set props to an element in each animation frame. \n\n    (duringAPI: CustomDuringAPI) => void\n    \n    interface CustomDuringAPI {\n        // Set transform prop value.\n        // Transform prop see `TransformProp`.\n        setTransform(key: TransformProp, val: unknown): void;\n        // Get transform prop value of the current animation frame.\n        getTransform(key: TransformProp): unknown;\n        // Set shape prop value.\n        // Shape prop is like `{ type: 'rect', shape: { xxxProp: xxxValue } }`.\n        setShape(key: string, val: unknown): void;\n        // Get shape prop value of the current animation frame.\n        getShape(key: string): unknown;\n        // Set style prop value.\n        // Style prop is like `{ type: 'rect', style: { xxxProp: xxxValue } }`.\n        setStyle(key: string, val: unknown): void;\n        // Get style prop value of the current animation frame.\n        getStyle(key: string): unknown;\n        // Set extra prop value.\n        // Extra prop is like `{ type: 'rect', extra: { xxxProp: xxxValue } }`.\n        setExtra(key: string, val: unknown): void;\n        // Get extra prop value of the current animation frame.\n        getExtra(key: string): unknown;\n    }\n    \n    type TransformProp =\n        'x' | 'y' | 'scaleX' | 'scaleY' | 'originX' | 'originY' | 'rotation';\n    \n\nIn most cases users do not need this during callback. For example, if some props are specified in [transition][0], echarts will make interpolation for these props internally and therefore have animation based on these props automatically. But if this kind of internal interpolation does not match the user requirements of animation, users can use this during callback to customize them. For example, if users are using [polygon][1] shape. The shape is described by [shape.points][2], which is an points array like: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: [[12, 33], [15, 36], [19, 39], ...]\n        },\n        // ...\n    }\n    \n\nIf users specify them into [transition][3] like: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: [[12, 33], [15, 36], [19, 39], ...],\n        },\n        transition: 'shape'\n        // ...\n    }\n    \n\nAlthough the points will be interpolated, the consequent animation will be like that each point runs straight to the target position, which might do not match the user requirement if some kind of track like spiral is actually needed. In this case, users can use the during callback like that: \n\n    {\n        type: 'polygon',\n        shape: {\n            points: calculatePoints(initialDegree),\n            transition: 'points'\n        },\n        extra: {\n            degree: nextDegree\n        },\n        // Make echarts interpolate `extra.degree` internally, based on which\n        // we calculate the `points` in each animation frame.\n        transition: 'extra',\n        during: function (duringAPI) {\n            var currentDegree = duringAPI.getExtra('degree');\n            duringAPI.setShape(calculatePoints(currentDegree));\n        }\n        // ...\n    }\n    \n\nSee this example [example][4].\n\n[0]: option.html#series-custom.renderItem.return_rect.transition\n[1]: option.html#series-custom.renderItem.return_polygon\n[2]: option.html#series-custom.renderItem.return_polygon.shape.points\n[3]: option.html#series-custom.renderItem.return_polygon.transition\n[4]: https://echarts.apache.org/examples/en/editor.html?c=custom-spiral-race&edit=1&reset=1"
    },
    "renderItem.return_bezierCurve.extra": {
        "desc": " Users can define their own props in this extra field. See [during][0] for the major usage of extra.\n\n[0]: option.html#series-custom.renderItem.return_rect.during"
    },
    "renderItem.return_bezierCurve.extra.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this extra. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            extra: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            extra: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `extra` will\n            // have transition animation.\n            transition: 'extra',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_bezierCurve.shape": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "renderItem.return_bezierCurve.shape.x1": {
        "desc": " x value of the start point. "
    },
    "renderItem.return_bezierCurve.shape.y1": {
        "desc": " y value of the start point. "
    },
    "renderItem.return_bezierCurve.shape.x2": {
        "desc": " x value of the end point. "
    },
    "renderItem.return_bezierCurve.shape.y2": {
        "desc": " y value of the end point. "
    },
    "renderItem.return_bezierCurve.shape.cpx1": {
        "desc": " x of control point. "
    },
    "renderItem.return_bezierCurve.shape.cpy1": {
        "desc": " y of control point. "
    },
    "renderItem.return_bezierCurve.shape.cpx2": {
        "desc": " x of the second control point. If specified, cubic bezier is used. If both cpx2 and cpy2 are not set, quatratic bezier is used. "
    },
    "renderItem.return_bezierCurve.shape.cpy2": {
        "desc": " y of the second control point. If specified, cubic bezier is used. If both cpx2 and cpy2 are not set, quatratic bezier is used. "
    },
    "renderItem.return_bezierCurve.shape.percent": {
        "desc": " Specify the percentage of drawing, useful in animation. Value range: [0, 1]. "
    },
    "renderItem.return_bezierCurve.shape.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this shape. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            shape: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            shape: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `shape` will\n            // have transition animation.\n            transition: 'shape',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_bezierCurve.style": {
        "desc": " More attributes in style (for example, [rich text][0]), see the style related attributes in [zrender/graphic/Displayable][1]. Notice, the attribute names of the style of graphic elements is derived from zrender, which may be different from the attribute names in echarts label, echarts itemStyle, etc., although they have the same meaning. For example: \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#Rich%20Text\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "renderItem.return_bezierCurve.style.fill": {
        "desc": " Color filled in this element. "
    },
    "renderItem.return_bezierCurve.style.stroke": {
        "desc": " Color of stroke. "
    },
    "renderItem.return_bezierCurve.style.lineWidth": {
        "desc": " Width of stroke. "
    },
    "renderItem.return_bezierCurve.style.shadowBlur": {
        "desc": " Width of shadow. "
    },
    "renderItem.return_bezierCurve.style.shadowOffsetX": {
        "desc": " X offset of shadow. "
    },
    "renderItem.return_bezierCurve.style.shadowOffsetY": {
        "desc": " Y offset of shadow. "
    },
    "renderItem.return_bezierCurve.style.shadowColor": {
        "desc": " color of shadow. "
    },
    "renderItem.return_bezierCurve.style.transition": {
        "desc": " Can be a single property name or an array of property names. Enable transition animation when the specified properties changed. Can only specify properties that are under this style. For example: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            style: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n                // This two props will perform transition animation.\n                transition: ['mmm', 'ppp']\n            }\n        };\n    }\n    \n\nWe can also specify all of the properties like this: \n\n    renderItem: function (params, api) {\n        return {\n            type: 'xxx',\n            style: {\n                mmm: ...,\n                nnn: ...,\n                ppp: ...,\n                qqq: ...,\n            },\n            // Indicate that all props in `style` will\n            // have transition animation.\n            transition: 'style',\n        };\n    }\n    \n\n"
    },
    "renderItem.return_bezierCurve.focus": {
        "desc": ">  Since > v5.0.0 When it's highlighted, whether to fade out of other data to focus the highlighted. The following configurations are supported: \n\n* 'none' Do not fade out other data, it's by default.\n* 'self' Only focus (not fade out) the element of the currently highlighted data.\n* 'series' Focus on all elements of the series which the currently highlighted data belongs to.\n\n"
    },
    "renderItem.return_bezierCurve.blurScope": {
        "desc": ">  Since > v5.0.0 The range of fade out when focus is enabled. Support the following configurations \n\n* 'coordinateSystem'\n* 'series'\n* 'global'\n\n"
    },
    "renderItem.return_bezierCurve.emphasis": {
        "desc": " Emphasis state of the element. "
    },
    "renderItem.return_bezierCurve.emphasis.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_bezierCurve.blur": {
        "desc": ">  Since > v5.0.0 Blur state, available when focus is set. "
    },
    "renderItem.return_bezierCurve.blur.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "renderItem.return_bezierCurve.select": {
        "desc": ">  Since > v5.0.0 Select state, available when [selectedMode][0] is set.\n\n[0]: #series-custom.selectedMode"
    },
    "renderItem.return_bezierCurve.select.style": {
        "desc": " Same to [style][0].\n\n[0]: #series-custom.renderItem.return_polygon.style"
    },
    "itemStyle": {
        "desc": " Graphic style of , emphasis is the style when it is highlighted, like being hovered by mouse, or highlighted via legend connect. "
    },
    "itemStyle.color": {
        "desc": " color. Color is taken from [option.color Palette][0] by default. \n\n> Supports setting as solid color using > rgb(255,255,255)> , > rgba(255,255,255,1)> , > #fff> , etc. Also supports setting as gradient color and pattern fill, see [> option.color][0]>  for details \n\n[0]: #color",
        "uiControl": {
            "type": "color"
        }
    },
    "itemStyle.borderColor": {
        "desc": " border color, whose format is similar to that of color. ",
        "uiControl": {
            "type": "color"
        }
    },
    "itemStyle.borderWidth": {
        "desc": " border width. No border when it is set to be 0. border width. No border when it is set to be 0. ",
        "uiControl": {
            "type": "number",
            "value": "0",
            "min": "0",
            "step": "0.5",
            "default": "0"
        }
    },
    "itemStyle.borderType": {
        "desc": " border type. Possible values are: \n\n* 'solid'\n* 'dashed'\n* 'dotted'\n\nSince v5.0.0, it can also be a number or a number array to specify the [dash array][0] of the line. With borderDashOffset , we can make the line style more flexible. For exampleï¼š \n\n    {\n    \n    borderType: [5, 10],\n    \n    borderDashOffset: 5\n    }\n    \n\n\n\n[0]: https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray",
        "uiControl": {
            "type": "enum",
            "options": "'solid','dashed','dotted'"
        }
    },
    "itemStyle.borderDashOffset": {
        "desc": ">  Since > v5.0.0 To set the line dash offset. With borderType , we can make the line style more flexible. Refer to MDN [lineDashOffset][0] for more details.\n\n[0]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineDashOffset",
        "uiControl": {
            "type": "number",
            "min": "0",
            "step": "1",
            "default": "0"
        }
    },
    "itemStyle.borderCap": {
        "desc": ">  Since > v5.0.0 To specify how to draw the end points of the line. Possible values are: \n\n* 'butt': The ends of lines are squared off at the endpoints.\n* 'round': The ends of lines are rounded.\n* 'square': The ends of lines are squared off by adding a box with an equal width and half the height of the line's thickness.\n\nDefault value is 'butt'. Refer to MDN [lineCap][0] for more details.\n\n[0]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineCap",
        "uiControl": {
            "type": "enum",
            "options": "'butt','round','square'"
        }
    },
    "itemStyle.borderJoin": {
        "desc": ">  Since > v5.0.0 To determine the shape used to join two line segments where they meet. Possible values are: \n\n* 'bevel': Fills an additional triangular area between the common endpoint of connected segments, and the separate outside rectangular corners of each segment.\n* 'round': Rounds off the corners of a shape by filling an additional sector of disc centered at the common endpoint of connected segments. The radius for these rounded corners is equal to the line width.\n* 'miter': Connected segments are joined by extending their outside edges to connect at a single point, with the effect of filling an additional lozenge-shaped area. This setting is affected by the borderMiterLimit property.\n\nDefault value is 'bevel'. Refer to MDN [lineJoin][0] for more details.\n\n[0]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineJoin",
        "uiControl": {
            "type": "enum",
            "options": "'bevel','round','miter'"
        }
    },
    "itemStyle.borderMiterLimit": {
        "desc": ">  Since > v5.0.0 To set the miter limit ratio. Only works when borderJoin is set as miter. Default value is 10. Negativeã€0ã€Infinity and NaN values are ignored. Refer to MDN [miterLimit][0] for more details.\n\n[0]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/miterLimit",
        "uiControl": {
            "type": "number",
            "min": "0",
            "step": "1",
            "default": "10"
        }
    },
    "itemStyle.shadowBlur": {
        "desc": " Size of shadow blur. This attribute should be used along with shadowColor,shadowOffsetX, shadowOffsetY to set shadow to component. For example: \n\n    {\n        shadowColor: 'rgba(0, 0, 0, 0.5)',\n        shadowBlur: 10\n    }\n    \n\n",
        "uiControl": {
            "type": "number",
            "default": "0",
            "min": "0",
            "step": "0.5"
        }
    },
    "itemStyle.shadowColor": {
        "desc": " Shadow color. Support same format as color. ",
        "uiControl": {
            "type": "color",
            "default": "''"
        }
    },
    "itemStyle.shadowOffsetX": {
        "desc": " Offset distance on the horizontal direction of shadow. ",
        "uiControl": {
            "type": "number",
            "default": "0",
            "step": "0.5"
        }
    },
    "itemStyle.shadowOffsetY": {
        "desc": " Offset distance on the vertical direction of shadow. ",
        "uiControl": {
            "type": "number",
            "default": "0",
            "step": "0.5"
        }
    },
    "itemStyle.opacity": {
        "desc": " Opacity of the component. Supports value from 0 to 1, and the component will not be drawn when set to 0. ",
        "uiControl": {
            "type": "number",
            "default": "1",
            "min": "0",
            "max": "1",
            "step": "0.01"
        }
    },
    "itemStyle.decal": {
        "desc": " The style of the decal pattern. It works only if [aria.enabled][0] and [aria.decal.show][1] are both set to be true. If it is set to be 'none', no decal will be used.\n\n[0]: #aria.enabled\n[1]: #aria.decal.show"
    },
    "itemStyle.decal.symbol": {
        "desc": " The symbol type of the decal. If it is in the type of string[], it means the symbols are used one by one. Icon types provided by ECharts includes 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow', 'none' It can be set to an image with 'image://url' , in which URL is the link to an image, or dataURI of an image. An image URL example: \n\n    'image://http://xxx.xxx.xxx/a/b.png'\n    \n\nA dataURI example: \n\n    'image://data:image/gif;base64,R0lGODlhEAAQAMQAAORHHOVSKudfOulrSOp3WOyDZu6QdvCchPGolfO0o/XBs/fNwfjZ0frl3/zy7////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAkAABAALAAAAAAQABAAAAVVICSOZGlCQAosJ6mu7fiyZeKqNKToQGDsM8hBADgUXoGAiqhSvp5QAnQKGIgUhwFUYLCVDFCrKUE1lBavAViFIDlTImbKC5Gm2hB0SlBCBMQiB0UjIQA7'\n    \n\nIcons can be set to arbitrary vector path via 'path://' in ECharts. As compared with a raster image, vector paths prevent jagging and blurring when scaled, and have better control over changing colors. The size of the vector icon will be adapted automatically. Refer to [SVG PathData][0] for more information about the format of the path. You may export vector paths from tools like Adobe For example: \n\n    'path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z'\n    \n\n[0]: http://www.w3.org/TR/SVG/paths.html#PathData"
    },
    "itemStyle.decal.symbolSize": {
        "desc": " Range of values: 0 to 1, representing the size of symbol relative to decal. "
    },
    "itemStyle.decal.symbolKeepAspect": {
        "desc": " Whether or not to keep the aspect ratio of the pattern. "
    },
    "itemStyle.decal.color": {
        "desc": " For the color of the decal pattern, it is recommended to use a translucent color, which can be superimposed on the color of the series itself. "
    },
    "itemStyle.decal.backgroundColor": {
        "desc": " The background color of the decal will be over the color of the series itself, under the decal pattern. "
    },
    "itemStyle.decal.dashArrayX": {
        "desc": " The basic pattern of the decal pattern is an infinite loop in the form of Pattern - Blank - Pattern - Blank - Pattern - Blank both horizontally and vertically, respectively. By setting the length of each pattern and blank, complex pattern effects can be achieved. dashArrayX controls the horizontal pattern pattern. When its value is of type number or number[], it is similar to [SVG stroke-dasharray][0]. \n\n* If it is of type number, it means that the pattern and the blank space are of this value respectively. For example, 5 means the pattern with width 5 is displayed first, then 5 pixels empty, then the pattern with width 5 is displayed...\n* In the case of number[] type, it means that the pattern and empty space are loops of an array of values. For example: [5, 10, 2, 6] means the pattern is 5 pixels wide, then 10 pixels empty, then the pattern is 2 pixels wide, then 6 pixels empty, then the pattern is 5 pixels wide...\n* If of type (number | number[])[], it means that each row is a loop with an array of values for the pattern and blank space. For example: [10, [2, 5]] means that the first line will be 10 pixels by 10 pixels and empty space, the second line will be 2 pixels by 2 pixels and empty space, and the third line will be 10 pixels by 10 pixels and empty space...\n\nThis interface can be better understood with the following examples. æš‚æ—¶æ— æ³•æ˜¾ç¤º\n\n[0]: https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray"
    },
    "itemStyle.decal.dashArrayY": {
        "desc": " The basic pattern of the decal pattern is an infinite loop in the form of Pattern - Blank - Pattern - Blank - Pattern - Blank both horizontally and vertically, respectively. By setting the length of each pattern and blank, complex pattern effects can be achieved. dashArrayY controls the horizontal pattern pattern. Similar to [SVG stroke-dasharray][0]. \n\n* If it is a number type, it means the pattern and the blank are each of this value. For example, 5 means that the pattern with a height of 5 is displayed first, then 5 pixels empty, then the pattern with a height of 5 is displayed...\n* In the case of number[] type, it means that the pattern and empty space are loops of sequential array values. For example: [5, 10, 2, 6] means the pattern is 5 pixels high, then 10 pixels empty, then the pattern is 2 pixels high, then 6 pixels empty, then the pattern is 5 pixels high...\n\nThis interface can be better understood with the following examples. æš‚æ—¶æ— æ³•æ˜¾ç¤º\n\n[0]: https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray"
    },
    "itemStyle.decal.rotation": {
        "desc": " The overall rotation angle (in radians) of the pattern, in the range from `-Math. "
    },
    "itemStyle.decal.maxTileWidth": {
        "desc": " The upper limit of the width of the generated pattern before it is duplicated. Usually this value is not necessary, but you can try to increase it if you notice discontinuous seams in the pattern when it repeats. "
    },
    "itemStyle.decal.maxTileHeight": {
        "desc": " The upper limit of the height of the generated pattern before it repeats. This value is usually not necessary to set, but you can try to increase it if you find that the pattern has discontinuous seams when it is repeated. "
    },
    "labelLine": {
        "desc": " Configuration of label guide line. "
    },
    "labelLine.show": {
        "desc": " Whether to show the label guide line. ",
        "uiControl": {
            "type": "boolean"
        }
    },
    "labelLine.showAbove": {
        "desc": " Whether to show the label guide line above the corresponding element. "
    },
    "labelLine.length2": {
        "desc": " The length of the second segment of guide line. ",
        "uiControl": {
            "type": "number",
            "default": "15",
            "min": "0",
            "step": "1"
        }
    },
    "labelLine.smooth": {
        "desc": " Whether to smooth the guide line. It defaults to be false and can be set as true or the values from 0 to 1 which indicating the smoothness. ",
        "uiControl": {
            "type": "boolean"
        }
    },
    "labelLine.minTurnAngle": {
        "desc": " Minimum turn angle between two segments of guide line to prevent unaesthetic display when angle is too small. Can be 0 - 180 degree. "
    },
    "labelLine.lineStyle": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "labelLine.lineStyle.color": {
        "desc": " Line color. \n\n> Supports setting as solid color using > rgb(255,255,255)> , > rgba(255,255,255,1)> , > #fff> , etc. Also supports setting as gradient color and pattern fill, see [> option.color][0]>  for details \n\n[0]: #color",
        "uiControl": {
            "type": "color"
        }
    },
    "labelLine.lineStyle.width": {
        "desc": " line width. ",
        "uiControl": {
            "type": "number",
            "value": "1",
            "min": "0",
            "step": "0.5",
            "default": "0"
        }
    },
    "labelLine.lineStyle.type": {
        "desc": " line type. Possible values are: \n\n* 'solid'\n* 'dashed'\n* 'dotted'\n\nSince v5.0.0, it can also be a number or a number array to specify the [dash array][0] of the line. With dashOffset , we can make the line style more flexible. For exampleï¼š \n\n    {\n    \n    type: [5, 10],\n    \n    dashOffset: 5\n    }\n    \n\n\n\n[0]: https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray",
        "uiControl": {
            "type": "enum",
            "options": "'solid','dashed','dotted'"
        }
    },
    "labelLine.lineStyle.dashOffset": {
        "desc": ">  Since > v5.0.0 To set the line dash offset. With type , we can make the line style more flexible. Refer to MDN [lineDashOffset][0] for more details.\n\n[0]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineDashOffset",
        "uiControl": {
            "type": "number",
            "min": "0",
            "step": "1",
            "default": "0"
        }
    },
    "labelLine.lineStyle.cap": {
        "desc": ">  Since > v5.0.0 To specify how to draw the end points of the line. Possible values are: \n\n* 'butt': The ends of lines are squared off at the endpoints.\n* 'round': The ends of lines are rounded.\n* 'square': The ends of lines are squared off by adding a box with an equal width and half the height of the line's thickness.\n\nDefault value is 'butt'. Refer to MDN [lineCap][0] for more details.\n\n[0]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineCap",
        "uiControl": {
            "type": "enum",
            "options": "'butt','round','square'"
        }
    },
    "labelLine.lineStyle.join": {
        "desc": ">  Since > v5.0.0 To determine the shape used to join two line segments where they meet. Possible values are: \n\n* 'bevel': Fills an additional triangular area between the common endpoint of connected segments, and the separate outside rectangular corners of each segment.\n* 'round': Rounds off the corners of a shape by filling an additional sector of disc centered at the common endpoint of connected segments. The radius for these rounded corners is equal to the line width.\n* 'miter': Connected segments are joined by extending their outside edges to connect at a single point, with the effect of filling an additional lozenge-shaped area. This setting is affected by the miterLimit property.\n\nDefault value is 'bevel'. Refer to MDN [lineJoin][0] for more details.\n\n[0]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineJoin",
        "uiControl": {
            "type": "enum",
            "options": "'bevel','round','miter'"
        }
    },
    "labelLine.lineStyle.miterLimit": {
        "desc": ">  Since > v5.0.0 To set the miter limit ratio. Only works when join is set as miter. Default value is 10. Negativeã€0ã€Infinity and NaN values are ignored. Refer to MDN [miterLimit][0] for more details.\n\n[0]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/miterLimit",
        "uiControl": {
            "type": "number",
            "min": "0",
            "step": "1",
            "default": "10"
        }
    },
    "labelLine.lineStyle.shadowBlur": {
        "desc": " Size of shadow blur. This attribute should be used along with shadowColor,shadowOffsetX, shadowOffsetY to set shadow to component. For example: \n\n    {\n        shadowColor: 'rgba(0, 0, 0, 0.5)',\n        shadowBlur: 10\n    }\n    \n\n",
        "uiControl": {
            "type": "number",
            "default": "0",
            "min": "0",
            "step": "0.5"
        }
    },
    "labelLine.lineStyle.shadowColor": {
        "desc": " Shadow color. Support same format as color. ",
        "uiControl": {
            "type": "color",
            "default": "''"
        }
    },
    "labelLine.lineStyle.shadowOffsetX": {
        "desc": " Offset distance on the horizontal direction of shadow. ",
        "uiControl": {
            "type": "number",
            "default": "0",
            "step": "0.5"
        }
    },
    "labelLine.lineStyle.shadowOffsetY": {
        "desc": " Offset distance on the vertical direction of shadow. ",
        "uiControl": {
            "type": "number",
            "default": "0",
            "step": "0.5"
        }
    },
    "labelLine.lineStyle.opacity": {
        "desc": " Opacity of the component. Supports value from 0 to 1, and the component will not be drawn when set to 0. ",
        "uiControl": {
            "type": "number",
            "default": "1",
            "min": "0",
            "max": "1",
            "step": "0.01"
        }
    },
    "labelLayout": {
        "desc": ">  Since > v5.0.0 Unified layout configuration of labels. It provide a chance to adjust the labels' (x, y) position, alignment based on the original layout each series provides. This option can be a callback with following parameters. \n\n    // corresponding index of data\n    dataIndex: number\n    // corresponding type of data. Only available in graph, in which it can be 'node' or 'edge'\n    dataType?: string\n    // corresponding index of series\n    seriesIndex: number\n    // Displayed text of label.\n    text: string\n    // Bounding rectangle of label.\n    labelRect: {x: number, y: number, width: number, height: number}\n    // Horizontal alignment of label.\n    align: 'left' | 'center' | 'right'\n    // Vertical alignment of label.\n    verticalAlign: 'top' | 'middle' | 'bottom'\n    // Bounding rectangle of the element corresponding to.\n    rect: {x: number, y: number, width: number, height: number}\n    // Default points array of labelLine. Currently only provided in pie and funnel series.\n    // It's null in other series.\n    labelLinePoints?: number[][]\n    \n\n**Example:** Align the labels on the right. Left 10px margin to the edge. \n\n    labelLayout(params) {\n        return {\n            x: params.rect.x + 10,\n            y: params.rect.y + params.rect.height / 2,\n            verticalAlign: 'middle',\n            align: 'left'\n        }\n    }\n    \n\nSet the text size based on the size of element bounding rectangle. \n\n    \n    labelLayout(params) {\n        return {\n            fontSize: Math.max(params.rect.width / 10, 5)\n        };\n    }\n    \n\n"
    },
    "labelLayout.hideOverlap": {
        "desc": " If hide the overlapped labels. The following example shows how to hide the overlapped labels in graph automatically when zooming. æš‚æ—¶æ— æ³•æ˜¾ç¤º "
    },
    "labelLayout.moveOverlap": {
        "desc": " If move the overlapped labels to avoid overlapping. Currently supported configurations: \n\n* 'shiftX' Place the labels on horizontal direction sequencely, used when aligned horizontally.\n* 'shiftY' Place the labels on vertial direction sequencely, used when aligned vertically.\n\nThe following example shows how to use moverOverlap: 'shiftY' to place the labels aligned vertically. æš‚æ—¶æ— æ³•æ˜¾ç¤º "
    },
    "labelLayout.x": {
        "desc": " The x position of the label. Support absolute pixel values â€‹â€‹or relative values â€‹â€‹such as '20%'. "
    },
    "labelLayout.y": {
        "desc": " The y position of the label. Support absolute pixel values â€‹â€‹or relative values â€‹â€‹such as '20%'. "
    },
    "labelLayout.dx": {
        "desc": " The pixel offset of the label in the x direction. Can be used with x. "
    },
    "labelLayout.dy": {
        "desc": " The pixel offset of the label in the y direction. Can be used with y"
    },
    "labelLayout.rotate": {
        "desc": " Label rotation angle. "
    },
    "labelLayout.width": {
        "desc": " The width of displayed label. Can be used with overflow to constraint the label in a fixed width "
    },
    "labelLayout.height": {
        "desc": " The height of displayed label. Can be used with lineOverflow to constraint the label in a fixed height. "
    },
    "labelLayout.align": {
        "desc": " The horizontal alignment of the label. Can be 'left', 'center', 'right'. "
    },
    "labelLayout.verticalAlign": {
        "desc": " The vertical alignment of the label. Can be 'top', 'middle', 'bottom'. "
    },
    "labelLayout.fontSize": {
        "desc": " The text size of the label. "
    },
    "labelLayout.draggable": {
        "desc": " Whether to allow the user to adjust the position by dragging. "
    },
    "labelLayout.labelLinePoints": {
        "desc": " The array of the three points of the label guide line. The format is: \n\n    [[x, y], [x, y], [x, y]]\n    \n\nIt is often used in pie charts to fine-tune the guide line that has been calculated. Usually not recommended to set it in other situations. "
    },
    "selectedMode": {
        "desc": ">  Since > v5.0.0 Selected mode. It is enabled by default, and you may set it to be false to disabled it. Besides, it can be set to 'single' or 'multiple', for single selection and multiple selections. ",
        "uiControl": {
            "type": "enum",
            "options": "'false','true','single','multiple'"
        }
    },
    "dimensions": {
        "desc": "dimensions can be used to define dimension info for series.data or dataset.source. Notice: if [dataset][0] is used, we can definite dimensions in [dataset.dimensions][1], or provide dimension names in the first column/row of [dataset.source][2], and not need to specify dimensions here. But if dimensions is specified here, it will be used despite the dimension definitions in dataset. For example: \n\n    option = {\n        dataset: {\n            source: [\n                // 'date', 'open', 'close', 'highest', 'lowest'\n                [12, 44, 55, 66, 2],\n                [23, 6, 16, 23, 1],\n                ...\n            ]\n        },\n        series: {\n            type: 'xxx',\n            // Specify name for each dimesions, which will be displayed in tooltip.\n            dimensions: ['date', 'open', 'close', 'highest', 'lowest']\n        }\n    }\n    \n\n    series: {\n        type: 'xxx',\n        dimensions: [\n            null,                // If you do not intent to defined this dimension, use null is fine.\n            {type: 'ordinal'},   // Specify type of this dimension.\n                                 // 'ordinal' is always used in string.\n                                 // If type is not specified, echarts will guess type by data.\n            {name: 'good', type: 'number'},\n            'bad'                // Equals to {name: 'bad'}.\n        ]\n    }\n    \n\nEach data item of dimensions can be: \n\n* string, for example, 'someName', which equals to {name: 'someName'}.\n* Object, where the attributes can be:\n  * name: string.\n  * type: string, supports:\n    * number\n    * float, that is, [Float64Array][3]\n    * int, that is, [Int32Array][4]\n    * ordinal, discrete value, which represents string generally.\n    * time, time value, see [data][5] to check the format of time value.\n  * displayName: string, generally used in tooltip for dimension display. If not specified, use name by default.\n\nWhen dimensions is specified, the default tooltip will be displayed vertically, which is better to show diemsion names. Otherwise, tooltip will displayed only value horizontally.\n\n[0]: #dataset\n[1]: #dataset.dimensions\n[2]: #dataset.source\n[3]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array\n[4]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array\n[5]: #series.data"
    },
    "encode": {
        "desc": " Define what is encoded to for each dimension of data. For example: \n\n    option = {\n        dataset: {\n            source: [\n                // Each column is called a dimension.\n                // There are five dimensions: 0, 1, 2, 3, 4.\n                [12, 44, 55, 66, 2],\n                [23, 6, 16, 23, 1],\n                ...\n            ]\n        },\n        series: {\n            type: 'xxx',\n            encode: {\n                x: [3, 1, 5],      // Dimension 3, 1, 5 is mapped to x axis.\n                y: 2,              // Dimension 2 is mapped to y axis.\n                tooltip: [3, 2, 4] // Dimension 3, 2, 4 will be displayed in tooltip.\n            }\n        }\n    }\n    \n\nWhen [dimensions][0] is used to defined name for a certain dimension, encode can refer the name directly. For example: \n\n    series: {\n        type: 'xxx',\n        dimensions: ['date', 'open', 'close', 'highest', 'lowest'],\n        encode: {\n            x: 'date',\n            y: ['open', 'close', 'highest', 'lowest']\n        }\n    }\n    \n\nThe basic structure of [encode][1] is illustrated as follows, where the left part of colon is the name of axis like 'x', 'y', 'radius', 'angle' or some special reserved names like \"tooltip\", \"itemName\" etc., and the right part of the colon is the dimension names or dimension indices (based on 0). One or more dimensions can be specified. Usually not all of mappings need to be specified, only specify needed ones. The properties available in encode listed as follows: \n\n    // In any of the series and coordinate systems,\n    // these properties are available:\n    encode: {\n        // Display dimension \"product\" and \"score\" in the tooltip.\n        tooltip: ['product', 'score']\n        // Set the series name as the concat of the names of dimensions[1] and dimensions[3].\n        // (sometimes the dimension names are too long to type in series.name manually).\n        seriesName: [1, 3],\n        // Using dimensions[2] as the id of each data item. This is useful when dynamically\n        // update data by `chart.setOption()`, where the new and old data item can be\n        // corresponded by id, by which the appropriate animation can be performed when updating.\n        itemId: 2,\n        // Using dimensions[3] as the name of each data item. This is useful in charts like\n        // 'pie', 'funnel', where data item name can be displayed in legend.\n        itemName: 3,\n        // Using dimensions[4] as the groupId of each data item. groupId will be used to categorize the data. And to determine\n        // How the merge and split animation are performed in the universal transition. See universalTransition option for detail.\n        itemGroupId: 4\n    }\n    \n    // These properties only work in cartesian(grid) coordinate system:\n    encode: {\n        // Map dimensions[1], dimensions[5] and dimension \"score\" to the X axis.\n        x: [1, 5, 'score'],\n        // Map dimensions[0] to the Y axis.\n        y: 0\n    }\n    \n    // These properties only work in polar coordinate system:\n    encode: {\n        radius: 3,\n        angle: 2,\n        ...\n    }\n    \n    // These properties only work in geo coordinate system:\n    encode: {\n        lng: 3,\n        lat: 2\n    }\n    \n    // For some type of series that are not in any coordinate system,\n    // like 'pie', 'funnel' etc.:\n    encode: {\n        value: 3\n    }\n    \n\nThis is an [example][2] for encode. Specially, in [custom series(~series-custom), some property in encode, corresponding to axis, can be set as null to make the series not controlled by the axis, that is, the series data will not be count in the extent of the axis, and the [dataZoom][3] on the axis will not filter the series. \n\n    var option = {\n        xAxis: {},\n        yAxis: {},\n        dataZoom: [{\n            xAxisIndex: 0\n        }, {\n            yAxisIndex: 0\n        }],\n        series: {\n            type: 'custom',\n            renderItem: function (params, api) {\n                return {\n                    type: 'circle',\n                    shape: {\n                        cx: 100, // x position is always 100\n                        cy: api.coord([0, api.value(0)])[1],\n                        r: 30\n                    },\n                    style: {\n                        fill: 'blue'\n                    }\n                };\n            },\n            encode: {\n                // Then the series will not be controlled\n                // by x axis and corresponding dataZoom.\n                x: -1,\n                y: 1\n            },\n            data: [ ... ]\n        }\n    };\n    \n\n\n\n[0]: #series.dimensions\n[1]: option.html#series.encode\n[2]: https://echarts.apache.org/examples/en/view.html?c=dataset-encode1&edit=1&reset=1\n[3]: #dataZoom"
    },
    "seriesLayoutBy": {
        "desc": " When [dataset][0] is used, seriesLayoutBy specifies whether the column or the row of dataset is mapped to the series, namely, the series is \"layout\" on columns or rows. Optional values: \n\n* 'column': by default, the columns of dataset are mapped the series. In this case, each column represents a dimension.\n* 'row'ï¼šthe rows of dataset are mapped to the series. In this case, each row represents a dimension.\n\nCheck this [example][1].\n\n[0]: #dataset\n[1]: https://echarts.apache.org/examples/en/editor.html?c=dataset-series-layout-by"
    },
    "datasetIndex": {
        "desc": " If [series.data][0] is not specified, and [dataset][1] exists, the series will use dataset. datasetIndex specifies which dataset will be used.\n\n[0]: #series.data\n[1]: #dataset"
    },
    "dataGroupId": {
        "desc": " A groupID common to all data in the series. the groupID will be used to classify the data and determine how merge and split animations are performed in the universal transition animation. If you are using the [dataset][0] component to represent the data, it is recommended to use encode.itemGroupID to specify which dimension is encoded as the groupID.\n\n[0]: #dataset"
    },
    "data": {
        "desc": " Data array of series, which can be in the following forms: Notice, if no data specified in series, and there is [dataset][0] in option, series will use the first [dataset][0] as its datasource. If data has been specified, [dataset][0] will not used. series.datasetIndex can be used to specify other [dataset][0]. Basically, data is represented by a two-dimension array, like the example below, where each column is named as a \"dimension\". \n\n    series: [{\n        data: [\n            // dimX   dimY   other dimensions ...\n            [  3.4,    4.5,   15,   43],\n            [  4.2,    2.3,   20,   91],\n            [  10.8,   9.5,   30,   18],\n            [  7.2,    8.8,   18,   57]\n        ]\n    }]\n    \n\n* In [cartesian (grid)][1], \"dimX\" and \"dimY\" correspond to [xAxis][2] and [yAxis][3] respectively.\n* In [polar][4] \"dimX\" and \"dimY\" correspond to [radiusAxis][5] å’Œ [angleAxis][6] respectively.\n* Other dimensions are optional, which can be used in other places. For example:\n  * [visualMap][7] can map one or more dimensions to visual (color, symbol size ...).\n  * [series.symbolSize][8] can be set as a callback function, where symbol size can be calculated by values of a certain dimension.\n  * Values in other dimensions can be shown by [tooltip.formatter][9] or [series.label.formatter][10].\n\nEspecially, when there is one and only one category axis (axis.type is 'category'), data can be simply be represented by a one-dimension array, like: \n\n    xAxis: {\n        data: ['a', 'b', 'm', 'n']\n    },\n    series: [{\n        // Each item corresponds to each item in xAxis.data.\n        data: [23,  44,  55,  19]\n        // In fact, it is the simplification of the format below:\n        // data: [[0, 23], [1, 44], [2, 55], [3, 19]]\n    }]\n    \n\n  \n**Relationship between \"value\" and [axis.type][11]*** When a dimension corresponds to a value axis (axis.type is 'value' or 'log'): The value can be a number (like 12) (can also be a number in a string format, like '12').\n* When a dimension corresponds to a category axis (axis.type is 'category'): The value should be the ordinal of the axis.data (based on 0), the string value of the axis.data. For example: \n\n      xAxis: {\n          type: 'category',\n          data: ['Monday', 'Tuesday', 'Wednesday', 'Thursday']\n      },\n      yAxis: {\n          type: 'category',\n          data: ['a', 'b', 'm', 'n', 'p', 'q']\n      },\n      series: [{\n          data: [\n              // xAxis      yAxis\n              [  0,           0,    2  ], // This point is located at xAxis: 'Monday', yAxis: 'a'.\n              [  'Thursday',  2,    1  ], // This point is located at xAxis: 'Thursday', yAxis: 'm'.\n              [  2,          'p',   2  ], // This point is located at xAxis: 'Wednesday', yAxis: 'p'.\n              [  3,           3,    5  ]\n          ]\n      }]\n    \n\nThere is an example of double category axes: [Github Punchcard][12].\n* When a dimension corresponds to a time axis (type is 'time'), the value can be: \n  * a timestamp, like 1484141700832, which represents a UTC time.\n  * a date string, in one of the formats below:\n    * a subset of [ISO 8601][13], only including (all of these are treated as local time unless timezone is specified, which is consistent with [moment][14]):\n      * only part of year/month/date/time are specified: '2012-03', '2012-03-01', '2012-03-01 05', '2012-03-01 05:06'.\n      * separated by \"T\" or a space: '2012-03-01T12:22:33.123', '2012-03-01 12:22:33.123'.\n      * timezone specified: '2012-03-01T12:22:33Z', '2012-03-01T12:22:33+8000', '2012-03-01T12:22:33-05:00'.\n    * other date string format (all of these are treated as local time): '2012', '2012-3-1', '2012/3/1', '2012/03/01', '2009/6/12 2:00', '2009/6/12 2:05:08', '2009/6/12 2:05:08.123'.\n  * a JavaScript Date instance created by user:\n    * Caution, when using a data string to create a Date instance, [browser differences and inconsistencies][15] should be considered.\n    * For example: In chrome, new Date('2012-01-01') is treated as a Jan 1st 2012 in UTC, while new Date('2012-1-1') and new Date('2012/01/01') are treated as Jan 1st 2012 in local timezone. In safari new Date('2012-1-1') is not supported.\n    * So if you intent to perform new Date(dateString), it is strongly recommended to use a time parse library (e.g., [moment][14]), or use echarts.number.parseDate, or check [this][15].\n\n  \n**Customize a data item:** When needing to customize a data item, it can be set as an object, where property value reprensent real value. For example: \n\n    [\n        12,\n        24,\n        {\n            value: [24, 32],\n            // label style, only works in this data item.\n            label: {},\n            // item style, only works in this data item.\n            itemStyle:{}\n        },\n        33\n    ]\n    // Or\n    [\n        [12, 332],\n        [24, 32],\n        {\n            value: [24, 32],\n            // label style, only works in this data item.\n            label: {},\n            // item style, only works in this data item.\n            itemStyle:{}\n        },\n        [33, 31]\n    ]\n    \n\n  \n**Empty value:**'-' or null or undefined or NaN can be used to describe that a data item does not exist (psï¼š_not exist_ does not means its value is 0). For example, line chart can break when encounter an empty value, and scatter chart do not display graphic elements for empty values.   \n  \n\n\n[0]: #dataset\n[1]: #grid\n[2]: #xAxis\n[3]: #yAxis\n[4]: #polar\n[5]: #radiusAxis\n[6]: #anbleAxis\n[7]: #visualMap\n[8]: #series.symbolSize\n[9]: #tooltip.formatter\n[10]: #series.label.formatter\n[11]: #xAxis.type\n[12]: https://echarts.apache.org/examples/en/editor.html?c=scatter-punchCard\n[13]: http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15\n[14]: https://momentjs.com/\n[15]: http://dygraphs.com/date-formats.html"
    },
    "data.name": {
        "desc": " Name of data item. "
    },
    "data.value": {
        "desc": " Value of data item. "
    },
    "data.groupId": {
        "desc": " The groupID of this data item. groupID will be used to classify the data. "
    },
    "data.itemStyle": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "data.itemStyle.color": {
        "desc": " color. \n\n> Supports setting as solid color using > rgb(255,255,255)> , > rgba(255,255,255,1)> , > #fff> , etc. Also supports setting as gradient color and pattern fill, see [> option.color][0]>  for details \n\n[0]: #color",
        "uiControl": {
            "type": "color"
        }
    },
    "data.itemStyle.borderColor": {
        "desc": " border color, whose format is similar to that of color. ",
        "uiControl": {
            "type": "color"
        }
    },
    "data.itemStyle.borderWidth": {
        "desc": " border width. No border when it is set to be 0. border width. No border when it is set to be 0. ",
        "uiControl": {
            "type": "number",
            "value": "0",
            "min": "0",
            "step": "0.5",
            "default": "0"
        }
    },
    "data.itemStyle.borderType": {
        "desc": " border type. Possible values are: \n\n* 'solid'\n* 'dashed'\n* 'dotted'\n\nSince v5.0.0, it can also be a number or a number array to specify the [dash array][0] of the line. With borderDashOffset , we can make the line style more flexible. For exampleï¼š \n\n    {\n    \n    borderType: [5, 10],\n    \n    borderDashOffset: 5\n    }\n    \n\n\n\n[0]: https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray",
        "uiControl": {
            "type": "enum",
            "options": "'solid','dashed','dotted'"
        }
    },
    "data.itemStyle.borderDashOffset": {
        "desc": ">  Since > v5.0.0 To set the line dash offset. With borderType , we can make the line style more flexible. Refer to MDN [lineDashOffset][0] for more details.\n\n[0]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineDashOffset",
        "uiControl": {
            "type": "number",
            "min": "0",
            "step": "1",
            "default": "0"
        }
    },
    "data.itemStyle.borderCap": {
        "desc": ">  Since > v5.0.0 To specify how to draw the end points of the line. Possible values are: \n\n* 'butt': The ends of lines are squared off at the endpoints.\n* 'round': The ends of lines are rounded.\n* 'square': The ends of lines are squared off by adding a box with an equal width and half the height of the line's thickness.\n\nDefault value is 'butt'. Refer to MDN [lineCap][0] for more details.\n\n[0]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineCap",
        "uiControl": {
            "type": "enum",
            "options": "'butt','round','square'"
        }
    },
    "data.itemStyle.borderJoin": {
        "desc": ">  Since > v5.0.0 To determine the shape used to join two line segments where they meet. Possible values are: \n\n* 'bevel': Fills an additional triangular area between the common endpoint of connected segments, and the separate outside rectangular corners of each segment.\n* 'round': Rounds off the corners of a shape by filling an additional sector of disc centered at the common endpoint of connected segments. The radius for these rounded corners is equal to the line width.\n* 'miter': Connected segments are joined by extending their outside edges to connect at a single point, with the effect of filling an additional lozenge-shaped area. This setting is affected by the borderMiterLimit property.\n\nDefault value is 'bevel'. Refer to MDN [lineJoin][0] for more details.\n\n[0]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineJoin",
        "uiControl": {
            "type": "enum",
            "options": "'bevel','round','miter'"
        }
    },
    "data.itemStyle.borderMiterLimit": {
        "desc": ">  Since > v5.0.0 To set the miter limit ratio. Only works when borderJoin is set as miter. Default value is 10. Negativeã€0ã€Infinity and NaN values are ignored. Refer to MDN [miterLimit][0] for more details.\n\n[0]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/miterLimit",
        "uiControl": {
            "type": "number",
            "min": "0",
            "step": "1",
            "default": "10"
        }
    },
    "data.itemStyle.shadowBlur": {
        "desc": " Size of shadow blur. This attribute should be used along with shadowColor,shadowOffsetX, shadowOffsetY to set shadow to component. For example: \n\n    {\n        shadowColor: 'rgba(0, 0, 0, 0.5)',\n        shadowBlur: 10\n    }\n    \n\n",
        "uiControl": {
            "type": "number",
            "default": "0",
            "min": "0",
            "step": "0.5"
        }
    },
    "data.itemStyle.shadowColor": {
        "desc": " Shadow color. Support same format as color. ",
        "uiControl": {
            "type": "color",
            "default": "''"
        }
    },
    "data.itemStyle.shadowOffsetX": {
        "desc": " Offset distance on the horizontal direction of shadow. ",
        "uiControl": {
            "type": "number",
            "default": "0",
            "step": "0.5"
        }
    },
    "data.itemStyle.shadowOffsetY": {
        "desc": " Offset distance on the vertical direction of shadow. ",
        "uiControl": {
            "type": "number",
            "default": "0",
            "step": "0.5"
        }
    },
    "data.itemStyle.opacity": {
        "desc": " Opacity of the component. Supports value from 0 to 1, and the component will not be drawn when set to 0. ",
        "uiControl": {
            "type": "number",
            "default": "1",
            "min": "0",
            "max": "1",
            "step": "0.01"
        }
    },
    "data.itemStyle.decal": {
        "desc": " The style of the decal pattern. It works only if [aria.enabled][0] and [aria.decal.show][1] are both set to be true. If it is set to be 'none', no decal will be used.\n\n[0]: #aria.enabled\n[1]: #aria.decal.show"
    },
    "data.itemStyle.decal.symbol": {
        "desc": " The symbol type of the decal. If it is in the type of string[], it means the symbols are used one by one. Icon types provided by ECharts includes 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow', 'none' It can be set to an image with 'image://url' , in which URL is the link to an image, or dataURI of an image. An image URL example: \n\n    'image://http://xxx.xxx.xxx/a/b.png'\n    \n\nA dataURI example: \n\n    'image://data:image/gif;base64,R0lGODlhEAAQAMQAAORHHOVSKudfOulrSOp3WOyDZu6QdvCchPGolfO0o/XBs/fNwfjZ0frl3/zy7////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAkAABAALAAAAAAQABAAAAVVICSOZGlCQAosJ6mu7fiyZeKqNKToQGDsM8hBADgUXoGAiqhSvp5QAnQKGIgUhwFUYLCVDFCrKUE1lBavAViFIDlTImbKC5Gm2hB0SlBCBMQiB0UjIQA7'\n    \n\nIcons can be set to arbitrary vector path via 'path://' in ECharts. As compared with a raster image, vector paths prevent jagging and blurring when scaled, and have better control over changing colors. The size of the vector icon will be adapted automatically. Refer to [SVG PathData][0] for more information about the format of the path. You may export vector paths from tools like Adobe For example: \n\n    'path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z'\n    \n\n[0]: http://www.w3.org/TR/SVG/paths.html#PathData"
    },
    "data.itemStyle.decal.symbolSize": {
        "desc": " Range of values: 0 to 1, representing the size of symbol relative to decal. "
    },
    "data.itemStyle.decal.symbolKeepAspect": {
        "desc": " Whether or not to keep the aspect ratio of the pattern. "
    },
    "data.itemStyle.decal.color": {
        "desc": " For the color of the decal pattern, it is recommended to use a translucent color, which can be superimposed on the color of the series itself. "
    },
    "data.itemStyle.decal.backgroundColor": {
        "desc": " The background color of the decal will be over the color of the series itself, under the decal pattern. "
    },
    "data.itemStyle.decal.dashArrayX": {
        "desc": " The basic pattern of the decal pattern is an infinite loop in the form of Pattern - Blank - Pattern - Blank - Pattern - Blank both horizontally and vertically, respectively. By setting the length of each pattern and blank, complex pattern effects can be achieved. dashArrayX controls the horizontal pattern pattern. When its value is of type number or number[], it is similar to [SVG stroke-dasharray][0]. \n\n* If it is of type number, it means that the pattern and the blank space are of this value respectively. For example, 5 means the pattern with width 5 is displayed first, then 5 pixels empty, then the pattern with width 5 is displayed...\n* In the case of number[] type, it means that the pattern and empty space are loops of an array of values. For example: [5, 10, 2, 6] means the pattern is 5 pixels wide, then 10 pixels empty, then the pattern is 2 pixels wide, then 6 pixels empty, then the pattern is 5 pixels wide...\n* If of type (number | number[])[], it means that each row is a loop with an array of values for the pattern and blank space. For example: [10, [2, 5]] means that the first line will be 10 pixels by 10 pixels and empty space, the second line will be 2 pixels by 2 pixels and empty space, and the third line will be 10 pixels by 10 pixels and empty space...\n\nThis interface can be better understood with the following examples. æš‚æ—¶æ— æ³•æ˜¾ç¤º\n\n[0]: https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray"
    },
    "data.itemStyle.decal.dashArrayY": {
        "desc": " The basic pattern of the decal pattern is an infinite loop in the form of Pattern - Blank - Pattern - Blank - Pattern - Blank both horizontally and vertically, respectively. By setting the length of each pattern and blank, complex pattern effects can be achieved. dashArrayY controls the horizontal pattern pattern. Similar to [SVG stroke-dasharray][0]. \n\n* If it is a number type, it means the pattern and the blank are each of this value. For example, 5 means that the pattern with a height of 5 is displayed first, then 5 pixels empty, then the pattern with a height of 5 is displayed...\n* In the case of number[] type, it means that the pattern and empty space are loops of sequential array values. For example: [5, 10, 2, 6] means the pattern is 5 pixels high, then 10 pixels empty, then the pattern is 2 pixels high, then 6 pixels empty, then the pattern is 5 pixels high...\n\nThis interface can be better understood with the following examples. æš‚æ—¶æ— æ³•æ˜¾ç¤º\n\n[0]: https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray"
    },
    "data.itemStyle.decal.rotation": {
        "desc": " The overall rotation angle (in radians) of the pattern, in the range from `-Math. "
    },
    "data.itemStyle.decal.maxTileWidth": {
        "desc": " The upper limit of the width of the generated pattern before it is duplicated. Usually this value is not necessary, but you can try to increase it if you notice discontinuous seams in the pattern when it repeats. "
    },
    "data.itemStyle.decal.maxTileHeight": {
        "desc": " The upper limit of the height of the generated pattern before it repeats. This value is usually not necessary to set, but you can try to increase it if you find that the pattern has discontinuous seams when it is repeated. "
    },
    "data.emphasis.itemStyle": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "data.emphasis.itemStyle.color": {
        "desc": " color. \n\n> Supports setting as solid color using > rgb(255,255,255)> , > rgba(255,255,255,1)> , > #fff> , etc. Also supports setting as gradient color and pattern fill, see [> option.color][0]>  for details \n\n[0]: #color",
        "uiControl": {
            "type": "color"
        }
    },
    "data.emphasis.itemStyle.borderColor": {
        "desc": " border color, whose format is similar to that of color. ",
        "uiControl": {
            "type": "color"
        }
    },
    "data.emphasis.itemStyle.borderWidth": {
        "desc": " border width. No border when it is set to be 0. border width. No border when it is set to be 0. ",
        "uiControl": {
            "type": "number",
            "value": "0",
            "min": "0",
            "step": "0.5",
            "default": "0"
        }
    },
    "data.emphasis.itemStyle.borderType": {
        "desc": " border type. Possible values are: \n\n* 'solid'\n* 'dashed'\n* 'dotted'\n\nSince v5.0.0, it can also be a number or a number array to specify the [dash array][0] of the line. With borderDashOffset , we can make the line style more flexible. For exampleï¼š \n\n    {\n    \n    borderType: [5, 10],\n    \n    borderDashOffset: 5\n    }\n    \n\n\n\n[0]: https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray",
        "uiControl": {
            "type": "enum",
            "options": "'solid','dashed','dotted'"
        }
    },
    "data.emphasis.itemStyle.borderDashOffset": {
        "desc": ">  Since > v5.0.0 To set the line dash offset. With borderType , we can make the line style more flexible. Refer to MDN [lineDashOffset][0] for more details.\n\n[0]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineDashOffset",
        "uiControl": {
            "type": "number",
            "min": "0",
            "step": "1",
            "default": "0"
        }
    },
    "data.emphasis.itemStyle.borderCap": {
        "desc": ">  Since > v5.0.0 To specify how to draw the end points of the line. Possible values are: \n\n* 'butt': The ends of lines are squared off at the endpoints.\n* 'round': The ends of lines are rounded.\n* 'square': The ends of lines are squared off by adding a box with an equal width and half the height of the line's thickness.\n\nDefault value is 'butt'. Refer to MDN [lineCap][0] for more details.\n\n[0]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineCap",
        "uiControl": {
            "type": "enum",
            "options": "'butt','round','square'"
        }
    },
    "data.emphasis.itemStyle.borderJoin": {
        "desc": ">  Since > v5.0.0 To determine the shape used to join two line segments where they meet. Possible values are: \n\n* 'bevel': Fills an additional triangular area between the common endpoint of connected segments, and the separate outside rectangular corners of each segment.\n* 'round': Rounds off the corners of a shape by filling an additional sector of disc centered at the common endpoint of connected segments. The radius for these rounded corners is equal to the line width.\n* 'miter': Connected segments are joined by extending their outside edges to connect at a single point, with the effect of filling an additional lozenge-shaped area. This setting is affected by the borderMiterLimit property.\n\nDefault value is 'bevel'. Refer to MDN [lineJoin][0] for more details.\n\n[0]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineJoin",
        "uiControl": {
            "type": "enum",
            "options": "'bevel','round','miter'"
        }
    },
    "data.emphasis.itemStyle.borderMiterLimit": {
        "desc": ">  Since > v5.0.0 To set the miter limit ratio. Only works when borderJoin is set as miter. Default value is 10. Negativeã€0ã€Infinity and NaN values are ignored. Refer to MDN [miterLimit][0] for more details.\n\n[0]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/miterLimit",
        "uiControl": {
            "type": "number",
            "min": "0",
            "step": "1",
            "default": "10"
        }
    },
    "data.emphasis.itemStyle.shadowBlur": {
        "desc": " Size of shadow blur. This attribute should be used along with shadowColor,shadowOffsetX, shadowOffsetY to set shadow to component. For example: \n\n    {\n        shadowColor: 'rgba(0, 0, 0, 0.5)',\n        shadowBlur: 10\n    }\n    \n\n",
        "uiControl": {
            "type": "number",
            "default": "0",
            "min": "0",
            "step": "0.5"
        }
    },
    "data.emphasis.itemStyle.shadowColor": {
        "desc": " Shadow color. Support same format as color. ",
        "uiControl": {
            "type": "color",
            "default": "''"
        }
    },
    "data.emphasis.itemStyle.shadowOffsetX": {
        "desc": " Offset distance on the horizontal direction of shadow. ",
        "uiControl": {
            "type": "number",
            "default": "0",
            "step": "0.5"
        }
    },
    "data.emphasis.itemStyle.shadowOffsetY": {
        "desc": " Offset distance on the vertical direction of shadow. ",
        "uiControl": {
            "type": "number",
            "default": "0",
            "step": "0.5"
        }
    },
    "data.emphasis.itemStyle.opacity": {
        "desc": " Opacity of the component. Supports value from 0 to 1, and the component will not be drawn when set to 0. ",
        "uiControl": {
            "type": "number",
            "default": "1",
            "min": "0",
            "max": "1",
            "step": "0.01"
        }
    },
    "data.tooltip": {
        "desc": " tooltip settings in this series data. "
    },
    "data.tooltip.position": {
        "desc": "\næç¤ºæ¡†æµ®å±‚çš„ä½ç½®ï¼Œé»˜è®¤ä¸è®¾ç½®æ—¶ä½ç½®ä¼šè·Ÿéšé¼ æ ‡çš„ä½ç½®ã€‚\n\nå¯é€‰ï¼š\n\n* Array\n\né€šè¿‡æ•°ç»„è¡¨ç¤ºæç¤ºæ¡†æµ®å±‚çš„ä½ç½®ï¼Œæ”¯æŒæ•°å­—è®¾ç½®ç»å¯¹ä½ç½®ï¼Œç™¾åˆ†æ¯”è®¾ç½®ç›¸å¯¹ä½ç½®ã€‚\n\nç¤ºä¾‹:\n```javascript\n// ç»å¯¹ä½ç½®ï¼Œç›¸å¯¹äºŽå®¹å™¨å·¦ä¾§ 10px, ä¸Šä¾§ 10 px\nposition: [10, 10]\n// ç›¸å¯¹ä½ç½®ï¼Œæ”¾ç½®åœ¨å®¹å™¨æ­£ä¸­é—´\nposition: ['50%', '50%']\n```\n\n* Function\n\nå›žè°ƒå‡½æ•°ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š\n\n```javascript\n(point: Array, params: Object|Array.<Object>, dom: HTMLDomElement, rect: Object, size: Object) => Array\n```\n\n**å‚æ•°**\npoint: é¼ æ ‡ä½ç½®ï¼Œå¦‚ [20, 40]ã€‚\nparams: åŒ formatter çš„å‚æ•°ç›¸åŒã€‚\ndom: tooltip çš„ dom å¯¹è±¡ã€‚\nrect: åªæœ‰é¼ æ ‡åœ¨å›¾å½¢ä¸Šæ—¶æœ‰æ•ˆï¼Œæ˜¯ä¸€ä¸ªç”¨ x , y , width , heightå››ä¸ªå±žæ€§è¡¨è¾¾çš„å›¾å½¢åŒ…å›´ç›’ã€‚\nsize: åŒ…æ‹¬ dom çš„å°ºå¯¸å’Œ echarts å®¹å™¨çš„å½“å‰å°ºå¯¸ï¼Œä¾‹å¦‚ï¼š{contentSize: [width, height], viewSize: [width, height]}ã€‚\n\n**è¿”å›žå€¼ï¼š**\nå¯ä»¥æ˜¯ä¸€ä¸ªè¡¨ç¤º tooltip ä½ç½®çš„æ•°ç»„ï¼Œæ•°ç»„å€¼å¯ä»¥æ˜¯ç»å¯¹çš„åƒç´ å€¼ï¼Œä¹Ÿå¯ä»¥æ˜¯ç›¸ ç™¾åˆ†æ¯”ã€‚\nä¹Ÿå¯ä»¥æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œå¦‚ï¼š{left: 10, top: 30}ï¼Œæˆ–è€… {right: '20%', bottom: 40}ã€‚\n\nå¦‚ä¸‹ç¤ºä¾‹ï¼š\n\n```javascript\nposition: function (point, params, dom, rect, size) {\n    // å›ºå®šåœ¨é¡¶éƒ¨\n    return [point[0], '10%'];\n}\n```\n\næˆ–è€…ï¼š\n\n```javascript\nposition: function (pos, params, dom, rect, size) {\n    // é¼ æ ‡åœ¨å·¦ä¾§æ—¶ tooltip æ˜¾ç¤ºåˆ°å³ä¾§ï¼Œé¼ æ ‡åœ¨å³ä¾§æ—¶ tooltip æ˜¾ç¤ºåˆ°å·¦ä¾§ã€‚\n    var obj = {top: 60};\n    obj[['left', 'right'][+(pos[0] < size.viewSize[0] / 2)]] = 5;\n    return obj;\n}\n```\n\n* 'inside'\n    é¼ æ ‡æ‰€åœ¨å›¾å½¢çš„å†…éƒ¨ä¸­å¿ƒä½ç½®ï¼Œåªåœ¨ trigger ä¸º 'item' çš„æ—¶å€™æœ‰æ•ˆã€‚\n\n* 'top'\n    é¼ æ ‡æ‰€åœ¨å›¾å½¢ä¸Šä¾§ï¼Œåªåœ¨ trigger ä¸º 'item' çš„æ—¶å€™æœ‰æ•ˆã€‚\n\n* 'left'\n    é¼ æ ‡æ‰€åœ¨å›¾å½¢å·¦ä¾§ï¼Œåªåœ¨ trigger ä¸º 'item' çš„æ—¶å€™æœ‰æ•ˆã€‚\n\n* 'right'\n    é¼ æ ‡æ‰€åœ¨å›¾å½¢å³ä¾§ï¼Œåªåœ¨ trigger ä¸º 'item' çš„æ—¶å€™æœ‰æ•ˆã€‚\n\n* 'bottom'\n    é¼ æ ‡æ‰€åœ¨å›¾å½¢åº•ä¾§ï¼Œåªåœ¨ trigger ä¸º 'item' çš„æ—¶å€™æœ‰æ•ˆã€‚\n"
    },
    "data.tooltip.formatter": {
        "desc": "**> Noticeï¼š**> series.data.tooltip only works when [> tooltip.trigger][0]>  is > 'item'> .  \nThe content formatter of tooltip's floating layer which supports string template and callback function. **1. String template** The template variables are {a}, {b}, {c}, {d} and {e}, which stands for series name, data name and data value and ect. When [trigger][0] is set to be 'axis', there may be data from multiple series. In this time, series index can be refered as {a0}, {a1}, or {a2}. {a}, {b}, {c}, {d} have different meanings for different series types: \n\n* Line (area) charts, bar (column) charts, K charts: {a} for series name, {b} for category name, {c} for data value, {d} for none;\n* Scatter (bubble) charts: {a} for series name, {b} for data name, {c} for data value, {d} for none;\n* Map: {a} for series name, {b} for area name, {c} for merging data, {d} for none;\n* Pie charts, gauge charts, funnel charts: {a} for series name, {b} for data item name, {c} for data value, {d} for percentage.\n\n**Example:**    formatter: '{b0}: {c0}  \n{b1}: {c1}'\n    \n\n**2. Callback function** The format of callback function: \n\n    (params: Object|Array, ticket: string, callback: (ticket: string, html: string)) => string | HTMLElement | HTMLElement[]\n    \n\nThe first parameter params is the data that the formatter needs. Its format is shown as follows: \n\n    {\n        componentType: 'series',\n        // Series type\n        seriesType: string,\n        // Series index in option.series\n        seriesIndex: number,\n        // Series name\n        seriesName: string,\n        // Data name, or category name\n        name: string,\n        // Data index in input data array\n        dataIndex: number,\n        // Original data as input\n        data: Object,\n        // Value of data. In most series it is the same as data.\n        // But in some series it is some part of the data (e.g., in map, radar)\n        value: number|Array|Object,\n        // encoding info of coordinate system\n        // Key: coord, like ('x' 'y' 'radius' 'angle')\n        // value: Must be an array, not null/undefined. Contain dimension indices, like:\n        // {\n        //     x: [2] // values on dimension index 2 are mapped to x axis.\n        //     y: [0] // values on dimension index 0 are mapped to y axis.\n        // }\n        encode: Object,\n        // dimension names list\n        dimensionNames: Array,\n        // data dimension index, for example 0 or 1 or 2 ...\n        // Only work in `radar` series.\n        dimensionIndex: number,\n        // Color of data\n        color: string,\n    \n    \n        // the percentage of pie chart\n        percent: number,\n    \n    \n    }\n    \n\nNote: the usage of encode and dimensionNames can be: If data is: \n\n    dataset: {\n        source: [\n            ['Matcha Latte', 43.3, 85.8, 93.7],\n            ['Milk Tea', 83.1, 73.4, 55.1],\n            ['Cheese Cocoa', 86.4, 65.2, 82.5],\n            ['Walnut Brownie', 72.4, 53.9, 39.1]\n        ]\n    }\n    \n\nWe can get values that corresponding to y axis by: \n\n    params.value[params.encode.y[0]]\n    \n\nIf data is: \n\n    dataset: {\n        dimensions: ['product', '2015', '2016', '2017'],\n        source: [\n            {product: 'Matcha Latte', '2015': 43.3, '2016': 85.8, '2017': 93.7},\n            {product: 'Milk Tea', '2015': 83.1, '2016': 73.4, '2017': 55.1},\n            {product: 'Cheese Cocoa', '2015': 86.4, '2016': 65.2, '2017': 82.5},\n            {product: 'Walnut Brownie', '2015': 72.4, '2016': 53.9, '2017': 39.1}\n        ]\n    }\n    \n\nWe can get values that corresponding to y axis by: \n\n    params.value[params.dimensionNames[params.encode.y[0]]]\n    \n\nWhen [trigger][0] is 'axis', or when tooltip is triggered by [axisPointer][1], params is the data array of multiple series. The content of each item of the array is the same as above. Besides, \n\n    {\n        componentType: 'series',\n        // Series type\n        seriesType: string,\n        // Series index in option.series\n        seriesIndex: number,\n        // Series name\n        seriesName: string,\n        // Data name, or category name\n        name: string,\n        // Data index in input data array\n        dataIndex: number,\n        // Original data as input\n        data: Object,\n        // Value of data. In most series it is the same as data.\n        // But in some series it is some part of the data (e.g., in map, radar)\n        value: number|Array|Object,\n        // encoding info of coordinate system\n        // Key: coord, like ('x' 'y' 'radius' 'angle')\n        // value: Must be an array, not null/undefined. Contain dimension indices, like:\n        // {\n        //     x: [2] // values on dimension index 2 are mapped to x axis.\n        //     y: [0] // values on dimension index 0 are mapped to y axis.\n        // }\n        encode: Object,\n        // dimension names list\n        dimensionNames: Array,\n        // data dimension index, for example 0 or 1 or 2 ...\n        // Only work in `radar` series.\n        dimensionIndex: number,\n        // Color of data\n        color: string,\n    \n    \n    \n    }\n    \n\nNote: the usage of encode and dimensionNames can be: If data is: \n\n    dataset: {\n        source: [\n            ['Matcha Latte', 43.3, 85.8, 93.7],\n            ['Milk Tea', 83.1, 73.4, 55.1],\n            ['Cheese Cocoa', 86.4, 65.2, 82.5],\n            ['Walnut Brownie', 72.4, 53.9, 39.1]\n        ]\n    }\n    \n\nWe can get values that corresponding to y axis by: \n\n    params.value[params.encode.y[0]]\n    \n\nIf data is: \n\n    dataset: {\n        dimensions: ['product', '2015', '2016', '2017'],\n        source: [\n            {product: 'Matcha Latte', '2015': 43.3, '2016': 85.8, '2017': 93.7},\n            {product: 'Milk Tea', '2015': 83.1, '2016': 73.4, '2017': 55.1},\n            {product: 'Cheese Cocoa', '2015': 86.4, '2016': 65.2, '2017': 82.5},\n            {product: 'Walnut Brownie', '2015': 72.4, '2016': 53.9, '2017': 39.1}\n        ]\n    }\n    \n\nWe can get values that corresponding to y axis by: \n\n    params.value[params.dimensionNames[params.encode.y[0]]]\n    \n\n**Note:**Using array to present all the parameters in ECharts 2.x is not supported anymore. The second parameter ticket is the asynchronous callback flag which should be used along with the third parameter callback when it is used. The third parameter callback is asynchronous callback. When the content of tooltip is acquired asynchronously, ticket and htm as introduced above can be used to update tooltip with callback. Example: \n\n    formatter: function (params, ticket, callback) {\n        $.get('detail?name=' + params.name, function (content) {\n            callback(ticket, toHTML(content));\n        });\n        return 'Loading';\n    }\n    \n\n\n\n[0]: #tooltip.trigger\n[1]: #xAxis.axisPointer"
    },
    "data.tooltip.backgroundColor": {
        "desc": "**> Noticeï¼š**> series.data.tooltip only works when [> tooltip.trigger][0]>  is > 'item'> .  \nThe background color of tooltip's floating layer.\n\n[0]: #tooltip.trigger"
    },
    "data.tooltip.borderColor": {
        "desc": "**> Noticeï¼š**> series.data.tooltip only works when [> tooltip.trigger][0]>  is > 'item'> .  \nThe border color of tooltip's floating layer.\n\n[0]: #tooltip.trigger",
        "uiControl": {
            "type": "color",
            "default": "'#333'"
        }
    },
    "data.tooltip.borderWidth": {
        "desc": "**> Noticeï¼š**> series.data.tooltip only works when [> tooltip.trigger][0]>  is > 'item'> .  \nThe border width of tooltip's floating layer.\n\n[0]: #tooltip.trigger",
        "uiControl": {
            "type": "number",
            "default": "0",
            "step": "0.5"
        }
    },
    "data.tooltip.padding": {
        "desc": "**> Noticeï¼š**> series.data.tooltip only works when [> tooltip.trigger][0]>  is > 'item'> .  \nThe floating layer of tooltip space around content. The unit is px. Default values for each position are 5. And they can be set to different values with left, right, top, and bottom. Examples: \n\n    // Set padding to be 5\n    padding: 5\n    // Set the top and bottom paddings to be 5, and left and right paddings to be 10\n    padding: [5, 10]\n    // Set each of the four paddings seperately\n    padding: [\n        5,  // up\n        10, // right\n        5,  // down\n        10, // left\n    ]\n    \n\n\n\n[0]: #tooltip.trigger",
        "uiControl": {
            "type": "vector",
            "min": "0",
            "dims": "T,R,B,L",
            "default": "0"
        }
    },
    "data.tooltip.textStyle": {
        "desc": "**> Noticeï¼š**> series.data.tooltip only works when [> tooltip.trigger][0]>  is > 'item'> .  \nThe text syle of tooltip's floating layer.\n\n[0]: #tooltip.trigger"
    },
    "data.tooltip.textStyle.color": {
        "desc": " text color. ",
        "uiControl": {
            "type": "color",
            "default": "'#fff'"
        }
    },
    "data.tooltip.textStyle.fontStyle": {
        "desc": " font style. Options are: \n\n* 'normal'\n* 'italic'\n* 'oblique'\n\n",
        "uiControl": {
            "type": "enum",
            "options": "'normal','italic','oblique'"
        }
    },
    "data.tooltip.textStyle.fontWeight": {
        "desc": " font thick weight. Options are: \n\n* 'normal'\n* 'bold'\n* 'bolder'\n* 'lighter'\n* 100 | 200 | 300 | 400...\n\n",
        "uiControl": {
            "type": "enum",
            "options": "'normal','bold','bolder','lighter'"
        }
    },
    "data.tooltip.textStyle.fontFamily": {
        "desc": " font family. Can also be 'serif' , 'monospace', ... ",
        "uiControl": {
            "type": "enum",
            "options": "'sans-serif','serif','monospace','Arial','Courier New'"
        }
    },
    "data.tooltip.textStyle.fontSize": {
        "desc": " font size. ",
        "uiControl": {
            "type": "number",
            "default": "14",
            "min": "1",
            "step": "1"
        }
    },
    "data.tooltip.textStyle.lineHeight": {
        "desc": " Line height of the text fragment. If lineHeight is not set in rich, lineHeight in parent level will be used. For example: \n\n    {\n        lineHeight: 56,\n        rich: {\n            a: {\n                // `lineHeight` is not set, then it will be 56\n            }\n        }\n    }\n    \n\n",
        "uiControl": {
            "type": "number",
            "min": "0",
            "step": "1",
            "default": "12"
        }
    },
    "data.tooltip.textStyle.width": {
        "desc": " Width of text block. ",
        "uiControl": {
            "type": "number",
            "default": "100",
            "min": "1",
            "max": "500",
            "step": "1"
        }
    },
    "data.tooltip.textStyle.height": {
        "desc": " Height of text block. ",
        "uiControl": {
            "type": "number",
            "default": "50",
            "min": "1",
            "max": "500",
            "step": "1"
        }
    },
    "data.tooltip.textStyle.textBorderColor": {
        "desc": " Storke color of the text. ",
        "uiControl": {
            "type": "color"
        }
    },
    "data.tooltip.textStyle.textBorderWidth": {
        "desc": " Storke line width of the text. ",
        "uiControl": {
            "type": "number",
            "min": "0",
            "step": "0.5",
            "default": "0"
        }
    },
    "data.tooltip.textStyle.textBorderType": {
        "desc": " Stroke line type of the text. Possible values are: \n\n* 'solid'\n* 'dashed'\n* 'dotted'\n\nSince v5.0.0, it can also be a number or a number array to specify the [dash array][0] of the line. With textBorderDashOffset , we can make the line style more flexible. For exampleï¼š \n\n    {\n    \n    textBorderType: [5, 10],\n    \n    textBorderDashOffset: 5\n    }\n    \n\n\n\n[0]: https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray",
        "uiControl": {
            "type": "enum",
            "options": "'solid','dashed','dotted'"
        }
    },
    "data.tooltip.textStyle.textBorderDashOffset": {
        "desc": ">  Since > v5.0.0 To set the line dash offset. With textBorderType , we can make the line style more flexible. Refer to MDN [lineDashOffset][0] for more details.\n\n[0]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineDashOffset",
        "uiControl": {
            "type": "number",
            "min": "0",
            "step": "1",
            "default": "0"
        }
    },
    "data.tooltip.textStyle.textShadowColor": {
        "desc": " Shadow color of the text itself. ",
        "uiControl": {
            "type": "color",
            "default": "'#000'"
        }
    },
    "data.tooltip.textStyle.textShadowBlur": {
        "desc": " Shadow blue of the text itself. ",
        "uiControl": {
            "type": "number",
            "min": "0",
            "step": "0.5",
            "default": "0"
        }
    },
    "data.tooltip.textStyle.textShadowOffsetX": {
        "desc": " Shadow X offset of the text itself. ",
        "uiControl": {
            "type": "number",
            "step": "0.5"
        }
    },
    "data.tooltip.textStyle.textShadowOffsetY": {
        "desc": " Shadow Y offset of the text itself. ",
        "uiControl": {
            "type": "number",
            "step": "0.5"
        }
    },
    "data.tooltip.textStyle.overflow": {
        "desc": " Determine how to display the text when it's overflow. Available when width is set. \n\n* 'truncate' Truncate the text and trailing with ellipsis.\n* 'break' Break by word\n* 'breakAll' Break by character.\n\n",
        "uiControl": {
            "type": "enum",
            "options": "'truncate','break','breakAll'"
        }
    },
    "data.tooltip.textStyle.ellipsis": {
        "desc": " Ellipsis to be displayed when overflow is set to truncate. "
    },
    "data.tooltip.textStyle.lineOverflow": {
        "desc": " Determine how to display the text when it's overflow on height. \n\n* 'truncate' Truncate the overflow lines.\n\n"
    },
    "data.tooltip.extraCssText": {
        "desc": "**> Noticeï¼š**> series.data.tooltip only works when [> tooltip.trigger][0]>  is > 'item'> .  \nExtra CSS style for floating layer. The following is an example for adding shadow. \n\n    extraCssText: 'box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);'\n    \n\n\n\n[0]: #tooltip.trigger",
        "uiControl": {
            "type": "text"
        }
    },
    "clip": {
        "desc": ">  Since > v4.4.0 If clip the overflow on the coordinate system. Clip results varies between series: \n\n* Scatter/EffectScatterï¼šIgnore the symbols exceeds the coordinate system. Not clip the elements.\n* Barï¼šClip all the overflowed. With bar width kept.\n* Lineï¼šClip the overflowed line.\n* Lines: Clip all the overflowed.\n* Candlestick: Ignore the elements exceeds the coordinate system.\n* Custom: Clip all the olverflowed.\n\nAll these series have default value true except custom series. Set it to false if you don't want to clip. ",
        "uiControl": {
            "type": "boolean",
            "default": "false"
        }
    },
    "zlevel": {
        "desc": "zlevel value of all graphical elements in custom series. zlevel is used to make layers with Canvas. Graphical elements with different zlevel values will be placed in different Canvases, which is a common optimization technique. We can put those frequently changed elements (like those with animations) to a separate zlevel. Notice that too many Canvases will increase memory cost, and should be used carefully on mobile phones to avoid crash. Canvases with bigger zlevel will be placed on Canvases with smaller zlevel. "
    },
    "z": {
        "desc": "z value of all graphical elements in custom series, which controls order of drawing graphical components. Components with smaller z values may be overwritten by those with larger z values. z has a lower priority to zlevel, and will not create new Canvas. "
    },
    "silent": {
        "desc": " Whether to ignore mouse events. Default value is false, for triggering and responding to mouse events. ",
        "uiControl": {
            "type": "boolean"
        }
    },
    "animation": {
        "desc": " Whether to enable animation. ",
        "uiControl": {
            "type": "boolean",
            "default": "true",
            "clean": "true"
        }
    },
    "animationThreshold": {
        "desc": " Whether to set graphic number threshold to animation. Animation will be disabled when graphic number is larger than threshold. "
    },
    "animationDuration": {
        "desc": " Duration of the first animation, which supports callback function for different data to have different animation effect: \n\n    animationDuration: function (idx) {\n        // delay for later data is larger\n        return idx * 100;\n    }\n    \n\n",
        "uiControl": {
            "type": "number",
            "min": "0",
            "default": "1000",
            "step": "20",
            "clean": "true"
        }
    },
    "animationEasing": {
        "desc": " Easing method used for the first animation. Varied easing effects can be found at [easing effect example][0].\n\n[0]: https://echarts.apache.org/examples/en/editor.html?c=line-easing",
        "uiControl": {
            "type": "enum",
            "options": "'linear','quadraticIn','quadraticOut','quadraticInOut','cubicIn','cubicOut','cubicInOut','quarticIn','quarticOut','quarticInOut','quinticIn','quinticOut','quinticInOut','sinusoidalIn','sinusoidalOut','sinusoidalInOut','exponentialIn','exponentialOut','exponentialInOut','circularIn','circularOut','circularInOut','elasticIn','elasticOut','elasticInOut','backIn','backOut','backInOut','bounceIn','bounceOut','bounceInOut'",
            "clean": "true"
        }
    },
    "animationDelay": {
        "desc": " Delay before updating the first animation, which supports callback function for different data to have different animation effect. For example: \n\n    animationDelay: function (idx) {\n        // delay for later data is larger\n        return idx * 100;\n    }\n    \n\nSee [this example][0] for more information.\n\n[0]: https://echarts.apache.org/examples/en/editor.html?c=bar-animation-delay"
    },
    "animationDurationUpdate": {
        "desc": " Time for animation to complete, which supports callback function for different data to have different animation effect: \n\n    animationDurationUpdate: function (idx) {\n        // delay for later data is larger\n        return idx * 100;\n    }\n    \n\n",
        "uiControl": {
            "type": "number",
            "min": "0",
            "default": "1000",
            "step": "20"
        }
    },
    "animationEasingUpdate": {
        "desc": " Easing method used for animation. ",
        "uiControl": {
            "type": "enum",
            "options": "'linear','quadraticIn','quadraticOut','quadraticInOut','cubicIn','cubicOut','cubicInOut','quarticIn','quarticOut','quarticInOut','quinticIn','quinticOut','quinticInOut','sinusoidalIn','sinusoidalOut','sinusoidalInOut','exponentialIn','exponentialOut','exponentialInOut','circularIn','circularOut','circularInOut','elasticIn','elasticOut','elasticInOut','backIn','backOut','backInOut','bounceIn','bounceOut','bounceInOut'"
        }
    },
    "animationDelayUpdate": {
        "desc": " Delay before updating animation, which supports callback function for different data to have different animation effects. For example: \n\n    animationDelayUpdate: function (idx) {\n        // delay for later data is larger\n        return idx * 100;\n    }\n    \n\nSee [this example][0] for more information.\n\n[0]: https://echarts.apache.org/examples/en/editor.html?c=bar-animation-delay"
    },
    "universalTransition": {
        "desc": " Configuration related to universal transition animation. Universal Transition provides the ability to morph between any series. With this feature enabled, each time setOption, transitions between series with the same id will be automatically associated with each other. One-to-many or many-to-one animations such as drill-down, aggregation, etc. can also be achieved by specifying groups of data such as encode.itemGroupId or dataGroupId. This can be enabled directly by configuring universalTransition: true in the series. It is also possible to provide an object for more detailed configuration. "
    },
    "universalTransition.enabled": {
        "desc": " Wheather to enable the universal transition animation. "
    },
    "universalTransition.seriesKey": {
        "desc": " The seriesKey determines how the series to be animated is associated, it defaults to the id of the series when not configured. Usually this is configured as a string, and transitions between series with the same seriesKey will be applied. It can also be configured as an array like the following. \n\n    seriesKey: ['male', 'female']\n    \n\nConfiguring to an array means that all series specified by the array item will be merged into the current series when animating. For example, this configuration means that series with id or seriesKey of 'male' and 'female' will be merged into the current series. "
    },
    "universalTransition.divideShape": {
        "desc": "divideShape determines how the elements in the current series will split into multiple elements in a one-to-many or many-to-one animation. Currently supports \n\n* 'split' Split the shape into multiple shapes.\n* 'clone' Get multiple clones from the current element.\n\nFor better results, different series will have different configurations by default, for example, [scatter][0] with smaller and more complex element uses 'clone' by default, while more regular ones like bar charts default to 'split'. You can set this to the desired splitting strategy according to the needs of your own scenario.\n\n[0]: #series-scatter"
    },
    "universalTransition.delay": {
        "desc": "    (index: number, count: number) => number\n    \n\nConfigure the animation delay for each shape in a one-to-many or many-to-one animation. Setting different animation delays can bring a more instereting animation. For example, the following code creates a staggered effect with a random delay for each shape. \n\n    delay: function (index, count) {\n        return Math.random() * 1000;\n    }\n    \n\n"
    },
    "tooltip": {
        "desc": " tooltip settings in this series. "
    },
    "tooltip.position": {
        "desc": "\næç¤ºæ¡†æµ®å±‚çš„ä½ç½®ï¼Œé»˜è®¤ä¸è®¾ç½®æ—¶ä½ç½®ä¼šè·Ÿéšé¼ æ ‡çš„ä½ç½®ã€‚\n\nå¯é€‰ï¼š\n\n* Array\n\né€šè¿‡æ•°ç»„è¡¨ç¤ºæç¤ºæ¡†æµ®å±‚çš„ä½ç½®ï¼Œæ”¯æŒæ•°å­—è®¾ç½®ç»å¯¹ä½ç½®ï¼Œç™¾åˆ†æ¯”è®¾ç½®ç›¸å¯¹ä½ç½®ã€‚\n\nç¤ºä¾‹:\n```javascript\n// ç»å¯¹ä½ç½®ï¼Œç›¸å¯¹äºŽå®¹å™¨å·¦ä¾§ 10px, ä¸Šä¾§ 10 px\nposition: [10, 10]\n// ç›¸å¯¹ä½ç½®ï¼Œæ”¾ç½®åœ¨å®¹å™¨æ­£ä¸­é—´\nposition: ['50%', '50%']\n```\n\n* Function\n\nå›žè°ƒå‡½æ•°ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š\n\n```javascript\n(point: Array, params: Object|Array.<Object>, dom: HTMLDomElement, rect: Object, size: Object) => Array\n```\n\n**å‚æ•°**\npoint: é¼ æ ‡ä½ç½®ï¼Œå¦‚ [20, 40]ã€‚\nparams: åŒ formatter çš„å‚æ•°ç›¸åŒã€‚\ndom: tooltip çš„ dom å¯¹è±¡ã€‚\nrect: åªæœ‰é¼ æ ‡åœ¨å›¾å½¢ä¸Šæ—¶æœ‰æ•ˆï¼Œæ˜¯ä¸€ä¸ªç”¨ x , y , width , heightå››ä¸ªå±žæ€§è¡¨è¾¾çš„å›¾å½¢åŒ…å›´ç›’ã€‚\nsize: åŒ…æ‹¬ dom çš„å°ºå¯¸å’Œ echarts å®¹å™¨çš„å½“å‰å°ºå¯¸ï¼Œä¾‹å¦‚ï¼š{contentSize: [width, height], viewSize: [width, height]}ã€‚\n\n**è¿”å›žå€¼ï¼š**\nå¯ä»¥æ˜¯ä¸€ä¸ªè¡¨ç¤º tooltip ä½ç½®çš„æ•°ç»„ï¼Œæ•°ç»„å€¼å¯ä»¥æ˜¯ç»å¯¹çš„åƒç´ å€¼ï¼Œä¹Ÿå¯ä»¥æ˜¯ç›¸ ç™¾åˆ†æ¯”ã€‚\nä¹Ÿå¯ä»¥æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œå¦‚ï¼š{left: 10, top: 30}ï¼Œæˆ–è€… {right: '20%', bottom: 40}ã€‚\n\nå¦‚ä¸‹ç¤ºä¾‹ï¼š\n\n```javascript\nposition: function (point, params, dom, rect, size) {\n    // å›ºå®šåœ¨é¡¶éƒ¨\n    return [point[0], '10%'];\n}\n```\n\næˆ–è€…ï¼š\n\n```javascript\nposition: function (pos, params, dom, rect, size) {\n    // é¼ æ ‡åœ¨å·¦ä¾§æ—¶ tooltip æ˜¾ç¤ºåˆ°å³ä¾§ï¼Œé¼ æ ‡åœ¨å³ä¾§æ—¶ tooltip æ˜¾ç¤ºåˆ°å·¦ä¾§ã€‚\n    var obj = {top: 60};\n    obj[['left', 'right'][+(pos[0] < size.viewSize[0] / 2)]] = 5;\n    return obj;\n}\n```\n\n* 'inside'\n    é¼ æ ‡æ‰€åœ¨å›¾å½¢çš„å†…éƒ¨ä¸­å¿ƒä½ç½®ï¼Œåªåœ¨ trigger ä¸º 'item' çš„æ—¶å€™æœ‰æ•ˆã€‚\n\n* 'top'\n    é¼ æ ‡æ‰€åœ¨å›¾å½¢ä¸Šä¾§ï¼Œåªåœ¨ trigger ä¸º 'item' çš„æ—¶å€™æœ‰æ•ˆã€‚\n\n* 'left'\n    é¼ æ ‡æ‰€åœ¨å›¾å½¢å·¦ä¾§ï¼Œåªåœ¨ trigger ä¸º 'item' çš„æ—¶å€™æœ‰æ•ˆã€‚\n\n* 'right'\n    é¼ æ ‡æ‰€åœ¨å›¾å½¢å³ä¾§ï¼Œåªåœ¨ trigger ä¸º 'item' çš„æ—¶å€™æœ‰æ•ˆã€‚\n\n* 'bottom'\n    é¼ æ ‡æ‰€åœ¨å›¾å½¢åº•ä¾§ï¼Œåªåœ¨ trigger ä¸º 'item' çš„æ—¶å€™æœ‰æ•ˆã€‚\n"
    },
    "tooltip.formatter": {
        "desc": "  \n**> Noticeï¼š**> series.tooltip only works when [> tooltip.trigger][0]>  is > 'item'> .  \nThe content formatter of tooltip's floating layer which supports string template and callback function. **1. String template** The template variables are {a}, {b}, {c}, {d} and {e}, which stands for series name, data name and data value and ect. When [trigger][0] is set to be 'axis', there may be data from multiple series. In this time, series index can be refered as {a0}, {a1}, or {a2}. {a}, {b}, {c}, {d} have different meanings for different series types: \n\n* Line (area) charts, bar (column) charts, K charts: {a} for series name, {b} for category name, {c} for data value, {d} for none;\n* Scatter (bubble) charts: {a} for series name, {b} for data name, {c} for data value, {d} for none;\n* Map: {a} for series name, {b} for area name, {c} for merging data, {d} for none;\n* Pie charts, gauge charts, funnel charts: {a} for series name, {b} for data item name, {c} for data value, {d} for percentage.\n\n**Example:**    formatter: '{b0}: {c0}  \n{b1}: {c1}'\n    \n\n**2. Callback function** The format of callback function: \n\n    (params: Object|Array, ticket: string, callback: (ticket: string, html: string)) => string | HTMLElement | HTMLElement[]\n    \n\nThe first parameter params is the data that the formatter needs. Its format is shown as follows: \n\n    {\n        componentType: 'series',\n        // Series type\n        seriesType: string,\n        // Series index in option.series\n        seriesIndex: number,\n        // Series name\n        seriesName: string,\n        // Data name, or category name\n        name: string,\n        // Data index in input data array\n        dataIndex: number,\n        // Original data as input\n        data: Object,\n        // Value of data. In most series it is the same as data.\n        // But in some series it is some part of the data (e.g., in map, radar)\n        value: number|Array|Object,\n        // encoding info of coordinate system\n        // Key: coord, like ('x' 'y' 'radius' 'angle')\n        // value: Must be an array, not null/undefined. Contain dimension indices, like:\n        // {\n        //     x: [2] // values on dimension index 2 are mapped to x axis.\n        //     y: [0] // values on dimension index 0 are mapped to y axis.\n        // }\n        encode: Object,\n        // dimension names list\n        dimensionNames: Array,\n        // data dimension index, for example 0 or 1 or 2 ...\n        // Only work in `radar` series.\n        dimensionIndex: number,\n        // Color of data\n        color: string,\n    \n    \n        // the percentage of pie chart\n        percent: number,\n    \n    \n    }\n    \n\nNote: the usage of encode and dimensionNames can be: If data is: \n\n    dataset: {\n        source: [\n            ['Matcha Latte', 43.3, 85.8, 93.7],\n            ['Milk Tea', 83.1, 73.4, 55.1],\n            ['Cheese Cocoa', 86.4, 65.2, 82.5],\n            ['Walnut Brownie', 72.4, 53.9, 39.1]\n        ]\n    }\n    \n\nWe can get values that corresponding to y axis by: \n\n    params.value[params.encode.y[0]]\n    \n\nIf data is: \n\n    dataset: {\n        dimensions: ['product', '2015', '2016', '2017'],\n        source: [\n            {product: 'Matcha Latte', '2015': 43.3, '2016': 85.8, '2017': 93.7},\n            {product: 'Milk Tea', '2015': 83.1, '2016': 73.4, '2017': 55.1},\n            {product: 'Cheese Cocoa', '2015': 86.4, '2016': 65.2, '2017': 82.5},\n            {product: 'Walnut Brownie', '2015': 72.4, '2016': 53.9, '2017': 39.1}\n        ]\n    }\n    \n\nWe can get values that corresponding to y axis by: \n\n    params.value[params.dimensionNames[params.encode.y[0]]]\n    \n\nWhen [trigger][0] is 'axis', or when tooltip is triggered by [axisPointer][1], params is the data array of multiple series. The content of each item of the array is the same as above. Besides, \n\n    {\n        componentType: 'series',\n        // Series type\n        seriesType: string,\n        // Series index in option.series\n        seriesIndex: number,\n        // Series name\n        seriesName: string,\n        // Data name, or category name\n        name: string,\n        // Data index in input data array\n        dataIndex: number,\n        // Original data as input\n        data: Object,\n        // Value of data. In most series it is the same as data.\n        // But in some series it is some part of the data (e.g., in map, radar)\n        value: number|Array|Object,\n        // encoding info of coordinate system\n        // Key: coord, like ('x' 'y' 'radius' 'angle')\n        // value: Must be an array, not null/undefined. Contain dimension indices, like:\n        // {\n        //     x: [2] // values on dimension index 2 are mapped to x axis.\n        //     y: [0] // values on dimension index 0 are mapped to y axis.\n        // }\n        encode: Object,\n        // dimension names list\n        dimensionNames: Array,\n        // data dimension index, for example 0 or 1 or 2 ...\n        // Only work in `radar` series.\n        dimensionIndex: number,\n        // Color of data\n        color: string,\n    \n    \n    \n    }\n    \n\nNote: the usage of encode and dimensionNames can be: If data is: \n\n    dataset: {\n        source: [\n            ['Matcha Latte', 43.3, 85.8, 93.7],\n            ['Milk Tea', 83.1, 73.4, 55.1],\n            ['Cheese Cocoa', 86.4, 65.2, 82.5],\n            ['Walnut Brownie', 72.4, 53.9, 39.1]\n        ]\n    }\n    \n\nWe can get values that corresponding to y axis by: \n\n    params.value[params.encode.y[0]]\n    \n\nIf data is: \n\n    dataset: {\n        dimensions: ['product', '2015', '2016', '2017'],\n        source: [\n            {product: 'Matcha Latte', '2015': 43.3, '2016': 85.8, '2017': 93.7},\n            {product: 'Milk Tea', '2015': 83.1, '2016': 73.4, '2017': 55.1},\n            {product: 'Cheese Cocoa', '2015': 86.4, '2016': 65.2, '2017': 82.5},\n            {product: 'Walnut Brownie', '2015': 72.4, '2016': 53.9, '2017': 39.1}\n        ]\n    }\n    \n\nWe can get values that corresponding to y axis by: \n\n    params.value[params.dimensionNames[params.encode.y[0]]]\n    \n\n**Note:**Using array to present all the parameters in ECharts 2.x is not supported anymore. The second parameter ticket is the asynchronous callback flag which should be used along with the third parameter callback when it is used. The third parameter callback is asynchronous callback. When the content of tooltip is acquired asynchronously, ticket and htm as introduced above can be used to update tooltip with callback. Example: \n\n    formatter: function (params, ticket, callback) {\n        $.get('detail?name=' + params.name, function (content) {\n            callback(ticket, toHTML(content));\n        });\n        return 'Loading';\n    }\n    \n\n\n\n[0]: #tooltip.trigger\n[1]: #xAxis.axisPointer"
    },
    "tooltip.backgroundColor": {
        "desc": "  \n**> Noticeï¼š**> series.tooltip only works when [> tooltip.trigger][0]>  is > 'item'> .  \nThe background color of tooltip's floating layer.\n\n[0]: #tooltip.trigger"
    },
    "tooltip.borderColor": {
        "desc": "  \n**> Noticeï¼š**> series.tooltip only works when [> tooltip.trigger][0]>  is > 'item'> .  \nThe border color of tooltip's floating layer.\n\n[0]: #tooltip.trigger",
        "uiControl": {
            "type": "color",
            "default": "'#333'"
        }
    },
    "tooltip.borderWidth": {
        "desc": "  \n**> Noticeï¼š**> series.tooltip only works when [> tooltip.trigger][0]>  is > 'item'> .  \nThe border width of tooltip's floating layer.\n\n[0]: #tooltip.trigger",
        "uiControl": {
            "type": "number",
            "default": "0",
            "step": "0.5"
        }
    },
    "tooltip.padding": {
        "desc": "  \n**> Noticeï¼š**> series.tooltip only works when [> tooltip.trigger][0]>  is > 'item'> .  \nThe floating layer of tooltip space around content. The unit is px. Default values for each position are 5. And they can be set to different values with left, right, top, and bottom. Examples: \n\n    // Set padding to be 5\n    padding: 5\n    // Set the top and bottom paddings to be 5, and left and right paddings to be 10\n    padding: [5, 10]\n    // Set each of the four paddings seperately\n    padding: [\n        5,  // up\n        10, // right\n        5,  // down\n        10, // left\n    ]\n    \n\n\n\n[0]: #tooltip.trigger",
        "uiControl": {
            "type": "vector",
            "min": "0",
            "dims": "T,R,B,L",
            "default": "0"
        }
    },
    "tooltip.textStyle": {
        "desc": "  \n**> Noticeï¼š**> series.tooltip only works when [> tooltip.trigger][0]>  is > 'item'> .  \nThe text syle of tooltip's floating layer.\n\n[0]: #tooltip.trigger"
    },
    "tooltip.textStyle.color": {
        "desc": " text color. ",
        "uiControl": {
            "type": "color",
            "default": "'#fff'"
        }
    },
    "tooltip.textStyle.fontStyle": {
        "desc": " font style. Options are: \n\n* 'normal'\n* 'italic'\n* 'oblique'\n\n",
        "uiControl": {
            "type": "enum",
            "options": "'normal','italic','oblique'"
        }
    },
    "tooltip.textStyle.fontWeight": {
        "desc": " font thick weight. Options are: \n\n* 'normal'\n* 'bold'\n* 'bolder'\n* 'lighter'\n* 100 | 200 | 300 | 400...\n\n",
        "uiControl": {
            "type": "enum",
            "options": "'normal','bold','bolder','lighter'"
        }
    },
    "tooltip.textStyle.fontFamily": {
        "desc": " font family. Can also be 'serif' , 'monospace', ... ",
        "uiControl": {
            "type": "enum",
            "options": "'sans-serif','serif','monospace','Arial','Courier New'"
        }
    },
    "tooltip.textStyle.fontSize": {
        "desc": " font size. ",
        "uiControl": {
            "type": "number",
            "default": "14",
            "min": "1",
            "step": "1"
        }
    },
    "tooltip.textStyle.lineHeight": {
        "desc": " Line height of the text fragment. If lineHeight is not set in rich, lineHeight in parent level will be used. For example: \n\n    {\n        lineHeight: 56,\n        rich: {\n            a: {\n                // `lineHeight` is not set, then it will be 56\n            }\n        }\n    }\n    \n\n",
        "uiControl": {
            "type": "number",
            "min": "0",
            "step": "1",
            "default": "12"
        }
    },
    "tooltip.textStyle.width": {
        "desc": " Width of text block. ",
        "uiControl": {
            "type": "number",
            "default": "100",
            "min": "1",
            "max": "500",
            "step": "1"
        }
    },
    "tooltip.textStyle.height": {
        "desc": " Height of text block. ",
        "uiControl": {
            "type": "number",
            "default": "50",
            "min": "1",
            "max": "500",
            "step": "1"
        }
    },
    "tooltip.textStyle.textBorderColor": {
        "desc": " Storke color of the text. ",
        "uiControl": {
            "type": "color"
        }
    },
    "tooltip.textStyle.textBorderWidth": {
        "desc": " Storke line width of the text. ",
        "uiControl": {
            "type": "number",
            "min": "0",
            "step": "0.5",
            "default": "0"
        }
    },
    "tooltip.textStyle.textBorderType": {
        "desc": " Stroke line type of the text. Possible values are: \n\n* 'solid'\n* 'dashed'\n* 'dotted'\n\nSince v5.0.0, it can also be a number or a number array to specify the [dash array][0] of the line. With textBorderDashOffset , we can make the line style more flexible. For exampleï¼š \n\n    {\n    \n    textBorderType: [5, 10],\n    \n    textBorderDashOffset: 5\n    }\n    \n\n\n\n[0]: https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray",
        "uiControl": {
            "type": "enum",
            "options": "'solid','dashed','dotted'"
        }
    },
    "tooltip.textStyle.textBorderDashOffset": {
        "desc": ">  Since > v5.0.0 To set the line dash offset. With textBorderType , we can make the line style more flexible. Refer to MDN [lineDashOffset][0] for more details.\n\n[0]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineDashOffset",
        "uiControl": {
            "type": "number",
            "min": "0",
            "step": "1",
            "default": "0"
        }
    },
    "tooltip.textStyle.textShadowColor": {
        "desc": " Shadow color of the text itself. ",
        "uiControl": {
            "type": "color",
            "default": "'#000'"
        }
    },
    "tooltip.textStyle.textShadowBlur": {
        "desc": " Shadow blue of the text itself. ",
        "uiControl": {
            "type": "number",
            "min": "0",
            "step": "0.5",
            "default": "0"
        }
    },
    "tooltip.textStyle.textShadowOffsetX": {
        "desc": " Shadow X offset of the text itself. ",
        "uiControl": {
            "type": "number",
            "step": "0.5"
        }
    },
    "tooltip.textStyle.textShadowOffsetY": {
        "desc": " Shadow Y offset of the text itself. ",
        "uiControl": {
            "type": "number",
            "step": "0.5"
        }
    },
    "tooltip.textStyle.overflow": {
        "desc": " Determine how to display the text when it's overflow. Available when width is set. \n\n* 'truncate' Truncate the text and trailing with ellipsis.\n* 'break' Break by word\n* 'breakAll' Break by character.\n\n",
        "uiControl": {
            "type": "enum",
            "options": "'truncate','break','breakAll'"
        }
    },
    "tooltip.textStyle.ellipsis": {
        "desc": " Ellipsis to be displayed when overflow is set to truncate. "
    },
    "tooltip.textStyle.lineOverflow": {
        "desc": " Determine how to display the text when it's overflow on height. \n\n* 'truncate' Truncate the overflow lines.\n\n"
    },
    "tooltip.extraCssText": {
        "desc": "  \n**> Noticeï¼š**> series.tooltip only works when [> tooltip.trigger][0]>  is > 'item'> .  \nExtra CSS style for floating layer. The following is an example for adding shadow. \n\n    extraCssText: 'box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);'\n    \n\n\n\n[0]: #tooltip.trigger",
        "uiControl": {
            "type": "text"
        }
    }
}